var documenterSearchIndex = {"docs":
[{"location":"library/function_index/#main-index","page":"Function index","title":"Index","text":"","category":"section"},{"location":"library/function_index/","page":"Function index","title":"Function index","text":"Pages = [\"public.md\", \"internals.md\", \"function_index.md\"]","category":"page"},{"location":"library/outline/#Library-Outline","page":"Contents","title":"Library Outline","text":"","category":"section"},{"location":"library/outline/","page":"Contents","title":"Contents","text":"Pages = [\"public.md\", \"internals.md\", \"function_index.md\"]","category":"page"},{"location":"library/internals/","page":"Private","title":"Private","text":"Private types and functions","category":"page"},{"location":"library/internals/","page":"Private","title":"Private","text":"Documentation for MimiqCircuitsBase.jl's internal interface.","category":"page"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [MimiqCircuitsBase]\nPublic  = false\nPages   = [\"MimiqCircuitsBase.jl\"]","category":"page"},{"location":"installation/#Installation-instructions","page":"Installation Instructions","title":"Installation instructions","text":"","category":"section"},{"location":"installation/","page":"Installation Instructions","title":"Installation Instructions","text":"Julia is required to use MimiqCircuitsBase.jl. If you do not have it on your system, please refer to the official website. We recommend to install Julia via the juliaup tool, which will manage updates and multiple versions of Julia on the same system automatically.","category":"page"},{"location":"installation/","page":"Installation Instructions","title":"Installation Instructions","text":"To install the latest version of MimiqCircuitsBase.jl, use the Julia's built-in package manager (accessed by pressing ] in the Julia REPL command prompt).","category":"page"},{"location":"installation/","page":"Installation Instructions","title":"Installation Instructions","text":"Before installing the package itself, since we didn't add it to the public Julia General registry, make sure to have installed QPerfect's own package registry.","category":"page"},{"location":"installation/","page":"Installation Instructions","title":"Installation Instructions","text":"julia> ]\n(v1.9) pkg> registry update\n(v1.9) pkg> registry add https://github.com/qperfect-io/QPerfectRegistry.git\n(v1.9) pkg> add MimiqCircuitsBase","category":"page"},{"location":"installation/","page":"Installation Instructions","title":"Installation Instructions","text":"note: Note\nThe ] registry update command will make sure, if this is your first time starting up Julia, to install and download the Julia General registry, where most packages are registered.","category":"page"},{"location":"#MimiqCircuitsBase.jl-Documentation","page":"Home","title":"MimiqCircuitsBase.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MimiqCircuitsBase provides a framework to build, manipulate, and analyze quantum circuits.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is an example on how to build a GHZ state with MimiqCircuitsBase. It has to be noted that this is not the optimal way to do it, but it is used here to showcase the syntax of MimiqCircuitsBase.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = quote\n    using MimiqCircuitsBase\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> c = Circuit()\nempty circuit\n\njulia> push!(c, GateH(), 1)\n1-qubit circuit with 1 instructions:\n└── H @ q1\n\njulia> push!(c, GateCX(), 1, 2:4)\n4-qubit circuit with 4 instructions:\n├── H @ q1\n├── CX @ q1, q2\n├── CX @ q1, q3\n└── CX @ q1, q4\n\njulia> push!(c, Barrier, 1:4...)\n4-qubit circuit with 5 instructions:\n├── H @ q1\n├── CX @ q1, q2\n├── CX @ q1, q3\n├── CX @ q1, q4\n└── Barrier @ q1, q2, q3, q4\n\njulia> for i in 1:4\n           push!(c, Measure(), i, i)\n       end\n\njulia> c\n4-qubit circuit with 9 instructions:\n├── H @ q1\n├── CX @ q1, q2\n├── CX @ q1, q3\n├── CX @ q1, q4\n├── Barrier @ q1, q2, q3, q4\n├── Measure @ q1, c1\n├── Measure @ q2, c2\n├── Measure @ q3, c3\n└── Measure @ q4, c4","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = nothing","category":"page"},{"location":"library/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Documentation for MimiqCircuitsBase.jl's public interface.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"See the Internals section of the manual for internal package docs.","category":"page"},{"location":"library/public/#MimiqCircuitsBase","page":"Public","title":"MimiqCircuitsBase","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"MimiqCircuitsBase.jl\"]","category":"page"},{"location":"library/public/#Quantum-Circuits-and-Instructions","page":"Public","title":"Quantum Circuits and Instructions","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"instruction.jl\", \"circuit.jl\", \"circuit_extras.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.Instruction","page":"Public","title":"MimiqCircuitsBase.Instruction","text":"struct Instruction{N,M,T<:Operation}\n\nElement of a quantum circuit, representing a N-qubit gate applied to N targets\n\nParameters\n\ngate::T actual gate represented\nqtargets::NTuple{N, Int64} indices specifying the quantum bits on which the instruction is applied\nctargets::NTuple{N, Int64} indices specifying the classical bits on which the instruction is applied\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.getbit","page":"Public","title":"MimiqCircuitsBase.getbit","text":"getbit(instruction, i)\n\nReturns the i-th target classical bit of an instruction.\n\nSee also getbits, getqubit, getqubits,\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.getbits","page":"Public","title":"MimiqCircuitsBase.getbits","text":"getbits(instruction)\n\nReturns all the classical bits to which the instruction is applied.\n\nSee also getbit, getqubits, getqubit,\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.getoperation-Tuple{Instruction}","page":"Public","title":"MimiqCircuitsBase.getoperation","text":"getoperation(instruction)\n\nReturns the quantum operation associated to the given instruction.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#MimiqCircuitsBase.getqubit","page":"Public","title":"MimiqCircuitsBase.getqubit","text":"getqubit(instruction, i)\n\nReturns the i-th target qubit of an instruction.\n\nSee also getqubits, getbit, getbits,\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.getqubits","page":"Public","title":"MimiqCircuitsBase.getqubits","text":"getqubits(instruction)\n\nReturns all the quantum bits to which the instruction is applied.\n\nSee also getqubit, getbits, getbit,\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.Circuit","page":"Public","title":"MimiqCircuitsBase.Circuit","text":"struct Circuit\n\nRepresentation of a quantum circuit as a vector of gates applied to the qubits.\n\nParameters\n\ngates::Vector{Instruction} vector of quantum instructions (see\n\nInstruction)\n\nExamples\n\nAdding operations to a circuit\n\nOperation can be added one by one to a circuit with the push!(circuit, operation, targets...) function\n\nc = Circuit()\npush!(c, GateH(), 1)\npush!(c, GateCX(), 1, 2)\npush!(c, GateRX(π / 4), 1)\npush!(c, Barrier, 1, 3)\npush!(c, Measure(), 1, 1)\n\nTargets are not restricted to be single values, but also vectors. In this case a single push! will add multiple operations. The behaviour is similar to Iterators.product. For example:\n\npush!(c, GateCX(), 1, 2:4)\n\nis equivalent to\n\nfor targets in Iterators.product(1, 2:4)\n    push!(c, GateCX(), targets...)\nend\n\nFor example\n\nc = Circuit()\npush!(c, GateH(),1:3)\npush!(c,GateCX(),1:3,4:6)\n\nSome operations behave a bit differently. See also: Barrier and Measure\n\nAvailable operations\n\nGates\n\nSingle qubit gates\n\nGateX GateY GateZ GateH GateS GateSDG GateT GateTDG GateSX GateSXDG GateID\n\nSingle qubit gates (parametric)\n\nGateRX GateRY GateRZ GateP GateR GateU\n\nTwo qubit gates\n\nGateCX GateCY GateCZ GateCH GateSWAP GateISWAP, GateISWAPDG\n\nTwo qubit gates (parametric)\n\nGateCP GateCRX GateCRY GateCRZ GateCU\n\nOther\n\nGateCustom\n\nNo-ops\n\nBarrier\n\nNon-unitary operations\n\nReset Measure\n\nComposite operations\n\nControl Parallel IfStatement\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.depth-Tuple{Circuit}","page":"Public","title":"MimiqCircuitsBase.depth","text":"depth(circuit)\n\nCompute the depth of a quantum circuit.\n\nThe depth of a quantum circuit is a metric computing the maximum time (in units of quantum gates application) between the input and output of the circuit.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#Operations","page":"Public","title":"Operations","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"operation.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.Operation","page":"Public","title":"MimiqCircuitsBase.Operation","text":"abstract type Operation{N,M}\n\nParameters\n\nN: number of qubits the operation applies on.\nM: number of bits the operation applies on.\n\nMethods\n\nopname\ninverse\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.hilbertspacedim","page":"Public","title":"MimiqCircuitsBase.hilbertspacedim","text":"hilbertspacedim(gate)\nhilberspacedim(circuit)\n\nHilbert space dimension for the given operation.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.inverse","page":"Public","title":"MimiqCircuitsBase.inverse","text":"inverse(circuit)\ninverse(instruction)\ninverse(operation)\n\nReturn the inverse of the given operation.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.numbits","page":"Public","title":"MimiqCircuitsBase.numbits","text":"numbits(instruction)\nnumbits(circuit)\n\nNumber of classical bits on which the given operation or instruction is defined.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.numqubits","page":"Public","title":"MimiqCircuitsBase.numqubits","text":"numqubits(gate)\nnumqubits(barrier)\nnumqubits(instruction)\nnumqubits(circuit)\n\nNumber of qubits on which the given operation or instruction is defined.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.opname","page":"Public","title":"MimiqCircuitsBase.opname","text":"opname(instruction)\nopname(operation)\n\nReturns the name of the given operation in a human readable format.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Gates","page":"Public","title":"Gates","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"gate.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.Gate","page":"Public","title":"MimiqCircuitsBase.Gate","text":"abstract type Gate{N} <: Operation{N}\n\nSupertype for all the N-qubit gates.\n\nMethods\n\ninverse\nnumqubits\nopname\nhilbertspacedim\nmatrix\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.ParametricGate","page":"Public","title":"MimiqCircuitsBase.ParametricGate","text":"abstract type ParametricGate{N}\n\nSupertype for all the parametric N-qubit gates.\n\nMethods\n\ninverse\nnumqubits\nopname\nhilbertspacedim\nmatrix\nnumparams\nparnames\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.matrix","page":"Public","title":"MimiqCircuitsBase.matrix","text":"matrix(gate)\n\nReturn the matrix associated to the specified quantum gate.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.numparams","page":"Public","title":"MimiqCircuitsBase.numparams","text":"numparams(gate)\n\nNumber of parameters for the given parametric gate. Zero for non parametric gates.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.parnames","page":"Public","title":"MimiqCircuitsBase.parnames","text":"parnames(gate)\n\nName of the parameters allowed for the given gate\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Single-qubit-gates","page":"Public","title":"Single qubit gates","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"singlequbit.jl\", \"singlequbitpar.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.GateH","page":"Public","title":"MimiqCircuitsBase.GateH","text":"struct GateH <: Gate{1}\n\nSingle qubit Hadamard gate.\n\nMatrix Representation\n\noperatorname H = frac1sqrt2\nbeginpmatrix\n    1  1 \n    1  -1\nendpmatrix\n\nExamples\n\njulia> matrix(GateH())\n2×2 Matrix{Float64}:\n 0.707107   0.707107\n 0.707107  -0.707107\n\njulia> push!(Circuit(), GateH(), 1)\n1-qubit circuit with 1 instructions:\n└── H @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateID","page":"Public","title":"MimiqCircuitsBase.GateID","text":"struct GateID <: Gate{1}\n\nSingle qubit Identity gate\n\nMatrix Representation\n\noperatornameI =\nbeginpmatrix\n    1  0 \n    0  1\nendpmatrix\n\nExamples\n\njulia> matrix(GateID())\n2×2 Matrix{Float64}:\n 1.0  -0.0\n 0.0   1.0\n\njulia> push!(Circuit(), GateID(), 1)\n1-qubit circuit with 1 instructions:\n└── ID @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateS","page":"Public","title":"MimiqCircuitsBase.GateS","text":"struct GateS <: Gate{1}\n\nSingle qubit S gate (or Phase gate).\n\nSee also GateSDG\n\nMatrix Representation\n\noperatorname S =\nbeginpmatrix\n    1  0 \n    0  i\nendpmatrix\n\nExamples\n\njulia> matrix(GateS())\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+1.0im\n\njulia> push!(Circuit(), GateS(), 1)\n1-qubit circuit with 1 instructions:\n└── S @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateSDG","page":"Public","title":"MimiqCircuitsBase.GateSDG","text":"struct GateSDG <: Gate{1}\n\nSingle qubit S-dagger gate (conjugate transpose of the S gate).\n\nSee also GateS\n\nMatrix Representation\n\noperatorname S^dagger =\nbeginpmatrix\n    1  0 \n    0  -i\nendpmatrix\n\nExamples\n\njulia> matrix(GateSDG())\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0-1.0im\n\njulia> push!(Circuit(), GateSDG(), 1)\n1-qubit circuit with 1 instructions:\n└── SDG @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateSX","page":"Public","title":"MimiqCircuitsBase.GateSX","text":"struct GateSX <: Gate{1}\n\nSingle qubit √X gate.\n\nSee also GateSXDG, GateX\n\nMatrix Representation\n\nsqrtoperatornameX = frac12\nbeginpmatrix\n    1+i  1-i \n    1-i  1+i\nendpmatrix\n\nExamples\n\njulia> matrix(GateSX())\n2×2 Matrix{ComplexF64}:\n 0.5+0.5im  0.5-0.5im\n 0.5-0.5im  0.5+0.5im\n\njulia> push!(Circuit(), GateSX(), 1)\n1-qubit circuit with 1 instructions:\n└── SX @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateSXDG","page":"Public","title":"MimiqCircuitsBase.GateSXDG","text":"struct GateSXDG <: Gate{1}\n\nSingle qubit √X-dagger gate (conjugate transpose of the √X gate)\n\nSee also GateSX, GateX\n\nMatrix Representation\n\nsqrtoperatornameX^dagger = frac12\nbeginpmatrix\n    1-i  1+i \n    1+i  1-i\nendpmatrix\n\nExamples\n\njulia> matrix(GateSXDG())\n2×2 Matrix{ComplexF64}:\n 0.5-0.5im  0.5+0.5im\n 0.5+0.5im  0.5-0.5im\n\njulia> push!(Circuit(), GateSXDG(), 1)\n1-qubit circuit with 1 instructions:\n└── SXDG @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateT","page":"Public","title":"MimiqCircuitsBase.GateT","text":"struct GateT <: Gate{1}\n\nSingle qubit T gate.\n\nSee also GateTDG\n\nMatrix Representation\n\noperatorname T =\nbeginpmatrix\n    1  0 \n    0  exp(fracipi4)\nendpmatrix\n\nExamples\n\njulia> matrix(GateT())\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.707107+0.707107im\n\njulia> push!(Circuit(), GateT(), 1)\n1-qubit circuit with 1 instructions:\n└── T @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateTDG","page":"Public","title":"MimiqCircuitsBase.GateTDG","text":"struct GateTDG <: Gate{1}\n\nSingle qubit T-dagger gate (conjugate transpose of the T gate).\n\nSee also GateT\n\nMatrix Representation\n\noperatorname T^dagger =\nbeginpmatrix\n    1  0 \n    0  exp(frac-ipi4)\nendpmatrix\n\nExamples\n\njulia> matrix(GateTDG())\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.707107-0.707107im\n\njulia> push!(Circuit(), GateTDG(), 1)\n1-qubit circuit with 1 instructions:\n└── TDG @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateX","page":"Public","title":"MimiqCircuitsBase.GateX","text":"struct GateX <: Gate{1}\n\nSingle qubit Pauli-X gate.\n\nMatrix Representation\n\noperatorname X =\nbeginpmatrix\n    0  1 \n    1  0\nendpmatrix\n\nExamples\n\njulia> matrix(GateX())\n2×2 Matrix{Float64}:\n 0.0   1.0\n 1.0  -0.0\n\njulia> push!(Circuit(), GateX(), 1)\n1-qubit circuit with 1 instructions:\n└── X @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateY","page":"Public","title":"MimiqCircuitsBase.GateY","text":"struct GateY <: Gate{1}\n\nSingle qubit Pauli-Y gate.\n\nMatrix Representation\n\noperatorname Y =\nbeginpmatrix\n    0  -i \n    i  0\nendpmatrix\n\nExamples\n\njulia> matrix(GateY())\n2×2 Matrix{ComplexF64}:\n 0.0+0.0im  -0.0-1.0im\n 0.0+1.0im  -0.0+0.0im\n\njulia> push!(Circuit(), GateY(), 1)\n1-qubit circuit with 1 instructions:\n└── Y @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateZ","page":"Public","title":"MimiqCircuitsBase.GateZ","text":"struct GateZ <: Gate{1}\n\nSingle qubit Pauli-Z gate.\n\nMatrix Representation\n\noperatorname Z =\nbeginpmatrix\n    1  0 \n    0  -1\nendpmatrix\n\nExamples\n\njulia> matrix(GateZ())\n2×2 Matrix{Float64}:\n 1.0   0.0\n 0.0  -1.0\n\njulia> push!(Circuit(), GateZ(), 1)\n1-qubit circuit with 1 instructions:\n└── Z @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateP","page":"Public","title":"MimiqCircuitsBase.GateP","text":"struct GateP <: ParametricGate{1}\n\nSingle qubit Phase gate.\n\nArguments\n\nλ::Float64: Phase angle in radians\n\nMatrix Representation\n\noperatorname P(lambda) =\nbeginpmatrix\n    1  0 \n    0  e^ilambda\nendpmatrix\n\nExamples\n\njulia> matrix(GateP(pi/4))\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.707107+0.707107im\n\njulia> push!(Circuit(), GateP(pi/4), 1)\n1-qubit circuit with 1 instructions:\n└── P(λ=0.7853981633974483) @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateR","page":"Public","title":"MimiqCircuitsBase.GateR","text":"struct GateR <: ParametricGate{1}\n\nSingle qubit Rotation gate around the axis cos(ϕ)x + sin(ϕ)y.\n\nArguments\n\nθ::Float64: Rotation angle in radians\nϕ::Float64: Axis of rotation in radians\n\nMatrix Representation\n\noperatorname R(thetaphi) = beginpmatrix\n          cosfractheta2  -ie^-iphisinfractheta2 \n          -ie^-iphisinfractheta2  cosfractheta2\n      endpmatrix\n\nExamples\n\njulia> matrix(GateR(pi/2,pi/4))\n2×2 Matrix{ComplexF64}:\n 0.707107+0.0im      -0.5-0.5im\n      0.5-0.5im  0.707107+0.0im\n\njulia> push!(Circuit(), GateR(pi/2,pi/4), 1)\n1-qubit circuit with 1 instructions:\n└── R(θ=1.5707963267948966, ϕ=0.7853981633974483) @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateRX","page":"Public","title":"MimiqCircuitsBase.GateRX","text":"struct GateRX <: ParametricGate{1}\n\nSingle qubit Rotation-X gate (RX gate)\n\nArguments\n\nθ::Float64: Rotation angle in radians\n\nMatrix Representation\n\noperatornameRX(theta) = beginpmatrix\n          cosfractheta2  -isinfractheta2 \n          -isinfractheta2  cosfractheta2\n      endpmatrix\n\nExamples\n\njulia> matrix(GateRX(pi/2))\n2×2 Matrix{ComplexF64}:\n 0.707107+0.0im           -0.0-0.707107im\n      0.0-0.707107im  0.707107+0.0im\n\njulia> push!(Circuit(), GateRX(pi/2), 1)\n1-qubit circuit with 1 instructions:\n└── RX(θ=1.5707963267948966) @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateRY","page":"Public","title":"MimiqCircuitsBase.GateRY","text":"struct GateRY <: ParametricGate{1}\n\nSingle qubit Rotation-Y gate (RY gate)\n\nArguments\n\nθ::Float64: Rotation angle in radians\n\nMatrix Representation\n\noperatornameRY(theta) = beginpmatrix\n          cosfractheta2  -sinfractheta2 \n          sinfractheta2  cosfractheta2\n      endpmatrix\n\nExamples\n\njulia> matrix(GateRY(pi/2))\n2×2 Matrix{Float64}:\n 0.707107  -0.707107\n 0.707107   0.707107\n\njulia> push!(Circuit(), GateRY(pi/2), 1)\n1-qubit circuit with 1 instructions:\n└── RY(θ=1.5707963267948966) @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateRZ","page":"Public","title":"MimiqCircuitsBase.GateRZ","text":"struct GateRZ <: ParametricGate{1}\n\nSingle qubit Rotation-Z gate (RZ gate)\n\nArguments\n\nλ::Float64: Rotation angle in radians\n\nMatrix Representation\n\noperatornameRZ(lambda) =\nbeginpmatrix\n    e^-ifraclambda2  0 \n    0  e^ifraclambda2\nendpmatrix\n\nExamples\n\njulia> matrix(GateRZ(pi/2))\n2×2 Matrix{ComplexF64}:\n 0.707107-0.707107im      -0.0+0.0im\n      0.0+0.0im       0.707107+0.707107im\n\njulia> push!(Circuit(), GateRZ(pi/2), 1)\n1-qubit circuit with 1 instructions:\n└── RZ(λ=1.5707963267948966) @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateU","page":"Public","title":"MimiqCircuitsBase.GateU","text":"struct GateU <: ParametricGate{1}\n\nOne qubit generic unitary gate, as defined in OpenQASM 3.0.\n\nArguments\n\nθ::Float64: Euler angle 1 in radians\nϕ::Float64: Euler angle 2 in radians\nλ::Float64: Euler angle 3 in radians\n\nMatrix Representation\n\noperatornameU(thetaphilambda) = beginpmatrix\n          cosfractheta2  -e^ilambdasinfractheta2 \n          e^iphisinfractheta2  e^i(phi+lambda)cosfractheta2\n      endpmatrix\n\nExamples\n\njulia> matrix(GateU(pi/3, pi/3, pi/3))\n2×2 Matrix{ComplexF64}:\n 0.866025+0.0im           -0.25-0.433013im\n     0.25+0.433013im  -0.433013+0.75im\n\njulia> push!(Circuit(), GateU(pi/3, pi/3, pi/3), 1)\n1-qubit circuit with 1 instructions:\n└── U(θ=1.0471975511965976, ϕ=1.0471975511965976, λ=1.0471975511965976) @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateU1","page":"Public","title":"MimiqCircuitsBase.GateU1","text":"struct GateU1 <: ParametricGate{1}\n\nOne qubit generic unitary gate u1, as defined in OpenQASM 3.0\n\nEquivalent to GateP\n\nArguments\n\nλ::Float64: Rotation angle in radians\n\nMatrix Representation\n\noperatornameU1(lambda) =\nbeginpmatrix\n    1  0 \n    0  e^ilambda\nendpmatrix\n\nExamples\n\njulia> matrix(GateU1(pi/4))\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.707107+0.707107im\n\njulia> push!(Circuit(), GateU1(pi/4), 1)\n1-qubit circuit with 1 instructions:\n└── U1(λ=0.7853981633974483) @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateU2","page":"Public","title":"MimiqCircuitsBase.GateU2","text":"struct GateU2 <: ParametricGate{1}\n\nOne qubit generic unitary gate u2, as defined in OpenQASM 3.0\n\nSee also GateU2DG.\n\nArguments\n\nϕ:Float64: Rotation angle in radians\nλ::Float64: Rotation angle in radians\n\nExamples\n\njulia> matrix(GateU2(pi/2,pi/4))\n2×2 Matrix{ComplexF64}:\n 0.270598-0.653281im  -0.653281+0.270598im\n 0.653281+0.270598im   0.270598+0.653281im\n\njulia> push!(Circuit(), GateU2(pi/4,pi/4), 1)\n1-qubit circuit with 1 instructions:\n└── U2(ϕ=0.7853981633974483, λ=0.7853981633974483) @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateU2DG","page":"Public","title":"MimiqCircuitsBase.GateU2DG","text":"struct GateU2DG <: ParametricGate{1}\n\nOne qubit generic unitary gate u2-dagger, as defined in OpenQASM 3.0 for backwards compatibility\n\nSee also GateU2\n\nArguments\n\nϕ:Float64: Rotation angle in radians\nλ::Float64: Rotation angle in radians\n\nExamples\n\njulia> matrix(GateU2DG(pi/2,pi/4))\n2×2 Matrix{ComplexF64}:\n  0.270598+0.653281im  0.653281-0.270598im\n -0.653281-0.270598im  0.270598-0.653281im\n\njulia> push!(Circuit(), GateU2DG(pi/2,pi/4), 1)\n1-qubit circuit with 1 instructions:\n└── U2DG(ϕ=1.5707963267948966, λ=0.7853981633974483) @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateU3","page":"Public","title":"MimiqCircuitsBase.GateU3","text":"struct GateU3 <: ParametricGate{1}\n\nOne qubit generic unitary gate u3, as defined in OpenQASM 3.0 for backwards compatibility.\n\nArguments\n\nθ:Float64: Rotation angle 1 in radians\nϕ:Float64: Rotation angle 2 in radians\nλ::Float64: Rotation angle 3 in radians\n\nExamples\n\njulia> matrix(GateU3(pi/2,pi/4,pi/2))\n2×2 Matrix{ComplexF64}:\n 0.270598-0.653281im  -0.653281-0.270598im\n 0.653281-0.270598im   0.270598+0.653281im\n\njulia> push!(Circuit(), GateU3(pi/2, pi/4, pi/2), 1)\n1-qubit circuit with 1 instructions:\n└── U3(θ=1.5707963267948966, ϕ=0.7853981633974483, λ=1.5707963267948966) @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Two-qubit-gates","page":"Public","title":"Two-qubit gates","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"twoqubit.jl\", \"twoqubitpar.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.GateCH","page":"Public","title":"MimiqCircuitsBase.GateCH","text":"struct GateCH <: Gate{2}\n\nTwo qubit Controlled-Hadamard gate.\n\nMatrix Representation\n\noperatornameCH = beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  frac1sqrt2  frac1sqrt2 \n    0  0  frac1sqrt2  -frac1sqrt2\nendpmatrix\n\nBy convention we refer to the first qubit as the control qubit and the second qubit as the target.\n\nExamples\n\njulia> matrix(GateCH())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0        0.0\n 0.0  1.0  0.0        0.0\n 0.0  0.0  0.707107   0.707107\n 0.0  0.0  0.707107  -0.707107\n\njulia> push!(Circuit(), GateCH(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CH @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCS","page":"Public","title":"MimiqCircuitsBase.GateCS","text":"struct GateCS <: Gate{2}\n\nTwo qubit Controlled-S gate.\n\nMatrix Representation\n\nbeginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  1  0 \n    0  0  0  i\nendpmatrix\n\nExamples\n\njulia> matrix(GateCS())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+1.0im\n\njulia> push!(Circuit(), GateCS(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CS @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCSDG","page":"Public","title":"MimiqCircuitsBase.GateCSDG","text":"struct GateCSDG <: Gate{2}\n\nTwo qubit CS-dagger gate.\n\nMatrix Representation\n\nbeginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  1  0 \n    0  0  0  i\nendpmatrix\n\nExamples\n\njulia> matrix(GateCSDG())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0-1.0im\n\njulia> push!(Circuit(), GateCSDG(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CSDG @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCSX","page":"Public","title":"MimiqCircuitsBase.GateCSX","text":"struct GateCSX <: Gate{2}\n\nTwo qubit Controlled-SX gate. (Control on second qubit)\n\nMatrix Representation\n\nbeginpmatrix\n    1  0  0  0 \n    0  frac1+isqrt2  0  frac1-isqrt2 \n    0  0  1  0 \n    0  frac1-isqrt2  0  frac1+isqrt2\nendpmatrix\n\nExamples\n\njulia> matrix(GateCSX())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.5+0.5im  0.0+0.0im  0.5-0.5im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.5-0.5im  0.0+0.0im  0.5+0.5im\n\njulia> push!(Circuit(), GateCSX(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CSX @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCSXDG","page":"Public","title":"MimiqCircuitsBase.GateCSXDG","text":"struct GateCSXDG <: Gate{2}\n\nTwo qubit CSX-dagger gate. (Control on second qubit)\n\nMatrix Representation\n\nbeginpmatrix\n    1  0  0  0 \n    0  frac1-isqrt2  0  frac1+isqrt2 \n    0  0  1  0 \n    0  frac1+isqrt2  0  frac1-isqrt2\nendpmatrix\n\nExamples\n\njulia> matrix(GateCSXDG())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.5-0.5im  0.0+0.0im  0.5+0.5im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.5+0.5im  0.0+0.0im  0.5-0.5im\n\njulia> push!(Circuit(), GateCSXDG(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CSXDG @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCX","page":"Public","title":"MimiqCircuitsBase.GateCX","text":"struct GateCX <: Gate{2}\n\nTwo qubit Controlled-X gate (or CNOT).\n\nMatrix Representation\n\noperatornameCX =\nbeginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  0  1 \n    0  0  1  0\nendpmatrix\n\nBy convention we refer to the first qubit as the control qubit and the second qubit as the target.\n\nExamples\n\njulia> matrix(GateCX())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0   0.0\n 0.0  1.0  0.0   0.0\n 0.0  0.0  0.0   1.0\n 0.0  0.0  1.0  -0.0\n\n\njulia> push!(Circuit(), GateCX(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CX @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCY","page":"Public","title":"MimiqCircuitsBase.GateCY","text":"struct GateCY <: Gate{2}\n\nTwo qubit Controlled-Y gate.\n\nMatrix Representation\n\noperatornameCY = beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  0  -i \n    0  0  i  0\nendpmatrix\n\nBy convention we refer to the first qubit as the control qubit and the second qubit as the target.\n\nExamples\n\njulia> matrix(GateCY())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  -0.0-1.0im\n 0.0+0.0im  0.0+0.0im  0.0+1.0im  -0.0+0.0im\n\njulia> push!(Circuit(), GateCY(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CY @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCZ","page":"Public","title":"MimiqCircuitsBase.GateCZ","text":"struct GateCZ <: Gate{2}\n\nTwo qubit Controlled-Z gate.\n\nMatrix Representation\n\noperatornameCZ = beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  1  0 \n    0  0  0  -1\nendpmatrix\n\nBy convention we refer to the first qubit as the control qubit and the second qubit as the target.\n\nExamples\n\njulia> matrix(GateCZ())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0   0.0\n 0.0  1.0  0.0   0.0\n 0.0  0.0  1.0   0.0\n 0.0  0.0  0.0  -1.0\n\njulia> push!(Circuit(), GateCZ(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CZ @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateDCX","page":"Public","title":"MimiqCircuitsBase.GateDCX","text":"struct GateDCX <: Gate{2}\n\nTwo qubit double-CNOT (Control on first qubit and then second) OR DCX gate.\n\nMatrix Representation\n\nbeginpmatrix\n    1  0  0  0 \n    0  0  0  1 \n    0  1  0  0 \n    0  0  1  0\nendpmatrix\n\nExamples\n\njulia> matrix(GateDCX())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  1.0  0.0\n\njulia> push!(Circuit(), GateDCX(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── DCX @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateDCXDG","page":"Public","title":"MimiqCircuitsBase.GateDCXDG","text":"struct GateDCXDG <: Gate{2}\n\nTwo qubit DCX-dagger gate.\n\nMatrix Representation\n\nbeginpmatrix\n    1  0  0  0 \n    0  0  1  0 \n    0  0  0  1 \n    0  1  0  0\nendpmatrix\n\nExamples\n\njulia> matrix(GateDCXDG())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  1.0\n 0.0  1.0  0.0  0.0\n\njulia> push!(Circuit(), GateDCXDG(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── DCXDG @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateECR","page":"Public","title":"MimiqCircuitsBase.GateECR","text":"struct GateECR <: Gate{2}\n\nTwo qubit ECR echo gate.\n\nMatrix Representation\n\nbeginpmatrix\n    0  frac1sqrt2   0  fracisqrt2  \n    frac1sqrt2  0  frac-isqrt2  0 \n    0  fracisqrt2  0  fracisqrt2  \n    frac-isqrt2  0  frac1sqrt2   0 \nendpmatrix\n\nExamples\n\njulia> matrix(GateCSX())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.5+0.5im  0.0+0.0im  0.5-0.5im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.5-0.5im  0.0+0.0im  0.5+0.5im\n\njulia> push!(Circuit(), GateCSX(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CSX @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateISWAP","page":"Public","title":"MimiqCircuitsBase.GateISWAP","text":"struct GateISWAP <: Gate{2}\n\nTwo qubit ISWAP gate.\n\nSee also GateISWAPDG, GateSWAP.\n\nMatrix Representation\n\noperatornameISWAP = frac1sqrt2\nbeginpmatrix\n    1  0  0  0 \n    0  0  i  0 \n    0  i  0  0 \n    0  0  0  1\nendpmatrix\n\nExamples\n\njulia> matrix(GateISWAP())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+1.0im  0.0+0.0im\n 0.0+0.0im  0.0+1.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  1.0+0.0im\n\njulia> push!(Circuit(), GateISWAP(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── ISWAP @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateISWAPDG","page":"Public","title":"MimiqCircuitsBase.GateISWAPDG","text":"struct GateISWAPDG <: Gate{2}\n\nTwo qubit ISWAP-dagger gate (conjugate transpose of ISWAP)\n\nSee also GateISWAP, GateSWAP\n\nMatrix Representation\n\noperatornameISWAP^dagger = frac1sqrt2\nbeginpmatrix\n    1  0  0  0 \n    0  0  -i  0 \n    0  -i  0  0 \n    0  0  0  1\nendpmatrix\n\nExamples\n\njulia> matrix(GateISWAPDG())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0-1.0im  0.0+0.0im\n 0.0+0.0im  0.0-1.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  1.0+0.0im\n\njulia> push!(Circuit(), GateISWAPDG(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── ISWAPDG @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateSWAP","page":"Public","title":"MimiqCircuitsBase.GateSWAP","text":"struct GateSWAP <: Gate{2}\n\nTwo qubit SWAP gate.\n\nSee also GateISWAP\n\nMatrix Representation\n\noperatornameSWAP = frac1sqrt2\nbeginpmatrix\n    1  0  0  0 \n    0  0  1  0 \n    0  1  0  0 \n    0  0  0  1\nendpmatrix\n\nExamples\n\njulia> matrix(GateSWAP())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  1.0\n\njulia> push!(Circuit(), GateSWAP(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── SWAP @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCP","page":"Public","title":"MimiqCircuitsBase.GateCP","text":"struct GateCP <: ParametricGate{2}\n\nTwo qubit Controlled-Phase gate \n\nArguments\n\nλ::Float64: Phase angle in radians\n\nMatrix Representation\n\noperatornameCP(lambda) = beginpmatrix\n          1  0  0  0 \n          0  1  0  0 \n          0  0  1  0 \n          0  0  0  e^ilambda\n      endpmatrix\n\nBy convention we refer to the first qubit as the control qubit and the second qubit as the target.\n\nExamples\n\njulia> matrix(GateCP(pi/4))\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im       0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.707107+0.707107im\n\njulia> push!(Circuit(), GateCP(pi/4), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CP(λ=0.7853981633974483) @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCR","page":"Public","title":"MimiqCircuitsBase.GateCR","text":"struct GateCR <: ParametricGate{2}\n\nTwo qubit Controlled-R gate.\n\nArguments\n\nθ::Float64: Rotation angle in radians\nϕ::Float64: The phase angle in radians.\n\nMatrix Representation\n\noperatornameCR(theta phi) =\nbeginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  cosfractheta2  -ie^-iphisinfractheta2 \n    0  0  -ie^iphisinfractheta2  cosfractheta2\nendpmatrix\n\nExamples\n\njulia> matrix(GateCR(pi,-pi))\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im           0.0+0.0im          0.0+0.0im\n 0.0+0.0im  1.0+0.0im           0.0+0.0im          0.0+0.0im\n 0.0+0.0im  0.0+0.0im   6.12323e-17+0.0im  1.22465e-16+1.0im\n 0.0+0.0im  0.0+0.0im  -1.22465e-16+1.0im  6.12323e-17+0.0im\n\njulia> push!(Circuit(), GateCR(pi,-pi), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CR(θ=3.141592653589793, ϕ=-3.141592653589793) @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCRX","page":"Public","title":"MimiqCircuitsBase.GateCRX","text":"struct GateCRX <: ParametricGate{2}\n\nTwo qubit Controlled-RX gate \n\nArguments\n\nθ::Float64: Rotation angle in radians\n\nMatrix Representation\n\noperatornameCRX(theta) =\nbeginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  cosfractheta2  -isinfractheta2 \n    0  0  -isinfractheta2  cosfractheta2\nendpmatrix\n\nBy convention we refer to the first qubit as the control qubit and the second qubit as the target.\n\nExamples\n\njulia> matrix(GateCRX(pi/2))\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im       0.0+0.0im            0.0+0.0im\n 0.0+0.0im  1.0+0.0im       0.0+0.0im            0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.707107+0.0im           -0.0-0.707107im\n 0.0+0.0im  0.0+0.0im       0.0-0.707107im  0.707107+0.0im\n\njulia> push!(Circuit(), GateCRX(pi/2), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CRX(θ=1.5707963267948966) @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCRY","page":"Public","title":"MimiqCircuitsBase.GateCRY","text":"struct GateCRY <: ParametricGate{2}\n\nTwo qubit Controlled-RY gate \n\nArguments\n\nθ::Float64: Rotation angle in radians\n\nMatrix Representation\n\noperatornameCRY(theta) =\nbeginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  cosfractheta2  -sinfractheta2 \n    0  0  sinfractheta2  cosfractheta2\nendpmatrix\n\nBy convention we refer to the first qubit as the control qubit and the second qubit as the target.\n\nExamples\n\njulia> matrix(GateCRY(pi/2))\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0        0.0\n 0.0  1.0  0.0        0.0\n 0.0  0.0  0.707107  -0.707107\n 0.0  0.0  0.707107   0.707107\n\njulia> push!(Circuit(), GateCRY(pi/2), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CRY(θ=1.5707963267948966) @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCRZ","page":"Public","title":"MimiqCircuitsBase.GateCRZ","text":"struct GateCRZ <: ParametricGate{2}\n\nTwo qubit Controlled-RZ gate \n\nArguments\n\nλ::Float64: Rotation angle in radians\n\nMatrix Representation\n\noperatornameCRZ(lambda) =\nbeginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  e^-ifraclambda2  0 \n    0  0  0  e^ifraclambda2\nendpmatrix\n\nBy convention we refer to the first qubit as the control qubit and the second qubit as the target.\n\nExamples\n\njulia> matrix(GateCRZ(pi/2))\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im       0.0+0.0im            0.0+0.0im\n 0.0+0.0im  1.0+0.0im       0.0+0.0im            0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.707107-0.707107im      -0.0+0.0im\n 0.0+0.0im  0.0+0.0im       0.0+0.0im       0.707107+0.707107im\n\njulia> push!(Circuit(), GateCRZ(pi/2), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CRZ(λ=1.5707963267948966) @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCU","page":"Public","title":"MimiqCircuitsBase.GateCU","text":"struct GateCU <: ParametricGate{2}\n\nTwo qubit generic unitary gate, equivalent to the qiskit CUGate https://qiskit.org/documentation/stubs/qiskit.circuit.library.CUGate.html\n\nArguments\n\nθ::Float64: Euler angle 1 in radians\nϕ::Float64: Euler angle 2 in radians\nλ::Float64: Euler angle 3 in radians\nγ::Float64: Global phase of the U gate\n\nMatrix Representation\n\noperatornameCU(thetaphilambdagamma) =\nbeginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  e^igammacosfractheta2  -e^i(gamma+lambda)sinfractheta2 \n    0  0  e^i(gamma+phi)sinfractheta2  e^i(gamma+phi+lambda)cosfractheta2\nendpmatrix\n\nBy convention we refer to the first qubit as the control qubit and the second qubit as the target.\n\nExamples\n\njulia> matrix(GateCU(pi/3, pi/3, pi/3, 0))\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im       0.0+0.0im             0.0+0.0im\n 0.0+0.0im  1.0+0.0im       0.0+0.0im             0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.866025+0.0im           -0.25-0.433013im\n 0.0+0.0im  0.0+0.0im      0.25+0.433013im  -0.433013+0.75im\n\njulia> push!(Circuit(), GateCU(pi/3, pi/3, pi/3, 0), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CU(θ=1.0471975511965976, ϕ=1.0471975511965976, λ=1.0471975511965976, γ=0.0) @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateRXX","page":"Public","title":"MimiqCircuitsBase.GateRXX","text":"struct GateRXX <: ParametricGate{2}\n\nTwo qubit RXX gate.\n\nArguments\n\nθ::Float64: The angle in radians\n\nMatrix Representation\n\noperatornameRXX(theta) =\nbeginpmatrix\n    cos(fractheta2)  0  0  -isin(fractheta2) \n    0  cos(fractheta2)  -isin(fractheta2)  0 \n    0  -isin(fractheta2)  cos(fractheta2)  0 \n    -isin(fractheta2)  0  0  cos(fractheta2)\nendpmatrix\n\nExamples\n\njulia> matrix(GateRXX(π/4))\n4×4 Matrix{ComplexF64}:\n 0.92388+0.0im           0.0+0.0im       …      0.0-0.382683im\n     0.0+0.0im       0.92388+0.0im              0.0+0.0im\n     0.0+0.0im           0.0-0.382683im         0.0+0.0im\n     0.0-0.382683im      0.0+0.0im          0.92388+0.0im\n\njulia> push!(Circuit(), GateRXX(π), 1, 2)\n2-qubit circuit with 1 instructions:\n└── RXX(θ=3.141592653589793) @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateRYY","page":"Public","title":"MimiqCircuitsBase.GateRYY","text":"struct GateRYY <: ParametricGate{2}\n\nTwo qubit RYY gate.\n\nArguments\n\nθ::Float64: The angle in radians\n\nMatrix Representation\n\noperatornameRYY(theta) =\nbeginpmatrix\n    cos(fractheta2)  0  0  isin(fractheta2) \n    0  cos(fractheta2)  -isin(fractheta2)  0 \n    0  -isin(fractheta2)  cos(fractheta2)  0 \n    isin(fractheta2)  0  0  cos(fractheta2)\nendpmatrix\n\nExamples\n\njulia> matrix(GateRYY(π/4))\n4×4 Matrix{ComplexF64}:\n 0.92388+0.0im           0.0+0.0im       …      0.0+0.382683im\n     0.0+0.0im       0.92388+0.0im              0.0+0.0im\n     0.0+0.0im           0.0-0.382683im         0.0+0.0im\n     0.0+0.382683im      0.0+0.0im          0.92388+0.0im\n\njulia> push!(Circuit(), GateRYY(π), 1, 2)\n2-qubit circuit with 1 instructions:\n└── RYY(θ=3.141592653589793) @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateRZZ","page":"Public","title":"MimiqCircuitsBase.GateRZZ","text":"struct GateRZZ <: ParametricGate{2}\n\nTwo qubit RZZ gate.\n\nArguments\n\nθ::Float64: The angle in radians\n\nMatrix Representation\n\noperatornameRZZ(theta) =\nbeginpmatrix\n    e^-ifractheta2  0  0  0 \n    0  e^ifractheta2  0  0 \n    0  0  e^ifractheta2  0 \n    0  0  0  e^-ifractheta2\nendpmatrix\n\nExamples\n\njulia> matrix(GateRZZ(π/4))\n4×4 Matrix{ComplexF64}:\n 0.92388-0.382683im      0.0+0.0im       …      0.0+0.0im\n     0.0+0.0im       0.92388+0.382683im         0.0+0.0im\n     0.0+0.0im           0.0+0.0im              0.0+0.0im\n     0.0+0.0im           0.0+0.0im          0.92388-0.382683im\n\njulia> push!(Circuit(), GateRZZ(π), 1, 2)\n2-qubit circuit with 1 instructions:\n└── RZZ(θ=3.141592653589793) @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateXXminusYY","page":"Public","title":"MimiqCircuitsBase.GateXXminusYY","text":"struct GateXXminusYY <: ParametricGate{2}\n\nTwo qubit XXminusYY gate.\n\nArguments\n\nθ::Float64: The angle in radians.\nβ::Float64: The phase angle in radians.\n\nMatrix Representation\n\noperatornameXXminusYY(theta beta) =\n    beginpmatrix\n        cos(fractheta2)  0  0  -isin(fractheta2)e^-ibeta \n        0  1  0  0 \n        0  0  1  0 \n        -isin(fractheta2)e^ibeta  0  0  cos(fractheta2)\n    endpmatrix\n\nExamples\n\njulia> matrix(GateXXminusYY(π/2,π/2))\n4×4 Matrix{ComplexF64}:\n 0.707107+0.0im          0.0+0.0im  0.0+0.0im  -0.707107-4.32978e-17im\n      0.0+0.0im          1.0+0.0im  0.0+0.0im        0.0+0.0im\n      0.0+0.0im          0.0+0.0im  1.0+0.0im        0.0+0.0im\n 0.707107-4.32978e-17im  0.0+0.0im  0.0+0.0im   0.707107+0.0im\n\njulia> push!(Circuit(), GateXXminusYY(π,π), 1, 2)\n2-qubit circuit with 1 instructions:\n└── XXminusYY(θ=3.141592653589793, β=3.141592653589793) @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateXXplusYY","page":"Public","title":"MimiqCircuitsBase.GateXXplusYY","text":"struct GateXXplusYY <: ParametricGate{2}\n\nTwo qubit XXplusYY gate.\n\nArguments\n\nθ::Float64: The angle in radians.\nβ::Float64: The phase angle in radians.\n\nMatrix Representation\n\noperatornameXXplusYY(theta beta) =\n    beginpmatrix\n        1  0  0  0 \n        0  cos(fractheta2)  -isin(fractheta2)e^-ibeta  0 \n        0  -isin(fractheta2)e^ibeta  cos(fractheta2)  0 \n        0  0  0  1\n    endpmatrix\n\nExamples\n\njulia> matrix(GateXXplusYY(π/2,π/2))\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im       0.0+0.0im                0.0+0.0im          0.0+0.0im\n 0.0+0.0im  0.707107+0.0im          -0.707107-4.32978e-17im  0.0+0.0im\n 0.0+0.0im  0.707107-4.32978e-17im   0.707107+0.0im          0.0+0.0im\n 0.0+0.0im       0.0+0.0im                0.0+0.0im          1.0+0.0im\n\njulia> push!(Circuit(), GateXXplusYY(π,π), 1, 2)\n2-qubit circuit with 1 instructions:\n└── XXplusYY(θ=3.141592653589793, β=3.141592653589793) @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Multi-qubit","page":"Public","title":"Multi-qubit","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"multiqubit.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.GateCCX","page":"Public","title":"MimiqCircuitsBase.GateCCX","text":"struct GateCCX <: Gate{3}\n\nC₂X (or C₂NOT) 3-qubits gate. Where the first two qubits are used as controls.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCSWAP","page":"Public","title":"MimiqCircuitsBase.GateCSWAP","text":"struct GateCSWAP <: Gate{3} end\n\n3-qubits control SWAP gate where the first qubit is the control.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Custom-gates","page":"Public","title":"Custom gates","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"custom.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.GateCustom","page":"Public","title":"MimiqCircuitsBase.GateCustom","text":"struct GateCustom{N,T} <: Gate{N}\n\nN qubit gate specified by a 2^N times 2^N matrix with elements of type T.\n\nUse this to construct your own gates based on unitary matrices. Currently only N=1,2 (M=2,4) are recognised.\n\nMIMIQ uses textbook convention for specifying gates.\n\nOne qubit gate matrices are defined in the basis 0rangle, 1rangle e.g.,\n\noperatornameZ =\nbeginpmatrix\n    10\n    0-1\nendpmatrix\n\nTwo qubit gate matrices are defined in the basis 00rangle, 01rangle>, 10rangle, 11rangle where the left-most qubit is the first to appear in the target list e.g.,\n\noperatornameCNOT =\nbeginpmatrix\n    1000\n    0100\n    0001\n    0010\nendpmatrix\n\njulia> CNOT = [1 0 0 0; 0 1 0 0; 0 0 0 1; 0 0 1 0]\n4×4 Matrix{Int64}:\n 1  0  0  0\n 0  1  0  0\n 0  0  0  1\n 0  0  1  0\n\njulia> # CNOT gate with control on q1 and target on q2\n\njulia> Instruction(GateCustom(CNOT), 1, 2)\nGateCustom([1 0 0 0; 0 1 0 0; 0 0 0 1; 0 0 1 0]) @ q1, q2\n\n# Examples\n\n\njldoctest julia> g = GateCustom([1 0; 0 1]) Custom([1.0 0.0; 0.0 1.0])\n\njulia> push!(Circuit(), g, 1) 1-qubit circuit with 1 instructions: └── Custom([1.0 0.0; 0.0 1.0]) @ q1 ```\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Non-unitary-operations","page":"Public","title":"Non-unitary operations","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"reset.jl\", \"measure.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.Reset","page":"Public","title":"MimiqCircuitsBase.Reset","text":"struct Reset <: Operation{1}\n\nQuantum operation that resets the status of one qubit to the ket0 state.\n\nExamples\n\njulia> push!(Circuit(), Reset(), 1)\n1-qubit circuit with 1 instructions:\n└── Reset @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.Measure","page":"Public","title":"MimiqCircuitsBase.Measure","text":"struct Measure <: Operation{1}\n\nSingle qubit measurement operation in the computational basis\n\nThis operation is non-reversible\n\nExamples\n\nMeasure project the qubit state and optionally store the result of the measurement for that qubit in a classical register.\n\nTo just apply the measurement on qubit 1 and discard the result, do:\n\njulia> push!(Circuit(), Measure(), 1,1)\n1-qubit circuit with 1 instructions:\n└── Measure @ q1, c1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#No-ops","page":"Public","title":"No-ops","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"barrier.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.Barrier","page":"Public","title":"MimiqCircuitsBase.Barrier","text":"struct Barrier <: Operation{1}\n\nA barrier is a special operation that does not affect the quantum state or the execution of a circuit, but it prevents compression or optimization operation from being applied across it.\n\nExamples\n\njulia> push!(Circuit(), Barrier(), 1)\n1-qubit circuit with 1 instructions:\n└── Barrier @ q1\n\njulia> push!(Circuit(), Barrier(4), 1:4...)\n4-qubit circuit with 1 instructions:\n└── Barrier @ q1, q2, q3, q4\n\njulia> push!(Circuit(), Barrier(), 1:4)\n4-qubit circuit with 4 instructions:\n├── Barrier @ q1\n├── Barrier @ q2\n├── Barrier @ q3\n└── Barrier @ q4\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Composite-operations","page":"Public","title":"Composite operations","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"ifstatement.jl\", \"control.jl\", \"parallel.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.IfStatement","page":"Public","title":"MimiqCircuitsBase.IfStatement","text":"struct IfStatement{N,M} <: Operation{N,M}\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.Control","page":"Public","title":"MimiqCircuitsBase.Control","text":"struct Control{N,M,L,T<:Operation{M,0}} <: Operation{L,0} end\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.Parallel","page":"Public","title":"MimiqCircuitsBase.Parallel","text":"struct Parallel{N,M,L,T<:Operation{M,0}} <: Operation{L,0} end\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Bit-States","page":"Public","title":"Bit States","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"bitstates.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.BitState","page":"Public","title":"MimiqCircuitsBase.BitState","text":"struct BitState\n\nRepresentation of the quantum state of a quantum register with definite values for each qubit.\n\nExamples\n\njulia> BitState(16)\n16-qubit BitState with 0 non-zero qubits:\n└── |0000000000000000⟩\n\njulia> bs = BitState(16, [1,2,3,4])\n16-qubit BitState with 4 non-zero qubits:\n├── |1111000000000000⟩\n└── non-zero qubits: [1, 2, 3, 4]\n\njulia> bs[10] = 1\n1\n\njulia> bs\n16-qubit BitState with 5 non-zero qubits:\n├── |1111000001000000⟩\n└── non-zero qubits: [1, 2, 3, 4, 10]\n\njulia> c = Circuit()\nempty circuit\n\njulia> push!(c, GateX(), 8)\n8-qubit circuit with 1 instructions:\n└── X @ q8\n\njulia> BitState(c, [1,3,5,8])\n8-qubit BitState with 4 non-zero qubits:\n├── |10101001⟩\n└── non-zero qubits: [1, 3, 5, 8]\n\njulia> bitstate_to_integer(bs)\n527\n\njulia> typeof(ans)\nBigInt\n\njulia> bitstate_to_integer(bs, Int64)\n527\n\njulia> typeof(ans)\nInt64\n\nThere are many different ways to get bit states:\n\njulia> bs = BitState(30, 2344574)\n30-qubit BitState with 13 non-zero qubits:\n├── |011111100110001111000100000000⟩\n└── non-zero qubits: [2, 3, 4, 5, 6, 7, 10, 11, 15, 16, 17, 18, 22]\n\njulia> ones(BitState, 10) # or also trues(BitState, 10)\n10-qubit BitState with 10 non-zero qubits:\n├── |1111111111⟩\n└── non-zero qubits: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\njulia> zeros(BitState, 10) # or also falses(BitState, 10)\n10-qubit BitState with 0 non-zero qubits:\n└── |0000000000⟩\n\njulia> BitState(16) do i\n           iseven(i)\n       end\n16-qubit BitState with 8 non-zero qubits:\n├── |0101010101010101⟩\n└── non-zero qubits: [2, 4, 6, 8, 10, 12, 14, 16]\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.bits-Tuple{BitState}","page":"Public","title":"MimiqCircuitsBase.bits","text":"bits(bitstate)\n\nGet the underlying bit array of a bit state.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#MimiqCircuitsBase.bitstate_to_index-Tuple{BitState}","page":"Public","title":"MimiqCircuitsBase.bitstate_to_index","text":"bitstate_to_index(bitstate)\n\nConvert a bit state into the corresponding index.\n\nThis is useful for indexing, for example, a vector of states.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#MimiqCircuitsBase.bitstate_to_integer-Union{Tuple{BitState}, Tuple{T}, Tuple{BitState, Type{T}}} where T","page":"Public","title":"MimiqCircuitsBase.bitstate_to_integer","text":"bitstate_to_integer(bitstate[, T])\n\nConvert a bit state into its corresponding integer.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#MimiqCircuitsBase.nonzeros-Tuple{BitState}","page":"Public","title":"MimiqCircuitsBase.nonzeros","text":"nonzeros(bitstate)\n\nReturn the indices of the non-zero qubits in a bit state.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#MimiqCircuitsBase.to01-Tuple{BitState}","page":"Public","title":"MimiqCircuitsBase.to01","text":"to01(bitstate[, endianess=:big])\n\nConverts a BitState into a string of 0 and 1 characters. Optionally endianess can be specified, which can be either :big or :little.\n\nExamples\n\njulia> to01(bs\"10011\")\n\"10011\"\n\njulia> to01(bs\"10011\"; endianess=:big)\n\"10011\"\n\njulia> to01(bs\"10011\"; endianess=:little)\n\"11001\"\n\n\n\n\n\n","category":"method"},{"location":"library/public/#MimiqCircuitsBase.@bs_str-Tuple{Any}","page":"Public","title":"MimiqCircuitsBase.@bs_str","text":"macro bs_str(s)\n\nConvert a string into a bit state.\n\nExamples\n\njulia> bs\"101011\"\n6-qubit BitState with 4 non-zero qubits:\n├── |101011⟩\n└── non-zero qubits: [1, 3, 5, 6]\n\n\n\n\n\n","category":"macro"}]
}
