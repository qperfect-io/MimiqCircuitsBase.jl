<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public · MimiqCircuitsBase.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MimiqCircuitsBase.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation/">Installation Instructions</a></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../outline/">Contents</a></li><li class="is-active"><a class="tocitem" href>Public</a><ul class="internal"><li><a class="tocitem" href="#MimiqCircuitsBase"><span>MimiqCircuitsBase</span></a></li><li><a class="tocitem" href="#Quantum-Circuits-and-Instructions"><span>Quantum Circuits and Instructions</span></a></li><li><a class="tocitem" href="#Operations"><span>Operations</span></a></li><li><a class="tocitem" href="#Bit-States"><span>Bit States</span></a></li></ul></li><li><a class="tocitem" href="../internals/">Private</a></li><li><a class="tocitem" href="../function_index/">Function index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Public</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/main/docs/src/library/public.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-Documentation"><a class="docs-heading-anchor" href="#Public-Documentation">Public Documentation</a><a id="Public-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Public-Documentation" title="Permalink"></a></h1><p>Documentation for <code>MimiqCircuitsBase.jl</code>&#39;s public interface.</p><p>See the Internals section of the manual for internal package docs.</p><h2 id="MimiqCircuitsBase"><a class="docs-heading-anchor" href="#MimiqCircuitsBase">MimiqCircuitsBase</a><a id="MimiqCircuitsBase-1"></a><a class="docs-heading-anchor-permalink" href="#MimiqCircuitsBase" title="Permalink"></a></h2><h2 id="Quantum-Circuits-and-Instructions"><a class="docs-heading-anchor" href="#Quantum-Circuits-and-Instructions">Quantum Circuits and Instructions</a><a id="Quantum-Circuits-and-Instructions-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Circuits-and-Instructions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.Instruction" href="#MimiqCircuitsBase.Instruction"><code>MimiqCircuitsBase.Instruction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Instruction{N,M,T&lt;:Operation}</code></pre><p>Element of a quantum circuit, representing a <code>N</code>-qubit gate applied to <code>N</code> targets</p><p><strong>Parameters</strong></p><ul><li><code>gate::T</code> actual gate represented</li><li><code>qtargets::NTuple{N, Int64}</code> indices specifying the quantum bits on which the instruction is applied</li><li><code>ctargets::NTuple{N, Int64}</code> indices specifying the classical bits on which the instruction is applied</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/instruction.jl#L71-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.getbit" href="#MimiqCircuitsBase.getbit"><code>MimiqCircuitsBase.getbit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getbit(instruction, i)</code></pre><p>Returns the i-th target classical bit of an instruction.</p><p>See also <a href="#MimiqCircuitsBase.getbits"><code>getbits</code></a>, <a href="#MimiqCircuitsBase.getqubit"><code>getqubit</code></a>, <a href="#MimiqCircuitsBase.getqubits"><code>getqubits</code></a>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/instruction.jl#L35-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.getbits" href="#MimiqCircuitsBase.getbits"><code>MimiqCircuitsBase.getbits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getbits(instruction)</code></pre><p>Returns all the classical bits to which the instruction is applied.</p><p>See also <a href="#MimiqCircuitsBase.getbit"><code>getbit</code></a>, <a href="#MimiqCircuitsBase.getqubits"><code>getqubits</code></a>, <a href="#MimiqCircuitsBase.getqubit"><code>getqubit</code></a>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/instruction.jl#L44-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.getoperation-Tuple{Instruction}" href="#MimiqCircuitsBase.getoperation-Tuple{Instruction}"><code>MimiqCircuitsBase.getoperation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getoperation(instruction)</code></pre><p>Returns the quantum operation associated to the given instruction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/instruction.jl#L122-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.getqubit" href="#MimiqCircuitsBase.getqubit"><code>MimiqCircuitsBase.getqubit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getqubit(instruction, i)</code></pre><p>Returns the i-th target qubit of an instruction.</p><p>See also <a href="#MimiqCircuitsBase.getqubits"><code>getqubits</code></a>, <a href="#MimiqCircuitsBase.getbit"><code>getbit</code></a>, <a href="#MimiqCircuitsBase.getbits"><code>getbits</code></a>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/instruction.jl#L17-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.getqubits" href="#MimiqCircuitsBase.getqubits"><code>MimiqCircuitsBase.getqubits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getqubits(instruction)</code></pre><p>Returns all the quantum bits to which the instruction is applied.</p><p>See also <a href="#MimiqCircuitsBase.getqubit"><code>getqubit</code></a>, <a href="#MimiqCircuitsBase.getbits"><code>getbits</code></a>, <a href="#MimiqCircuitsBase.getbit"><code>getbit</code></a>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/instruction.jl#L26-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.Circuit" href="#MimiqCircuitsBase.Circuit"><code>MimiqCircuitsBase.Circuit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Circuit</code></pre><p>Representation of a quantum circuit as a vector of gates applied to the qubits.</p><p><strong>Parameters</strong></p><ul><li><code>gates::Vector{Instruction}</code> vector of quantum instructions (see</li></ul><p><a href="#MimiqCircuitsBase.Instruction"><code>Instruction</code></a>)</p><p><strong>Examples</strong></p><p><strong>Adding operations to a circuit</strong></p><p>Operation can be added one by one to a circuit with the <code>push!(circuit, operation, targets...)</code> function</p><pre><code class="language- hljs">c = Circuit()
push!(c, GateH(), 1)
push!(c, GateCX(), 1, 2)
push!(c, GateRX(π / 4), 1)
push!(c, Barrier, 1, 3)
push!(c, Measure(), 1, 1)</code></pre><p>Targets are not restricted to be single values, but also vectors. In this case a single <code>push!</code> will add multiple operations. The behaviour is similar to <code>Iterators.product</code>. For example:</p><pre><code class="language-julia hljs">push!(c, GateCX(), 1, 2:4)</code></pre><p>is equivalent to</p><pre><code class="nohighlight hljs">for targets in Iterators.product(1, 2:4)
    push!(c, GateCX(), targets...)
end</code></pre><p>For example</p><pre><code class="language- hljs">c = Circuit()
push!(c, GateH(),1:3)
push!(c,GateCX(),1:3,4:6)</code></pre><p>Some operations behave a bit differently. See also: <a href="#MimiqCircuitsBase.Barrier"><code>Barrier</code></a> and <a href="#MimiqCircuitsBase.Measure"><code>Measure</code></a></p><p><strong>Available operations</strong></p><p><strong>Gates</strong></p><p><strong>Single qubit gates</strong></p><p><a href="#MimiqCircuitsBase.GateX"><code>GateX</code></a> <a href="#MimiqCircuitsBase.GateY"><code>GateY</code></a> <a href="#MimiqCircuitsBase.GateZ"><code>GateZ</code></a> <a href="#MimiqCircuitsBase.GateH"><code>GateH</code></a> <a href="#MimiqCircuitsBase.GateS"><code>GateS</code></a> <a href="#MimiqCircuitsBase.GateSDG"><code>GateSDG</code></a> <a href="#MimiqCircuitsBase.GateT"><code>GateT</code></a> <a href="#MimiqCircuitsBase.GateTDG"><code>GateTDG</code></a> <a href="#MimiqCircuitsBase.GateSX"><code>GateSX</code></a> <a href="#MimiqCircuitsBase.GateSXDG"><code>GateSXDG</code></a> <a href="#MimiqCircuitsBase.GateID"><code>GateID</code></a></p><p><strong>Single qubit gates (parametric)</strong></p><p><a href="#MimiqCircuitsBase.GateRX"><code>GateRX</code></a> <a href="#MimiqCircuitsBase.GateRY"><code>GateRY</code></a> <a href="#MimiqCircuitsBase.GateRZ"><code>GateRZ</code></a> <a href="#MimiqCircuitsBase.GateP"><code>GateP</code></a> <a href="#MimiqCircuitsBase.GateR"><code>GateR</code></a> <a href="#MimiqCircuitsBase.GateU"><code>GateU</code></a></p><p><strong>Two qubit gates</strong></p><p><a href="#MimiqCircuitsBase.GateCX"><code>GateCX</code></a> <a href="#MimiqCircuitsBase.GateCY"><code>GateCY</code></a> <a href="#MimiqCircuitsBase.GateCZ"><code>GateCZ</code></a> <a href="#MimiqCircuitsBase.GateCH"><code>GateCH</code></a> <a href="#MimiqCircuitsBase.GateSWAP"><code>GateSWAP</code></a> <a href="#MimiqCircuitsBase.GateISWAP"><code>GateISWAP</code></a>, <a href="#MimiqCircuitsBase.GateISWAPDG"><code>GateISWAPDG</code></a></p><p><strong>Two qubit gates (parametric)</strong></p><p><a href="#MimiqCircuitsBase.GateCP"><code>GateCP</code></a> <a href="#MimiqCircuitsBase.GateCRX"><code>GateCRX</code></a> <a href="#MimiqCircuitsBase.GateCRY"><code>GateCRY</code></a> <a href="#MimiqCircuitsBase.GateCRZ"><code>GateCRZ</code></a> <a href="#MimiqCircuitsBase.GateCU"><code>GateCU</code></a></p><p><strong>Other</strong></p><p><a href="#MimiqCircuitsBase.GateCustom"><code>GateCustom</code></a></p><p><strong>No-ops</strong></p><p><a href="#MimiqCircuitsBase.Barrier"><code>Barrier</code></a></p><p><strong>Non-unitary operations</strong></p><p><a href="#MimiqCircuitsBase.Reset"><code>Reset</code></a> <a href="#MimiqCircuitsBase.Measure"><code>Measure</code></a></p><p><strong>Composite operations</strong></p><p><a href="#MimiqCircuitsBase.Control"><code>Control</code></a> <a href="#MimiqCircuitsBase.Parallel"><code>Parallel</code></a> <a href="#MimiqCircuitsBase.IfStatement"><code>IfStatement</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/circuit.jl#L17-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.depth-Tuple{Circuit}" href="#MimiqCircuitsBase.depth-Tuple{Circuit}"><code>MimiqCircuitsBase.depth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">depth(circuit)</code></pre><p>Compute the depth of a quantum circuit.</p><p>The depth of a quantum circuit is a metric computing the maximum time (in units of quantum gates application) between the input and output of the circuit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/circuit_extras.jl#L17-L24">source</a></section></article><h2 id="Operations"><a class="docs-heading-anchor" href="#Operations">Operations</a><a id="Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Operations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.Operation" href="#MimiqCircuitsBase.Operation"><code>MimiqCircuitsBase.Operation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Operation{N,M}</code></pre><p><strong>Parameters</strong></p><ul><li><code>N</code>: number of qubits the operation applies on.</li><li><code>M</code>: number of bits the operation applies on.</li></ul><p><strong>Methods</strong></p><ul><li><a href="#MimiqCircuitsBase.opname"><code>opname</code></a></li><li><a href="#MimiqCircuitsBase.inverse"><code>inverse</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operation.jl#L60-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.hilbertspacedim" href="#MimiqCircuitsBase.hilbertspacedim"><code>MimiqCircuitsBase.hilbertspacedim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hilbertspacedim(gate)
hilberspacedim(circuit)</code></pre><p>Hilbert space dimension for the given operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operation.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.inverse" href="#MimiqCircuitsBase.inverse"><code>MimiqCircuitsBase.inverse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inverse(circuit)
inverse(instruction)
inverse(operation)</code></pre><p>Return the inverse of the given operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operation.jl#L43-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.numbits" href="#MimiqCircuitsBase.numbits"><code>MimiqCircuitsBase.numbits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numbits(instruction)
numbits(circuit)</code></pre><p>Number of classical bits on which the given operation or instruction is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operation.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.numqubits" href="#MimiqCircuitsBase.numqubits"><code>MimiqCircuitsBase.numqubits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numqubits(gate)
numqubits(barrier)
numqubits(instruction)
numqubits(circuit)</code></pre><p>Number of qubits on which the given operation or instruction is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operation.jl#L17-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.opname" href="#MimiqCircuitsBase.opname"><code>MimiqCircuitsBase.opname</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">opname(instruction)
opname(operation)</code></pre><p>Returns the name of the given operation in a human readable format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operation.jl#L52-L57">source</a></section></article><h3 id="Gates"><a class="docs-heading-anchor" href="#Gates">Gates</a><a id="Gates-1"></a><a class="docs-heading-anchor-permalink" href="#Gates" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.Gate" href="#MimiqCircuitsBase.Gate"><code>MimiqCircuitsBase.Gate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Gate{N} &lt;: Operation{N}</code></pre><p>Supertype for all the <code>N</code>-qubit gates.</p><p><strong>Methods</strong></p><ul><li><a href="#MimiqCircuitsBase.inverse"><code>inverse</code></a></li><li><a href="#MimiqCircuitsBase.numqubits"><code>numqubits</code></a></li><li><a href="#MimiqCircuitsBase.opname"><code>opname</code></a></li><li><a href="#MimiqCircuitsBase.hilbertspacedim"><code>hilbertspacedim</code></a></li><li><a href="#MimiqCircuitsBase.matrix"><code>matrix</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gate.jl#L17-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.ParametricGate" href="#MimiqCircuitsBase.ParametricGate"><code>MimiqCircuitsBase.ParametricGate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ParametricGate{N}</code></pre><p>Supertype for all the parametric <code>N</code>-qubit gates.</p><p><strong>Methods</strong></p><ul><li><a href="#MimiqCircuitsBase.inverse"><code>inverse</code></a></li><li><a href="#MimiqCircuitsBase.numqubits"><code>numqubits</code></a></li><li><a href="#MimiqCircuitsBase.opname"><code>opname</code></a></li><li><a href="#MimiqCircuitsBase.hilbertspacedim"><code>hilbertspacedim</code></a></li><li><a href="#MimiqCircuitsBase.matrix"><code>matrix</code></a></li><li><a href="#MimiqCircuitsBase.numparams"><code>numparams</code></a></li><li><a href="#MimiqCircuitsBase.parnames"><code>parnames</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gate.jl#L41-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.matrix" href="#MimiqCircuitsBase.matrix"><code>MimiqCircuitsBase.matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">matrix(gate)</code></pre><p>Return the matrix associated to the specified quantum gate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gate.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.numparams" href="#MimiqCircuitsBase.numparams"><code>MimiqCircuitsBase.numparams</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numparams(gate)</code></pre><p>Number of parameters for the given parametric gate. Zero for non parametric gates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gate.jl#L58-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.parnames" href="#MimiqCircuitsBase.parnames"><code>MimiqCircuitsBase.parnames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parnames(gate)</code></pre><p>Name of the parameters allowed for the given gate</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gate.jl#L70-L74">source</a></section></article><h4 id="Single-qubit-gates"><a class="docs-heading-anchor" href="#Single-qubit-gates">Single qubit gates</a><a id="Single-qubit-gates-1"></a><a class="docs-heading-anchor-permalink" href="#Single-qubit-gates" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateH" href="#MimiqCircuitsBase.GateH"><code>MimiqCircuitsBase.GateH</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateH &lt;: Gate{1}</code></pre><p>Single qubit Hadamard gate.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname H = \frac{1}{\sqrt{2}}
\begin{pmatrix}
    1 &amp; 1 \\
    1 &amp; -1
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateH())
2×2 Matrix{Float64}:
 0.707107   0.707107
 0.707107  -0.707107

julia&gt; push!(Circuit(), GateH(), 1)
1-qubit circuit with 1 instructions:
└── H @ q1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/singlequbit.jl#L125-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateID" href="#MimiqCircuitsBase.GateID"><code>MimiqCircuitsBase.GateID</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateID &lt;: Gate{1}</code></pre><p>Single qubit Identity gate</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname{I} =
\begin{pmatrix}
    1 &amp; 0 \\
    0 &amp; 1
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateID())
2×2 Matrix{Float64}:
 1.0  -0.0
 0.0   1.0

julia&gt; push!(Circuit(), GateID(), 1)
1-qubit circuit with 1 instructions:
└── ID @ q1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/singlequbit.jl#L389-L416">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateS" href="#MimiqCircuitsBase.GateS"><code>MimiqCircuitsBase.GateS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateS &lt;: Gate{1}</code></pre><p>Single qubit S gate (or Phase gate).</p><p>See also <a href="#MimiqCircuitsBase.GateSDG"><code>GateSDG</code></a></p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname S =
\begin{pmatrix}
    1 &amp; 0 \\
    0 &amp; i
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateS())
2×2 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+1.0im

julia&gt; push!(Circuit(), GateS(), 1)
1-qubit circuit with 1 instructions:
└── S @ q1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/singlequbit.jl#L161-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateSDG" href="#MimiqCircuitsBase.GateSDG"><code>MimiqCircuitsBase.GateSDG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateSDG &lt;: Gate{1}</code></pre><p>Single qubit S-dagger gate (conjugate transpose of the S gate).</p><p>See also <a href="#MimiqCircuitsBase.GateS"><code>GateS</code></a></p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname S^\dagger =
\begin{pmatrix}
    1 &amp; 0 \\
    0 &amp; -i
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateSDG())
2×2 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0-1.0im

julia&gt; push!(Circuit(), GateSDG(), 1)
1-qubit circuit with 1 instructions:
└── SDG @ q1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/singlequbit.jl#L199-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateSX" href="#MimiqCircuitsBase.GateSX"><code>MimiqCircuitsBase.GateSX</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateSX &lt;: Gate{1}</code></pre><p>Single qubit √X gate.</p><p>See also <a href="#MimiqCircuitsBase.GateSXDG"><code>GateSXDG</code></a>, <a href="#MimiqCircuitsBase.GateX"><code>GateX</code></a></p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\sqrt{\operatorname{X}} = \frac{1}{2}
\begin{pmatrix}
    1+i &amp; 1-i \\
    1-i &amp; 1+i
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateSX())
2×2 Matrix{ComplexF64}:
 0.5+0.5im  0.5-0.5im
 0.5-0.5im  0.5+0.5im

julia&gt; push!(Circuit(), GateSX(), 1)
1-qubit circuit with 1 instructions:
└── SX @ q1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/singlequbit.jl#L313-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateSXDG" href="#MimiqCircuitsBase.GateSXDG"><code>MimiqCircuitsBase.GateSXDG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateSXDG &lt;: Gate{1}</code></pre><p>Single qubit √X-dagger gate (conjugate transpose of the √X gate)</p><p>See also <a href="#MimiqCircuitsBase.GateSX"><code>GateSX</code></a>, <a href="#MimiqCircuitsBase.GateX"><code>GateX</code></a></p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\sqrt{\operatorname{X}}^\dagger = \frac{1}{2}
\begin{pmatrix}
    1-i &amp; 1+i \\
    1+i &amp; 1-i
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateSXDG())
2×2 Matrix{ComplexF64}:
 0.5-0.5im  0.5+0.5im
 0.5+0.5im  0.5-0.5im

julia&gt; push!(Circuit(), GateSXDG(), 1)
1-qubit circuit with 1 instructions:
└── SXDG @ q1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/singlequbit.jl#L351-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateT" href="#MimiqCircuitsBase.GateT"><code>MimiqCircuitsBase.GateT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateT &lt;: Gate{1}</code></pre><p>Single qubit T gate.</p><p>See also <a href="#MimiqCircuitsBase.GateTDG"><code>GateTDG</code></a></p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname T =
\begin{pmatrix}
    1 &amp; 0 \\
    0 &amp; \exp(\frac{i\pi}{4})
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateT())
2×2 Matrix{ComplexF64}:
 1.0+0.0im       0.0+0.0im
 0.0+0.0im  0.707107+0.707107im

julia&gt; push!(Circuit(), GateT(), 1)
1-qubit circuit with 1 instructions:
└── T @ q1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/singlequbit.jl#L237-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateTDG" href="#MimiqCircuitsBase.GateTDG"><code>MimiqCircuitsBase.GateTDG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateTDG &lt;: Gate{1}</code></pre><p>Single qubit T-dagger gate (conjugate transpose of the T gate).</p><p>See also <a href="#MimiqCircuitsBase.GateT"><code>GateT</code></a></p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname T^\dagger =
\begin{pmatrix}
    1 &amp; 0 \\
    0 &amp; \exp(\frac{-i\pi}{4})
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateTDG())
2×2 Matrix{ComplexF64}:
 1.0+0.0im       0.0+0.0im
 0.0+0.0im  0.707107-0.707107im

julia&gt; push!(Circuit(), GateTDG(), 1)
1-qubit circuit with 1 instructions:
└── TDG @ q1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/singlequbit.jl#L275-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateX" href="#MimiqCircuitsBase.GateX"><code>MimiqCircuitsBase.GateX</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateX &lt;: Gate{1}</code></pre><p>Single qubit Pauli-X gate.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname X =
\begin{pmatrix}
    0 &amp; 1 \\
    1 &amp; 0
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateX())
2×2 Matrix{Float64}:
 0.0   1.0
 1.0  -0.0

julia&gt; push!(Circuit(), GateX(), 1)
1-qubit circuit with 1 instructions:
└── X @ q1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/singlequbit.jl#L17-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateY" href="#MimiqCircuitsBase.GateY"><code>MimiqCircuitsBase.GateY</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateY &lt;: Gate{1}</code></pre><p>Single qubit Pauli-Y gate.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname Y =
\begin{pmatrix}
    0 &amp; -i \\
    i &amp; 0
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateY())
2×2 Matrix{ComplexF64}:
 0.0+0.0im  -0.0-1.0im
 0.0+1.0im  -0.0+0.0im

julia&gt; push!(Circuit(), GateY(), 1)
1-qubit circuit with 1 instructions:
└── Y @ q1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/singlequbit.jl#L53-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateZ" href="#MimiqCircuitsBase.GateZ"><code>MimiqCircuitsBase.GateZ</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateZ &lt;: Gate{1}</code></pre><p>Single qubit Pauli-Z gate.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname Z =
\begin{pmatrix}
    1 &amp; 0 \\
    0 &amp; -1
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateZ())
2×2 Matrix{Float64}:
 1.0   0.0
 0.0  -1.0

julia&gt; push!(Circuit(), GateZ(), 1)
1-qubit circuit with 1 instructions:
└── Z @ q1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/singlequbit.jl#L89-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateP" href="#MimiqCircuitsBase.GateP"><code>MimiqCircuitsBase.GateP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateP &lt;: ParametricGate{1}</code></pre><p>Single qubit Phase gate.</p><p><strong>Arguments</strong></p><ul><li><code>λ::Float64</code>: Phase angle in radians</li></ul><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname P(\lambda) =
\begin{pmatrix}
    1 &amp; 0 \\
    0 &amp; e^{i\lambda}
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateP(pi/4))
2×2 Matrix{ComplexF64}:
 1.0+0.0im       0.0+0.0im
 0.0+0.0im  0.707107+0.707107im

julia&gt; push!(Circuit(), GateP(pi/4), 1)
1-qubit circuit with 1 instructions:
└── P(λ=0.7853981633974483) @ q1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/singlequbitpar.jl#L17-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateR" href="#MimiqCircuitsBase.GateR"><code>MimiqCircuitsBase.GateR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateR &lt;: ParametricGate{1}</code></pre><p>Single qubit Rotation gate around the axis cos(ϕ)x + sin(ϕ)y.</p><p><strong>Arguments</strong></p><ul><li><code>θ::Float64</code>: Rotation angle in radians</li><li><code>ϕ::Float64</code>: Axis of rotation in radians</li></ul><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname R(\theta,\phi) = \begin{pmatrix}
          \cos\frac{\theta}{2} &amp; -ie^{-i\phi}\sin\frac{\theta}{2} \\
          -ie^{-i\phi}\sin\frac{\theta}{2} &amp; \cos\frac{\theta}{2}
      \end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateR(pi/2,pi/4))
2×2 Matrix{ComplexF64}:
 0.707107+0.0im      -0.5-0.5im
      0.5-0.5im  0.707107+0.0im

julia&gt; push!(Circuit(), GateR(pi/2,pi/4), 1)
1-qubit circuit with 1 instructions:
└── R(θ=1.5707963267948966, ϕ=0.7853981633974483) @ q1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/singlequbitpar.jl#L252-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateRX" href="#MimiqCircuitsBase.GateRX"><code>MimiqCircuitsBase.GateRX</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateRX &lt;: ParametricGate{1}</code></pre><p>Single qubit Rotation-X gate (RX gate)</p><p><strong>Arguments</strong></p><ul><li><code>θ::Float64</code>: Rotation angle in radians</li></ul><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname{RX}(\theta) = \begin{pmatrix}
          \cos\frac{\theta}{2} &amp; -i\sin\frac{\theta}{2} \\
          -i\sin\frac{\theta}{2} &amp; \cos\frac{\theta}{2}
      \end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateRX(pi/2))
2×2 Matrix{ComplexF64}:
 0.707107+0.0im           -0.0-0.707107im
      0.0-0.707107im  0.707107+0.0im

julia&gt; push!(Circuit(), GateRX(pi/2), 1)
1-qubit circuit with 1 instructions:
└── RX(θ=1.5707963267948966) @ q1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/singlequbitpar.jl#L75-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateRY" href="#MimiqCircuitsBase.GateRY"><code>MimiqCircuitsBase.GateRY</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateRY &lt;: ParametricGate{1}</code></pre><p>Single qubit Rotation-Y gate (RY gate)</p><p><strong>Arguments</strong></p><ul><li><code>θ::Float64</code>: Rotation angle in radians</li></ul><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname{RY}(\theta) = \begin{pmatrix}
          \cos\frac{\theta}{2} &amp; -\sin\frac{\theta}{2} \\
          \sin\frac{\theta}{2} &amp; \cos\frac{\theta}{2}
      \end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateRY(pi/2))
2×2 Matrix{Float64}:
 0.707107  -0.707107
 0.707107   0.707107

julia&gt; push!(Circuit(), GateRY(pi/2), 1)
1-qubit circuit with 1 instructions:
└── RY(θ=1.5707963267948966) @ q1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/singlequbitpar.jl#L137-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateRZ" href="#MimiqCircuitsBase.GateRZ"><code>MimiqCircuitsBase.GateRZ</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateRZ &lt;: ParametricGate{1}</code></pre><p>Single qubit Rotation-Z gate (RZ gate)</p><p><strong>Arguments</strong></p><ul><li><code>λ::Float64</code>: Rotation angle in radians</li></ul><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname{RZ}(\lambda) =
\begin{pmatrix}
    e^{-i\frac{\lambda}{2}} &amp; 0 \\
    0 &amp; e^{i\frac{\lambda}{2}}
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateRZ(pi/2))
2×2 Matrix{ComplexF64}:
 0.707107-0.707107im      -0.0+0.0im
      0.0+0.0im       0.707107+0.707107im

julia&gt; push!(Circuit(), GateRZ(pi/2), 1)
1-qubit circuit with 1 instructions:
└── RZ(λ=1.5707963267948966) @ q1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/singlequbitpar.jl#L194-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateU" href="#MimiqCircuitsBase.GateU"><code>MimiqCircuitsBase.GateU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateU &lt;: ParametricGate{1}</code></pre><p>One qubit generic unitary gate, as defined in OpenQASM 3.0.</p><p><strong>Arguments</strong></p><ul><li><code>θ::Float64</code>: Euler angle 1 in radians</li><li><code>ϕ::Float64</code>: Euler angle 2 in radians</li><li><code>λ::Float64</code>: Euler angle 3 in radians</li></ul><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname{U}(\theta,\phi,\lambda) = \begin{pmatrix}
          \cos\frac{\theta}{2} &amp; -e^{i\lambda}\sin\frac{\theta}{2} \\
          e^{i\phi}\sin\frac{\theta}{2} &amp; e^{i(\phi+\lambda)}\cos\frac{\theta}{2}
      \end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateU(pi/3, pi/3, pi/3))
2×2 Matrix{ComplexF64}:
 0.866025+0.0im           -0.25-0.433013im
     0.25+0.433013im  -0.433013+0.75im

julia&gt; push!(Circuit(), GateU(pi/3, pi/3, pi/3), 1)
1-qubit circuit with 1 instructions:
└── U(θ=1.0471975511965976, ϕ=1.0471975511965976, λ=1.0471975511965976) @ q1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/singlequbitpar.jl#L508-L540">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateU1" href="#MimiqCircuitsBase.GateU1"><code>MimiqCircuitsBase.GateU1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateU1 &lt;: ParametricGate{1}</code></pre><p>One qubit generic unitary gate <code>u1</code>, as defined in OpenQASM 3.0</p><p>Equivalent to <a href="#MimiqCircuitsBase.GateP"><code>GateP</code></a></p><p><strong>Arguments</strong></p><ul><li><code>λ::Float64</code>: Rotation angle in radians</li></ul><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname{U1}(\lambda) =
\begin{pmatrix}
    1 &amp; 0 \\
    0 &amp; e^{i\lambda}
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateU1(pi/4))
2×2 Matrix{ComplexF64}:
 1.0+0.0im       0.0+0.0im
 0.0+0.0im  0.707107+0.707107im

julia&gt; push!(Circuit(), GateU1(pi/4), 1)
1-qubit circuit with 1 instructions:
└── U1(λ=0.7853981633974483) @ q1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/singlequbitpar.jl#L307-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateU2" href="#MimiqCircuitsBase.GateU2"><code>MimiqCircuitsBase.GateU2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateU2 &lt;: ParametricGate{1}</code></pre><p>One qubit generic unitary gate <code>u2</code>, as defined in OpenQASM 3.0</p><p>See also <a href="#MimiqCircuitsBase.GateU2DG"><code>GateU2DG</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>ϕ:Float64</code>: Rotation angle in radians</li><li><code>λ::Float64</code>: Rotation angle in radians</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateU2(pi/2,pi/4))
2×2 Matrix{ComplexF64}:
 0.270598-0.653281im  -0.653281+0.270598im
 0.653281+0.270598im   0.270598+0.653281im

julia&gt; push!(Circuit(), GateU2(pi/4,pi/4), 1)
1-qubit circuit with 1 instructions:
└── U2(ϕ=0.7853981633974483, λ=0.7853981633974483) @ q1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/singlequbitpar.jl#L363-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateU2DG" href="#MimiqCircuitsBase.GateU2DG"><code>MimiqCircuitsBase.GateU2DG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateU2DG &lt;: ParametricGate{1}</code></pre><p>One qubit generic unitary gate <code>u2</code>-dagger, as defined in OpenQASM 3.0 for backwards compatibility</p><p>See also <a href="#MimiqCircuitsBase.GateU2"><code>GateU2</code></a></p><p><strong>Arguments</strong></p><ul><li><code>ϕ:Float64</code>: Rotation angle in radians</li><li><code>λ::Float64</code>: Rotation angle in radians</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateU2DG(pi/2,pi/4))
2×2 Matrix{ComplexF64}:
  0.270598+0.653281im  0.653281-0.270598im
 -0.653281-0.270598im  0.270598-0.653281im

julia&gt; push!(Circuit(), GateU2DG(pi/2,pi/4), 1)
1-qubit circuit with 1 instructions:
└── U2DG(ϕ=1.5707963267948966, λ=0.7853981633974483) @ q1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/singlequbitpar.jl#L412-L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateU3" href="#MimiqCircuitsBase.GateU3"><code>MimiqCircuitsBase.GateU3</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateU3 &lt;: ParametricGate{1}</code></pre><p>One qubit generic unitary gate <code>u3</code>, as defined in OpenQASM 3.0 for backwards compatibility.</p><p><strong>Arguments</strong></p><ul><li><code>θ:Float64</code>: Rotation angle 1 in radians</li><li><code>ϕ:Float64</code>: Rotation angle 2 in radians</li><li><code>λ::Float64</code>: Rotation angle 3 in radians</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateU3(pi/2,pi/4,pi/2))
2×2 Matrix{ComplexF64}:
 0.270598-0.653281im  -0.653281-0.270598im
 0.653281-0.270598im   0.270598+0.653281im

julia&gt; push!(Circuit(), GateU3(pi/2, pi/4, pi/2), 1)
1-qubit circuit with 1 instructions:
└── U3(θ=1.5707963267948966, ϕ=0.7853981633974483, λ=1.5707963267948966) @ q1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/singlequbitpar.jl#L459-L482">source</a></section></article><h4 id="Two-qubit-gates"><a class="docs-heading-anchor" href="#Two-qubit-gates">Two-qubit gates</a><a id="Two-qubit-gates-1"></a><a class="docs-heading-anchor-permalink" href="#Two-qubit-gates" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateCH" href="#MimiqCircuitsBase.GateCH"><code>MimiqCircuitsBase.GateCH</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateCH &lt;: Gate{2}</code></pre><p>Two qubit Controlled-Hadamard gate.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname{CH} = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\
    0 &amp; 0 &amp; \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}
\end{pmatrix}\]</p><p>By convention we refer to the first qubit as the control qubit and the second qubit as the target.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateCH())
4×4 Matrix{Float64}:
 1.0  0.0  0.0        0.0
 0.0  1.0  0.0        0.0
 0.0  0.0  0.707107   0.707107
 0.0  0.0  0.707107  -0.707107

julia&gt; push!(Circuit(), GateCH(), 1, 2)
2-qubit circuit with 1 instructions:
└── CH @ q1, q2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/twoqubit.jl#L141-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateCS" href="#MimiqCircuitsBase.GateCS"><code>MimiqCircuitsBase.GateCS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateCS &lt;: Gate{2}</code></pre><p>Two qubit Controlled-S gate.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; i
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateCS())
4×4 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+1.0im

julia&gt; push!(Circuit(), GateCS(), 1, 2)
2-qubit circuit with 1 instructions:
└── CS @ q1, q2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/twoqubit.jl#L309-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateCSDG" href="#MimiqCircuitsBase.GateCSDG"><code>MimiqCircuitsBase.GateCSDG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateCSDG &lt;: Gate{2}</code></pre><p>Two qubit CS-dagger gate.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; i
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateCSDG())
4×4 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0-1.0im

julia&gt; push!(Circuit(), GateCSDG(), 1, 2)
2-qubit circuit with 1 instructions:
└── CSDG @ q1, q2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/twoqubit.jl#L348-L378">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateCSX" href="#MimiqCircuitsBase.GateCSX"><code>MimiqCircuitsBase.GateCSX</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateCSX &lt;: Gate{2}</code></pre><p>Two qubit Controlled-SX gate. (Control on second qubit)</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; \frac{1+i}{\sqrt{2}} &amp; 0 &amp; \frac{1-i}{\sqrt{2}} \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; \frac{1-i}{\sqrt{2}} &amp; 0 &amp; \frac{1+i}{\sqrt{2}}
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateCSX())
4×4 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.5+0.5im  0.0+0.0im  0.5-0.5im
 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im
 0.0+0.0im  0.5-0.5im  0.0+0.0im  0.5+0.5im

julia&gt; push!(Circuit(), GateCSX(), 1, 2)
2-qubit circuit with 1 instructions:
└── CSX @ q1, q2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/twoqubit.jl#L387-L417">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateCSXDG" href="#MimiqCircuitsBase.GateCSXDG"><code>MimiqCircuitsBase.GateCSXDG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateCSXDG &lt;: Gate{2}</code></pre><p>Two qubit CSX-dagger gate. (Control on second qubit)</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; \frac{1-i}{\sqrt{2}} &amp; 0 &amp; \frac{1+i}{\sqrt{2}} \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; \frac{1+i}{\sqrt{2}} &amp; 0 &amp; \frac{1-i}{\sqrt{2}}
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateCSXDG())
4×4 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.5-0.5im  0.0+0.0im  0.5+0.5im
 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im
 0.0+0.0im  0.5+0.5im  0.0+0.0im  0.5-0.5im

julia&gt; push!(Circuit(), GateCSXDG(), 1, 2)
2-qubit circuit with 1 instructions:
└── CSXDG @ q1, q2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/twoqubit.jl#L426-L456">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateCX" href="#MimiqCircuitsBase.GateCX"><code>MimiqCircuitsBase.GateCX</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateCX &lt;: Gate{2}</code></pre><p>Two qubit Controlled-X gate (or CNOT).</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname{CX} =
\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 \\
    0 &amp; 0 &amp; 1 &amp; 0
\end{pmatrix}\]</p><p>By convention we refer to the first qubit as the control qubit and the second qubit as the target.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateCX())
4×4 Matrix{Float64}:
 1.0  0.0  0.0   0.0
 0.0  1.0  0.0   0.0
 0.0  0.0  0.0   1.0
 0.0  0.0  1.0  -0.0


julia&gt; push!(Circuit(), GateCX(), 1, 2)
2-qubit circuit with 1 instructions:
└── CX @ q1, q2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/twoqubit.jl#L17-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateCY" href="#MimiqCircuitsBase.GateCY"><code>MimiqCircuitsBase.GateCY</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateCY &lt;: Gate{2}</code></pre><p>Two qubit Controlled-Y gate.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname{CY} = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; -i \\
    0 &amp; 0 &amp; i &amp; 0
\end{pmatrix}\]</p><p>By convention we refer to the first qubit as the control qubit and the second qubit as the target.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateCY())
4×4 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im  0.0+0.0im   0.0+0.0im
 0.0+0.0im  1.0+0.0im  0.0+0.0im   0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  -0.0-1.0im
 0.0+0.0im  0.0+0.0im  0.0+1.0im  -0.0+0.0im

julia&gt; push!(Circuit(), GateCY(), 1, 2)
2-qubit circuit with 1 instructions:
└── CY @ q1, q2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/twoqubit.jl#L60-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateCZ" href="#MimiqCircuitsBase.GateCZ"><code>MimiqCircuitsBase.GateCZ</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateCZ &lt;: Gate{2}</code></pre><p>Two qubit Controlled-Z gate.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname{CZ} = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; -1
\end{pmatrix}\]</p><p>By convention we refer to the first qubit as the control qubit and the second qubit as the target.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateCZ())
4×4 Matrix{Float64}:
 1.0  0.0  0.0   0.0
 0.0  1.0  0.0   0.0
 0.0  0.0  1.0   0.0
 0.0  0.0  0.0  -1.0

julia&gt; push!(Circuit(), GateCZ(), 1, 2)
2-qubit circuit with 1 instructions:
└── CZ @ q1, q2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/twoqubit.jl#L101-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateDCX" href="#MimiqCircuitsBase.GateDCX"><code>MimiqCircuitsBase.GateDCX</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateDCX &lt;: Gate{2}</code></pre><p>Two qubit double-CNOT (Control on first qubit and then second) OR DCX gate.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateDCX())
4×4 Matrix{Float64}:
 1.0  0.0  0.0  0.0
 0.0  0.0  0.0  1.0
 0.0  1.0  0.0  0.0
 0.0  0.0  1.0  0.0

julia&gt; push!(Circuit(), GateDCX(), 1, 2)
2-qubit circuit with 1 instructions:
└── DCX @ q1, q2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/twoqubit.jl#L505-L535">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateDCXDG" href="#MimiqCircuitsBase.GateDCXDG"><code>MimiqCircuitsBase.GateDCXDG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateDCXDG &lt;: Gate{2}</code></pre><p>Two qubit DCX-dagger gate.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 \\
    0 &amp; 1 &amp; 0 &amp; 0
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateDCXDG())
4×4 Matrix{Float64}:
 1.0  0.0  0.0  0.0
 0.0  0.0  1.0  0.0
 0.0  0.0  0.0  1.0
 0.0  1.0  0.0  0.0

julia&gt; push!(Circuit(), GateDCXDG(), 1, 2)
2-qubit circuit with 1 instructions:
└── DCXDG @ q1, q2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/twoqubit.jl#L544-L575">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateECR" href="#MimiqCircuitsBase.GateECR"><code>MimiqCircuitsBase.GateECR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateECR &lt;: Gate{2}</code></pre><p>Two qubit ECR echo gate.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\begin{pmatrix}
    0 &amp; \frac{1}{\sqrt{2}} \ &amp; 0 &amp; \frac{i}{\sqrt{2}} \\ 
    \frac{1}{\sqrt{2}} &amp; 0 &amp; \frac{-i}{\\sqrt{2}} &amp; 0 \\
    0 &amp; \frac{i}{\\sqrt{2}} &amp; 0 &amp; \frac{i}{\sqrt{2}} \\ 
    \frac{-i}{\sqrt{2}} &amp; 0 &amp; \frac{1}{\sqrt{2}}  &amp; 0 
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateCSX())
4×4 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.5+0.5im  0.0+0.0im  0.5-0.5im
 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im
 0.0+0.0im  0.5-0.5im  0.0+0.0im  0.5+0.5im

julia&gt; push!(Circuit(), GateCSX(), 1, 2)
2-qubit circuit with 1 instructions:
└── CSX @ q1, q2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/twoqubit.jl#L465-L495">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateISWAP" href="#MimiqCircuitsBase.GateISWAP"><code>MimiqCircuitsBase.GateISWAP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateISWAP &lt;: Gate{2}</code></pre><p>Two qubit ISWAP gate.</p><p>See also <a href="#MimiqCircuitsBase.GateISWAPDG"><code>GateISWAPDG</code></a>, <a href="#MimiqCircuitsBase.GateSWAP"><code>GateSWAP</code></a>.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname{ISWAP} = \frac{1}{\sqrt{2}}
\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; i &amp; 0 \\
    0 &amp; i &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateISWAP())
4×4 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+1.0im  0.0+0.0im
 0.0+0.0im  0.0+1.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  1.0+0.0im

julia&gt; push!(Circuit(), GateISWAP(), 1, 2)
2-qubit circuit with 1 instructions:
└── ISWAP @ q1, q2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/twoqubit.jl#L224-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateISWAPDG" href="#MimiqCircuitsBase.GateISWAPDG"><code>MimiqCircuitsBase.GateISWAPDG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateISWAPDG &lt;: Gate{2}</code></pre><p>Two qubit ISWAP-dagger gate (conjugate transpose of ISWAP)</p><p>See also <a href="#MimiqCircuitsBase.GateISWAP"><code>GateISWAP</code></a>, <a href="#MimiqCircuitsBase.GateSWAP"><code>GateSWAP</code></a></p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname{ISWAP}^\dagger = \frac{1}{\sqrt{2}}
\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; -i &amp; 0 \\
    0 &amp; -i &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateISWAPDG())
4×4 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0-1.0im  0.0+0.0im
 0.0+0.0im  0.0-1.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  1.0+0.0im

julia&gt; push!(Circuit(), GateISWAPDG(), 1, 2)
2-qubit circuit with 1 instructions:
└── ISWAPDG @ q1, q2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/twoqubit.jl#L266-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateSWAP" href="#MimiqCircuitsBase.GateSWAP"><code>MimiqCircuitsBase.GateSWAP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateSWAP &lt;: Gate{2}</code></pre><p>Two qubit SWAP gate.</p><p>See also <a href="#MimiqCircuitsBase.GateISWAP"><code>GateISWAP</code></a></p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname{SWAP} = \frac{1}{\sqrt{2}}
\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateSWAP())
4×4 Matrix{Float64}:
 1.0  0.0  0.0  0.0
 0.0  0.0  1.0  0.0
 0.0  1.0  0.0  0.0
 0.0  0.0  0.0  1.0

julia&gt; push!(Circuit(), GateSWAP(), 1, 2)
2-qubit circuit with 1 instructions:
└── SWAP @ q1, q2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/twoqubit.jl#L182-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateCP" href="#MimiqCircuitsBase.GateCP"><code>MimiqCircuitsBase.GateCP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateCP &lt;: ParametricGate{2}</code></pre><p>Two qubit Controlled-Phase gate </p><p><strong>Arguments</strong></p><ul><li><code>λ::Float64</code>: Phase angle in radians</li></ul><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname{CP}(\lambda) = \begin{pmatrix}
          1 &amp; 0 &amp; 0 &amp; 0 \\
          0 &amp; 1 &amp; 0 &amp; 0 \\
          0 &amp; 0 &amp; 1 &amp; 0 \\
          0 &amp; 0 &amp; 0 &amp; e^{i\lambda}
      \end{pmatrix}\]</p><p>By convention we refer to the first qubit as the control qubit and the second qubit as the target.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateCP(pi/4))
4×4 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im  0.0+0.0im       0.0+0.0im
 0.0+0.0im  1.0+0.0im  0.0+0.0im       0.0+0.0im
 0.0+0.0im  0.0+0.0im  1.0+0.0im       0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.707107+0.707107im

julia&gt; push!(Circuit(), GateCP(pi/4), 1, 2)
2-qubit circuit with 1 instructions:
└── CP(λ=0.7853981633974483) @ q1, q2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/twoqubitpar.jl#L17-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateCR" href="#MimiqCircuitsBase.GateCR"><code>MimiqCircuitsBase.GateCR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateCR &lt;: ParametricGate{2}

Two qubit Controlled-R gate.</code></pre><p><strong>Arguments</strong></p><ul><li><code>θ::Float64</code>: Rotation angle in radians</li><li><code>ϕ::Float64</code>: The phase angle in radians.</li></ul><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname{CR}(\theta, \phi) =
\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; \cos\frac{\theta}{2} &amp; -ie^{-i\phi}\sin\\frac{\theta}{2} \\
    0 &amp; 0 &amp; -ie^{i\phi}\sin\frac{\theta}{2} &amp; \cos\frac{\theta}{2}
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateCR(pi,-pi))
4×4 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im           0.0+0.0im          0.0+0.0im
 0.0+0.0im  1.0+0.0im           0.0+0.0im          0.0+0.0im
 0.0+0.0im  0.0+0.0im   6.12323e-17+0.0im  1.22465e-16+1.0im
 0.0+0.0im  0.0+0.0im  -1.22465e-16+1.0im  6.12323e-17+0.0im

julia&gt; push!(Circuit(), GateCR(pi,-pi), 1, 2)
2-qubit circuit with 1 instructions:
└── CR(θ=3.141592653589793, ϕ=-3.141592653589793) @ q1, q2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/twoqubitpar.jl#L347-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateCRX" href="#MimiqCircuitsBase.GateCRX"><code>MimiqCircuitsBase.GateCRX</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateCRX &lt;: ParametricGate{2}</code></pre><p>Two qubit Controlled-RX gate </p><p><strong>Arguments</strong></p><ul><li><code>θ::Float64</code>: Rotation angle in radians</li></ul><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname{CRX}(\theta) =
\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; \cos\frac{\theta}{2} &amp; -i\sin\frac{\theta}{2} \\
    0 &amp; 0 &amp; -i\sin\frac{\theta}{2} &amp; \cos\frac{\theta}{2}
\end{pmatrix}\]</p><p>By convention we refer to the first qubit as the control qubit and the second qubit as the target.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateCRX(pi/2))
4×4 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im       0.0+0.0im            0.0+0.0im
 0.0+0.0im  1.0+0.0im       0.0+0.0im            0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.707107+0.0im           -0.0-0.707107im
 0.0+0.0im  0.0+0.0im       0.0-0.707107im  0.707107+0.0im

julia&gt; push!(Circuit(), GateCRX(pi/2), 1, 2)
2-qubit circuit with 1 instructions:
└── CRX(θ=1.5707963267948966) @ q1, q2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/twoqubitpar.jl#L80-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateCRY" href="#MimiqCircuitsBase.GateCRY"><code>MimiqCircuitsBase.GateCRY</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateCRY &lt;: ParametricGate{2}</code></pre><p>Two qubit Controlled-RY gate </p><p><strong>Arguments</strong></p><ul><li><code>θ::Float64</code>: Rotation angle in radians</li></ul><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname{CRY}(\theta) =
\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; \cos\frac{\theta}{2} &amp; -\sin\frac{\theta}{2} \\
    0 &amp; 0 &amp; \sin\frac{\theta}{2} &amp; \cos\frac{\theta}{2}
\end{pmatrix}\]</p><p>By convention we refer to the first qubit as the control qubit and the second qubit as the target.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateCRY(pi/2))
4×4 Matrix{Float64}:
 1.0  0.0  0.0        0.0
 0.0  1.0  0.0        0.0
 0.0  0.0  0.707107  -0.707107
 0.0  0.0  0.707107   0.707107

julia&gt; push!(Circuit(), GateCRY(pi/2), 1, 2)
2-qubit circuit with 1 instructions:
└── CRY(θ=1.5707963267948966) @ q1, q2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/twoqubitpar.jl#L148-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateCRZ" href="#MimiqCircuitsBase.GateCRZ"><code>MimiqCircuitsBase.GateCRZ</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateCRZ &lt;: ParametricGate{2}</code></pre><p>Two qubit Controlled-RZ gate </p><p><strong>Arguments</strong></p><ul><li><code>λ::Float64</code>: Rotation angle in radians</li></ul><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname{CRZ}(\lambda) =
\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; e^{-i\frac{\lambda}{2}} &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; e^{i\frac{\lambda}{2}}
\end{pmatrix}\]</p><p>By convention we refer to the first qubit as the control qubit and the second qubit as the target.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateCRZ(pi/2))
4×4 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im       0.0+0.0im            0.0+0.0im
 0.0+0.0im  1.0+0.0im       0.0+0.0im            0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.707107-0.707107im      -0.0+0.0im
 0.0+0.0im  0.0+0.0im       0.0+0.0im       0.707107+0.707107im

julia&gt; push!(Circuit(), GateCRZ(pi/2), 1, 2)
2-qubit circuit with 1 instructions:
└── CRZ(λ=1.5707963267948966) @ q1, q2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/twoqubitpar.jl#L212-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateCU" href="#MimiqCircuitsBase.GateCU"><code>MimiqCircuitsBase.GateCU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateCU &lt;: ParametricGate{2}</code></pre><p>Two qubit generic unitary gate, equivalent to the qiskit CUGate <code>https://qiskit.org/documentation/stubs/qiskit.circuit.library.CUGate.html</code></p><p><strong>Arguments</strong></p><ul><li><code>θ::Float64</code>: Euler angle 1 in radians</li><li><code>ϕ::Float64</code>: Euler angle 2 in radians</li><li><code>λ::Float64</code>: Euler angle 3 in radians</li><li><code>γ::Float64</code>: Global phase of the U gate</li></ul><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname{CU}(\theta,\phi,\lambda,\gamma) =
\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; e^{i\gamma}\cos\frac{\theta}{2} &amp; -e^{i(\gamma+\lambda)}\sin\frac{\theta}{2} \\
    0 &amp; 0 &amp; e^{i(\gamma+\phi)}\sin\frac{\theta}{2} &amp; e^{i(\gamma+\phi+\lambda)}\cos\frac{\theta}{2}
\end{pmatrix}\]</p><p>By convention we refer to the first qubit as the control qubit and the second qubit as the target.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateCU(pi/3, pi/3, pi/3, 0))
4×4 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im       0.0+0.0im             0.0+0.0im
 0.0+0.0im  1.0+0.0im       0.0+0.0im             0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.866025+0.0im           -0.25-0.433013im
 0.0+0.0im  0.0+0.0im      0.25+0.433013im  -0.433013+0.75im

julia&gt; push!(Circuit(), GateCU(pi/3, pi/3, pi/3, 0), 1, 2)
2-qubit circuit with 1 instructions:
└── CU(θ=1.0471975511965976, ϕ=1.0471975511965976, λ=1.0471975511965976, γ=0.0) @ q1, q2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/twoqubitpar.jl#L276-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateRXX" href="#MimiqCircuitsBase.GateRXX"><code>MimiqCircuitsBase.GateRXX</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateRXX &lt;: ParametricGate{2}</code></pre><p>Two qubit RXX gate.</p><p><strong>Arguments</strong></p><ul><li><code>θ::Float64</code>: The angle in radians</li></ul><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname{RXX}(\theta) =
\begin{pmatrix}
    \cos(\\frac{\theta}{2}) &amp; 0 &amp; 0 &amp; -i\sin(\\frac{\theta}{2}) \\
    0 &amp; \cos(\frac{\theta}{2}) &amp; -i\sin(\frac{\theta}{2}) &amp; 0 \\
    0 &amp; -i\sin(\frac{\theta}{2}) &amp; \cos(\frac{\theta}{2}) &amp; 0 \\
    -i\sin(\frac{\theta}{2}) &amp; 0 &amp; 0 &amp; \cos(\frac{\theta}{2})
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateRXX(π/4))
4×4 Matrix{ComplexF64}:
 0.92388+0.0im           0.0+0.0im       …      0.0-0.382683im
     0.0+0.0im       0.92388+0.0im              0.0+0.0im
     0.0+0.0im           0.0-0.382683im         0.0+0.0im
     0.0-0.382683im      0.0+0.0im          0.92388+0.0im

julia&gt; push!(Circuit(), GateRXX(π), 1, 2)
2-qubit circuit with 1 instructions:
└── RXX(θ=3.141592653589793) @ q1, q2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/twoqubitpar.jl#L407-L442">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateRYY" href="#MimiqCircuitsBase.GateRYY"><code>MimiqCircuitsBase.GateRYY</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateRYY &lt;: ParametricGate{2}</code></pre><p>Two qubit RYY gate.</p><p><strong>Arguments</strong></p><ul><li><code>θ::Float64</code>: The angle in radians</li></ul><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname{RYY}(\theta) =
\begin{pmatrix}
    \cos(\frac{\theta}{2}) &amp; 0 &amp; 0 &amp; i\sin(\frac{\theta}{2}) \\
    0 &amp; \cos(\frac{\theta}{2}) &amp; -i\sin(\frac{\theta}{2}) &amp; 0 \\
    0 &amp; -i\sin(\\frac{\theta}{2}) &amp; \cos(\frac{\theta}{2}) &amp; 0 \\
    i\sin(\frac{\theta}{2}) &amp; 0 &amp; 0 &amp; \cos(\frac{\theta}{2})
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateRYY(π/4))
4×4 Matrix{ComplexF64}:
 0.92388+0.0im           0.0+0.0im       …      0.0+0.382683im
     0.0+0.0im       0.92388+0.0im              0.0+0.0im
     0.0+0.0im           0.0-0.382683im         0.0+0.0im
     0.0+0.382683im      0.0+0.0im          0.92388+0.0im

julia&gt; push!(Circuit(), GateRYY(π), 1, 2)
2-qubit circuit with 1 instructions:
└── RYY(θ=3.141592653589793) @ q1, q2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/twoqubitpar.jl#L473-L508">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateRZZ" href="#MimiqCircuitsBase.GateRZZ"><code>MimiqCircuitsBase.GateRZZ</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateRZZ &lt;: ParametricGate{2}</code></pre><p>Two qubit RZZ gate.</p><p><strong>Arguments</strong></p><ul><li><code>θ::Float64</code>: The angle in radians</li></ul><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname{RZZ}(\theta) =
\begin{pmatrix}
    e^{-i\frac{\theta}{2}} &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; e^{i\frac{\theta}{2}} &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; e^{i\frac{\theta}{2}} &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; e^{-i\frac{\theta}{2}}
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateRZZ(π/4))
4×4 Matrix{ComplexF64}:
 0.92388-0.382683im      0.0+0.0im       …      0.0+0.0im
     0.0+0.0im       0.92388+0.382683im         0.0+0.0im
     0.0+0.0im           0.0+0.0im              0.0+0.0im
     0.0+0.0im           0.0+0.0im          0.92388-0.382683im

julia&gt; push!(Circuit(), GateRZZ(π), 1, 2)
2-qubit circuit with 1 instructions:
└── RZZ(θ=3.141592653589793) @ q1, q2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/twoqubitpar.jl#L539-L574">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateXXminusYY" href="#MimiqCircuitsBase.GateXXminusYY"><code>MimiqCircuitsBase.GateXXminusYY</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateXXminusYY &lt;: ParametricGate{2}</code></pre><p>Two qubit XXminusYY gate.</p><p><strong>Arguments</strong></p><ul><li><code>θ::Float64</code>: The angle in radians.</li><li><code>β::Float64</code>: The phase angle in radians.</li></ul><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname{XXminusYY}(\theta, \beta) =
    \begin{pmatrix}
        \cos(\frac{\theta}{2}) &amp; 0 &amp; 0 &amp; -i\sin(\frac{\theta}{2})e^{-i\beta} \\
        0 &amp; 1 &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; 1 &amp; 0 \\
        -i\sin(\frac{\theta}{2})e^{i\beta} &amp; 0 &amp; 0 &amp; \cos(\frac{\theta}{2})
    \end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateXXminusYY(π/2,π/2))
4×4 Matrix{ComplexF64}:
 0.707107+0.0im          0.0+0.0im  0.0+0.0im  -0.707107-4.32978e-17im
      0.0+0.0im          1.0+0.0im  0.0+0.0im        0.0+0.0im
      0.0+0.0im          0.0+0.0im  1.0+0.0im        0.0+0.0im
 0.707107-4.32978e-17im  0.0+0.0im  0.0+0.0im   0.707107+0.0im

julia&gt; push!(Circuit(), GateXXminusYY(π,π), 1, 2)
2-qubit circuit with 1 instructions:
└── XXminusYY(θ=3.141592653589793, β=3.141592653589793) @ q1, q2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/twoqubitpar.jl#L664-L699">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateXXplusYY" href="#MimiqCircuitsBase.GateXXplusYY"><code>MimiqCircuitsBase.GateXXplusYY</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateXXplusYY &lt;: ParametricGate{2}</code></pre><p>Two qubit XXplusYY gate.</p><p><strong>Arguments</strong></p><ul><li><code>θ::Float64</code>: The angle in radians.</li><li><code>β::Float64</code>: The phase angle in radians.</li></ul><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname{XXplusYY}(\theta, \beta) =
    \begin{pmatrix}
        1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; \cos(\frac{\theta}{2}) &amp; -i\sin(\frac{\theta}{2})e^{-i\beta} &amp; 0 \\
        0 &amp; -i\sin(\\frac{theta}{2})e^{i\beta} &amp; \cos(\frac{\theta}{2}) &amp; 0 \\
        0 &amp; 0 &amp; 0 &amp; 1
    \end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateXXplusYY(π/2,π/2))
4×4 Matrix{ComplexF64}:
 1.0+0.0im       0.0+0.0im                0.0+0.0im          0.0+0.0im
 0.0+0.0im  0.707107+0.0im          -0.707107-4.32978e-17im  0.0+0.0im
 0.0+0.0im  0.707107-4.32978e-17im   0.707107+0.0im          0.0+0.0im
 0.0+0.0im       0.0+0.0im                0.0+0.0im          1.0+0.0im

julia&gt; push!(Circuit(), GateXXplusYY(π,π), 1, 2)
2-qubit circuit with 1 instructions:
└── XXplusYY(θ=3.141592653589793, β=3.141592653589793) @ q1, q2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/twoqubitpar.jl#L597-L630">source</a></section></article><h4 id="Multi-qubit"><a class="docs-heading-anchor" href="#Multi-qubit">Multi-qubit</a><a id="Multi-qubit-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-qubit" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateCCX" href="#MimiqCircuitsBase.GateCCX"><code>MimiqCircuitsBase.GateCCX</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateCCX &lt;: Gate{3}</code></pre><p>C₂X (or C₂NOT) 3-qubits gate. Where the first two qubits are used as controls.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/multiqubit.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateCSWAP" href="#MimiqCircuitsBase.GateCSWAP"><code>MimiqCircuitsBase.GateCSWAP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateCSWAP &lt;: Gate{3} end</code></pre><p>3-qubits control SWAP gate where the first qubit is the control.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/multiqubit.jl#L30-L34">source</a></section></article><h4 id="Custom-gates"><a class="docs-heading-anchor" href="#Custom-gates">Custom gates</a><a id="Custom-gates-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-gates" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.GateCustom" href="#MimiqCircuitsBase.GateCustom"><code>MimiqCircuitsBase.GateCustom</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateCustom{N,T} &lt;: Gate{N}</code></pre><p><code>N</code> qubit gate specified by a <span>$2^N \times 2^N$</span> matrix with elements of type <code>T</code>.</p><p>Use this to construct your own gates based on unitary matrices. Currently only N=1,2 (M=2,4) are recognised.</p><p>MIMIQ uses textbook convention for specifying gates.</p><p>One qubit gate matrices are defined in the basis <span>$|0\rangle$</span>, <span>$|1\rangle$</span> e.g.,</p><p class="math-container">\[\operatorname{Z} =
\begin{pmatrix}
    1&amp;0\\
    0&amp;-1
\end{pmatrix}\]</p><p>Two qubit gate matrices are defined in the basis <span>$|00\rangle$</span>, <span>$|01\rangle$</span>&gt;, <span>$|10\rangle$</span>, <span>$|11\rangle$</span> where the left-most qubit is the first to appear in the target list e.g.,</p><p class="math-container">\[\operatorname{CNOT} =
\begin{pmatrix}
    1&amp;0&amp;0&amp;0\\
    0&amp;1&amp;0&amp;0\\
    0&amp;0&amp;0&amp;1\\
    0&amp;0&amp;1&amp;0
\end{pmatrix}\]</p><pre><code class="nohighlight hljs">julia&gt; CNOT = [1 0 0 0; 0 1 0 0; 0 0 0 1; 0 0 1 0]
4×4 Matrix{Int64}:
 1  0  0  0
 0  1  0  0
 0  0  0  1
 0  0  1  0

julia&gt; # CNOT gate with control on q1 and target on q2

julia&gt; Instruction(GateCustom(CNOT), 1, 2)
GateCustom([1 0 0 0; 0 1 0 0; 0 0 0 1; 0 0 1 0]) @ q1, q2

# Examples
</code></pre><p>jldoctest julia&gt; g = GateCustom([1 0; 0 1]) Custom([1.0 0.0; 0.0 1.0])</p><p>julia&gt; push!(Circuit(), g, 1) 1-qubit circuit with 1 instructions: └── Custom([1.0 0.0; 0.0 1.0]) @ q1 ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/gates/custom.jl#L7-L67">source</a></section></article><h3 id="Non-unitary-operations"><a class="docs-heading-anchor" href="#Non-unitary-operations">Non-unitary operations</a><a id="Non-unitary-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Non-unitary-operations" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.Reset" href="#MimiqCircuitsBase.Reset"><code>MimiqCircuitsBase.Reset</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Reset &lt;: Operation{1}</code></pre><p>Quantum operation that resets the status of one qubit to the <span>$\ket{0}$</span> state.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; push!(Circuit(), Reset(), 1)
1-qubit circuit with 1 instructions:
└── Reset @ q1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/reset.jl#L17-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.Measure" href="#MimiqCircuitsBase.Measure"><code>MimiqCircuitsBase.Measure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Measure &lt;: Operation{1}</code></pre><p>Single qubit measurement operation in the computational basis</p><p>This operation is non-reversible</p><p><strong>Examples</strong></p><p>Measure project the qubit state and optionally store the result of the measurement for that qubit in a classical register.</p><p>To just apply the measurement on qubit <code>1</code> and discard the result, do:</p><pre><code class="language-julia-repl hljs">julia&gt; push!(Circuit(), Measure(), 1,1)
1-qubit circuit with 1 instructions:
└── Measure @ q1, c1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/measure.jl#L17-L36">source</a></section></article><h3 id="No-ops"><a class="docs-heading-anchor" href="#No-ops">No-ops</a><a id="No-ops-1"></a><a class="docs-heading-anchor-permalink" href="#No-ops" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.Barrier" href="#MimiqCircuitsBase.Barrier"><code>MimiqCircuitsBase.Barrier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Barrier &lt;: Operation{1}</code></pre><p>A barrier is a special operation that does not affect the quantum state or the execution of a circuit, but it prevents compression or optimization operation from being applied across it.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; push!(Circuit(), Barrier(), 1)
1-qubit circuit with 1 instructions:
└── Barrier @ q1

julia&gt; push!(Circuit(), Barrier(4), 1:4...)
4-qubit circuit with 1 instructions:
└── Barrier @ q1, q2, q3, q4

julia&gt; push!(Circuit(), Barrier(), 1:4)
4-qubit circuit with 4 instructions:
├── Barrier @ q1
├── Barrier @ q2
├── Barrier @ q3
└── Barrier @ q4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/barrier.jl#L17-L42">source</a></section></article><h3 id="Composite-operations"><a class="docs-heading-anchor" href="#Composite-operations">Composite operations</a><a id="Composite-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Composite-operations" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.IfStatement" href="#MimiqCircuitsBase.IfStatement"><code>MimiqCircuitsBase.IfStatement</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct IfStatement{N,M} &lt;: Operation{N,M}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/ifstatement.jl#L17-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.Control" href="#MimiqCircuitsBase.Control"><code>MimiqCircuitsBase.Control</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Control{N,M,L,T&lt;:Operation{M,0}} &lt;: Operation{L,0} end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/control.jl#L17-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.Parallel" href="#MimiqCircuitsBase.Parallel"><code>MimiqCircuitsBase.Parallel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Parallel{N,M,L,T&lt;:Operation{M,0}} &lt;: Operation{L,0} end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/operations/parallel.jl#L17-L19">source</a></section></article><h2 id="Bit-States"><a class="docs-heading-anchor" href="#Bit-States">Bit States</a><a id="Bit-States-1"></a><a class="docs-heading-anchor-permalink" href="#Bit-States" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.BitState" href="#MimiqCircuitsBase.BitState"><code>MimiqCircuitsBase.BitState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BitState</code></pre><p>Representation of the quantum state of a quantum register with definite values for each qubit.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; BitState(16)
16-qubit BitState with 0 non-zero qubits:
└── |0000000000000000⟩

julia&gt; bs = BitState(16, [1,2,3,4])
16-qubit BitState with 4 non-zero qubits:
├── |1111000000000000⟩
└── non-zero qubits: [1, 2, 3, 4]

julia&gt; bs[10] = 1
1

julia&gt; bs
16-qubit BitState with 5 non-zero qubits:
├── |1111000001000000⟩
└── non-zero qubits: [1, 2, 3, 4, 10]

julia&gt; c = Circuit()
empty circuit

julia&gt; push!(c, GateX(), 8)
8-qubit circuit with 1 instructions:
└── X @ q8

julia&gt; BitState(c, [1,3,5,8])
8-qubit BitState with 4 non-zero qubits:
├── |10101001⟩
└── non-zero qubits: [1, 3, 5, 8]

julia&gt; bitstate_to_integer(bs)
527

julia&gt; typeof(ans)
BigInt

julia&gt; bitstate_to_integer(bs, Int64)
527

julia&gt; typeof(ans)
Int64</code></pre><p>There are many different ways to get bit states:</p><pre><code class="language-julia hljs">julia&gt; bs = BitState(30, 2344574)
30-qubit BitState with 13 non-zero qubits:
├── |011111100110001111000100000000⟩
└── non-zero qubits: [2, 3, 4, 5, 6, 7, 10, 11, 15, 16, 17, 18, 22]

julia&gt; ones(BitState, 10) # or also trues(BitState, 10)
10-qubit BitState with 10 non-zero qubits:
├── |1111111111⟩
└── non-zero qubits: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

julia&gt; zeros(BitState, 10) # or also falses(BitState, 10)
10-qubit BitState with 0 non-zero qubits:
└── |0000000000⟩

julia&gt; BitState(16) do i
           iseven(i)
       end
16-qubit BitState with 8 non-zero qubits:
├── |0101010101010101⟩
└── non-zero qubits: [2, 4, 6, 8, 10, 12, 14, 16]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/bitstates.jl#L45-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.bits-Tuple{BitState}" href="#MimiqCircuitsBase.bits-Tuple{BitState}"><code>MimiqCircuitsBase.bits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bits(bitstate)</code></pre><p>Get the underlying bit array of a bit state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/bitstates.jl#L313-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.bitstate_to_index-Tuple{BitState}" href="#MimiqCircuitsBase.bitstate_to_index-Tuple{BitState}"><code>MimiqCircuitsBase.bitstate_to_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bitstate_to_index(bitstate)</code></pre><p>Convert a bit state into the corresponding index.</p><p>This is useful for indexing, for example, a vector of states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/bitstates.jl#L164-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.bitstate_to_integer-Union{Tuple{BitState}, Tuple{T}, Tuple{BitState, Type{T}}} where T" href="#MimiqCircuitsBase.bitstate_to_integer-Union{Tuple{BitState}, Tuple{T}, Tuple{BitState, Type{T}}} where T"><code>MimiqCircuitsBase.bitstate_to_integer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bitstate_to_integer(bitstate[, T])</code></pre><p>Convert a bit state into its corresponding integer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/bitstates.jl#L157-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.nonzeros-Tuple{BitState}" href="#MimiqCircuitsBase.nonzeros-Tuple{BitState}"><code>MimiqCircuitsBase.nonzeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nonzeros(bitstate)</code></pre><p>Return the indices of the non-zero qubits in a bit state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/bitstates.jl#L186-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.to01-Tuple{BitState}" href="#MimiqCircuitsBase.to01-Tuple{BitState}"><code>MimiqCircuitsBase.to01</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to01(bitstate[, endianess=:big])</code></pre><p>Converts a BitState into a string of 0 and 1 characters. Optionally endianess can be specified, which can be either <code>:big</code> or <code>:little</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; to01(bs&quot;10011&quot;)
&quot;10011&quot;

julia&gt; to01(bs&quot;10011&quot;; endianess=:big)
&quot;10011&quot;

julia&gt; to01(bs&quot;10011&quot;; endianess=:little)
&quot;11001&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/bitstates.jl#L247-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MimiqCircuitsBase.@bs_str-Tuple{Any}" href="#MimiqCircuitsBase.@bs_str-Tuple{Any}"><code>MimiqCircuitsBase.@bs_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">macro bs_str(s)</code></pre><p>Convert a string into a bit state.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bs&quot;101011&quot;
6-qubit BitState with 4 non-zero qubits:
├── |101011⟩
└── non-zero qubits: [1, 3, 5, 6]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/9f6b571de912eb9bc9d484db4991e1c5c96bbe7e/src/bitstates.jl#L295-L308">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../outline/">« Contents</a><a class="docs-footer-nextpage" href="../internals/">Private »</a><div class="flexbox-break"></div><p class="footer-message">Copyright 2021-2023 QPerfect. All rights reserved.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 3 August 2023 15:30">Thursday 3 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
