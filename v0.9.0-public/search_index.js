var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"A. Barenco, C. H. Bennett, R. Cleve, D. P. DiVincenzo, N. Margolus, P. Shor, T. Sleator, J. A. Smolin and H. Weinfurter. Elementary gates for quantum computation. Phys. Rev. A 52, 3457–3467 (1995).\n\n\n\n","category":"page"},{"location":"library/function_index/#main-index","page":"Function index","title":"Index","text":"","category":"section"},{"location":"library/function_index/","page":"Function index","title":"Function index","text":"Pages = [\"public.md\", \"internals.md\", \"function_index.md\"]","category":"page"},{"location":"library/outline/#Library-Outline","page":"Contents","title":"Library Outline","text":"","category":"section"},{"location":"library/outline/","page":"Contents","title":"Contents","text":"Pages = [\"public.md\", \"internals.md\", \"function_index.md\"]","category":"page"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Private types and functions","category":"page"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Documentation for MimiqCircuitsBase.jl's internal interface.","category":"page"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Modules = [MimiqCircuitsBase]\nPublic  = false\nPages   = [\"MimiqCircuitsBase.jl\"]","category":"page"},{"location":"installation/#Installation-instructions","page":"Installation Instructions","title":"Installation instructions","text":"","category":"section"},{"location":"installation/","page":"Installation Instructions","title":"Installation Instructions","text":"Julia is required to use MimiqCircuitsBase.jl. If you do not have it on your system, please refer to the official website. We recommend to install Julia via the juliaup tool, which will manage updates and multiple versions of Julia on the same system automatically.","category":"page"},{"location":"installation/","page":"Installation Instructions","title":"Installation Instructions","text":"To install the latest version of MimiqCircuitsBase.jl, use the Julia's built-in package manager (accessed by pressing ] in the Julia REPL command prompt).","category":"page"},{"location":"installation/","page":"Installation Instructions","title":"Installation Instructions","text":"Before installing the package itself, since we didn't add it to the public Julia General registry, make sure to have installed QPerfect's own package registry.","category":"page"},{"location":"installation/","page":"Installation Instructions","title":"Installation Instructions","text":"julia> ]\n(v1.9) pkg> registry update\n(v1.9) pkg> registry add https://github.com/qperfect-io/QPerfectRegistry.git\n(v1.9) pkg> add MimiqCircuitsBase","category":"page"},{"location":"installation/","page":"Installation Instructions","title":"Installation Instructions","text":"note: Note\nThe ] registry update command will make sure, if this is your first time starting up Julia, to install and download the Julia General registry, where most packages are registered.","category":"page"},{"location":"#MimiqCircuitsBase.jl-Documentation","page":"Home","title":"MimiqCircuitsBase.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MimiqCircuitsBase provides a framework to build, manipulate, and analyze quantum circuits.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is an example on how to build a GHZ state preparation circuit with MimiqCircuitsBase. It has to be noted that this is not the optimal way to do it, but it is used here to showcase the syntax of MimiqCircuitsBase.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using MimiqCircuitsBase\nc = Circuit()\npush!(c, GateH(), 1)\npush!(c, GateCX(), 1, 2:4)\npush!(c, Barrier(1), 1:4)\nfor i in 1:4\n    push!(c, Measure(), i, i)\nend\nc","category":"page"},{"location":"library/operations/#Quantum-Operations-list","page":"List of Operations","title":"Quantum Operations list","text":"","category":"section"},{"location":"library/operations/","page":"List of Operations","title":"List of Operations","text":"List of operations implemented in MimiqCircuitsBase.jl's public interface.","category":"page"},{"location":"library/operations/","page":"List of Operations","title":"List of Operations","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"list.jl\"]","category":"page"},{"location":"library/operations/#MimiqCircuitsBase.GATES","page":"List of Operations","title":"MimiqCircuitsBase.GATES","text":"GATES\n\nList of gates provided by the library.\n\nSingle qubit gates\n\nGateID, GateX, GateY, GateZ, GateH, GateS, GateSDG, GateT, GateTDG, GateSX, GateSXDG.\n\nSingle qubit parametric gates\n\nGateU, GateP, GateRX, GateRY, GateRZ, GateR, GateU1, GateU2, GateU3.\n\nTwo qubit gates\n\nGateCX, GateCY, GateCZ, GateCH, GateSWAP, GateISWAP, GateCS, GateCSDG, GateCSX, GateCSXDG, GateECR, GateDCX,\n\nTwo qubit parametric gates\n\nGateCP, GateCU, GateCRX, GateCRY, GateCRZ, GateRXX, GateRYY, GateRZZ, GateRZX, GateXXplusYY, GateXXminusYY.\n\nMulti qubit Gates\n\nGateCCX, GateC3X, GateCCP, GateCSWAP.\n\nGeneralized gates\n\nThese defines an unitary quantum operation on non fixed number of qubits.\n\nSee GENERALIZED for a list of them.\n\nOperations\n\nSee OPERATIONS for a complete list of operations.\n\n\n\n\n\n","category":"constant"},{"location":"library/operations/#MimiqCircuitsBase.GENERALIZED","page":"List of Operations","title":"MimiqCircuitsBase.GENERALIZED","text":"GENERALIZED\n\nDefinition of complex unitary quantum opteration on a not fixed number of qubits, or on multiple groups of qubits (registers).\n\nUsually they are initialized with the number of qubits they operate on, or with the size of each group of qubits they act on\n\nQFT, PhaseGradient\n\n\n\n\n\n","category":"constant"},{"location":"library/operations/#MimiqCircuitsBase.OPERATIONS","page":"List of Operations","title":"MimiqCircuitsBase.OPERATIONS","text":"OPERATIONS\n\nPhases and other unitaries\n\nSee GATES for a complete list unitary gates.\n\nGateCustom\n\nFor gate definitions and calls, see GateDecl and GateCall\n\nOther circuits elements\n\nBarrier, IfStatement\n\nModifiers\n\nControl, Parallel, Power, Inverse\n\nNon-unitary operations\n\nMeasure, Reset\n\nAlgorithms or complex gate builders\n\nSee GENERALIZED for a complete list of generalized gates or algorithms.\n\n\n\n\n\n","category":"constant"},{"location":"library/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Documentation for MimiqCircuitsBase.jl's public interface.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"See the Internals section of the manual for internal package docs.","category":"page"},{"location":"library/public/#MimiqCircuitsBase","page":"Public","title":"MimiqCircuitsBase","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"MimiqCircuitsBase.jl\"]","category":"page"},{"location":"library/public/#General-functions","page":"Public","title":"General functions","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"abstract.jl\", \"docstrings.jl\", \"evaluate.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.isopalias","page":"Public","title":"MimiqCircuitsBase.isopalias","text":"isopalias(typ)\n\nChecks if a given operation type is an alias or not.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.isunitary","page":"Public","title":"MimiqCircuitsBase.isunitary","text":"isunitary(instruction)\nisunitary(operation)\n\nChecks if a given operation is unititary or not.\n\nSee also\n\niswrapper\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.getoperation","page":"Public","title":"MimiqCircuitsBase.getoperation","text":"getoperation(operation)\ngetoperation(instruction)\n\nReturns the quantum operation associated to the given instruction.\n\nSee also iswrapper.\n\nExamples\n\njulia> getoperation(Instruction(GateX(), 1))\nX\n\njulia> getoperation(GateSX())\nX\n\njulia> getoperation(GateCX())\nX\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.inverse","page":"Public","title":"MimiqCircuitsBase.inverse","text":"inverse(circuit)\ninverse(instruction)\ninverse(operation)\n\nInverse of the given circuit, instruction or operation.\n\nWhen the inverse is not a known operation, it will return an Inverse object that wraps the original operation.\n\ndetails: Details\nIt throws an error if the object is not invertible. Such for example, in the case of non unitary operations, or circuits containing Measure or Reset.\n\nSee also matrix, isunitary, power.\n\nExamples\n\njulia> inverse(GateRX(λ))\nRX(-λ)\n\njulia> inverse(GateCSX())\nC(SX†)\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.numbits","page":"Public","title":"MimiqCircuitsBase.numbits","text":"numbits(instruction)\nnumbits(circuit)\n\nNumber of classical bits on which the given operation or instruction is defined.\n\nSee also numqubits.\n\nExamples\n\njulia> numbits(GateCX())\n0\n\njulia> numbits(Measure())\n1\n\njulia> c = Circuit(); push!(c, Measure(), 1, 1); push!(c, Measure(),1,3)\n1-qubit circuit with 2 instructions:\n├── Measure @ q[1], c[1]\n└── Measure @ q[1], c[3]\n\njulia> numbits(c)\n3\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.numqubits","page":"Public","title":"MimiqCircuitsBase.numqubits","text":"numqubits(operation)\nnumqubits(instruction)\nnumqubits(circuit)\n\nNumber of qubits on which the given operation or instruction is defined.\n\nSee also numbits.\n\nExamples\n\njulia> numqubits(GateCX())\n2\n\njulia> numqubits(Measure())\n1\n\njulia> c = Circuit(); push!(c, GateX(), 1); push!(c, GateCX(),3,6)\n6-qubit circuit with 2 instructions:\n├── X @ q[1]\n└── CX @ q[3], q[6]\n\njulia> numqubits(c)\n6\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.opname","page":"Public","title":"MimiqCircuitsBase.opname","text":"opname(instruction)\nopname(operation)\n\nName of the underlying quantum operation in a human readable format.\n\nSee also numqubits, numbits.\n\nExamples\n\njulia> opname(GateX())\n\"X\"\n\njulia> opname(GateRX(π/2))\n\"RX\"\n\njulia> opname(Instruction(GateCX(),1,2))\n\"CX\"\n\njulia> opname(QFT(4))\n\"QFT\"\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.power","page":"Public","title":"MimiqCircuitsBase.power","text":"power(operation, exponent)\n\nElevate an operation to a given exponent.\n\nIt performs simplifications when possible otherwise wraps the operation in a Power object.\n\nSee also Power, inverse, Inverse.\n\nExamples\n\njulia> power(GateX(), 1//2)\nSX\n\njulia> power(GateX(), 0.5)\nX^0.5\n\njulia> GateX()^2\nID\n\njulia> GateCSX()^2\nCX\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.evaluate","page":"Public","title":"MimiqCircuitsBase.evaluate","text":"evaluate(object, dictionary)\n\nEvaluate all the parametric expression in object using the values specified in the given in the variable, value dictionary, returning a new object constructed on the evaluated parameters.\n\nExamples\n\nEvaluate a single parametric gate\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> g  = GateRX(θ)\nRX(θ)\n\njulia> evaluate(g, Dict(θ => 3π))\nRX(3π)\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Quantum-Circuits-and-Instructions","page":"Public","title":"Quantum Circuits and Instructions","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"instruction.jl\", \"circuit.jl\", \"circuit_extras.jl\", \"circuit_macro.jl\", \"draw.jl\", \"emplace.j\", \"emplace.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.AbstractInstruction","page":"Public","title":"MimiqCircuitsBase.AbstractInstruction","text":"AbstractInstruction\n\nAbstract super type for all the instrcutions.\n\nAn instruction applies one or more operations to a set of qubits and classical bits.\n\nMethods\n\ngetqubit, getqubits, getbits, getbit inverse, opname, numqubits, numbits\n\nSee also\n\nInstruction, Operation\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.Instruction","page":"Public","title":"MimiqCircuitsBase.Instruction","text":"Instruction(op, qtargets, ctargets) <: AbstractInstruction\n\nRepresentation of an operation applied to specific qubit and bit targets.\n\nExample\n\njulia> Instruction(GateX(), (1,), ())\nX @ q[1]\n\njulia> Instruction(GateCX(), (1,2), ())\nCX @ q[1], q[2]\n\njulia> Instruction(Measure(), (3,), (3,))\nMeasure @ q[3], c[3]\n\n\nSee also\n\nAbstractInstruction, Operation\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.Instruction-Union{Tuple{L}, Tuple{M}, Tuple{N}, Tuple{Operation{N, M}, Vararg{Integer, L}}} where {N, M, L}","page":"Public","title":"MimiqCircuitsBase.Instruction","text":"Instruction(op, targets...)\n\nConstructors an instruction from an operation and a list of targets.\n\nBy convention, if op is an N-qubit and M-bit operations, then the first N targets are used as qubits and the last M as bits.\n\nExamples\n\njulia> Instruction(GateX(), 1)\nX @ q[1]\n\njulia> Instruction(GateCX(), 1,2)\nCX @ q[1], q[2]\n\njulia> Instruction(Measure(), 3, 3)\nMeasure @ q[3], c[3]\n\n\n\n\n\n\n","category":"method"},{"location":"library/public/#MimiqCircuitsBase.getbit","page":"Public","title":"MimiqCircuitsBase.getbit","text":"getbit(instruction, i)\n\ni-th target classical bit of an instruction.\n\nExamples\n\njulia> inst = Instruction(Measure(), 1, 3)\nMeasure @ q[1], c[3]\n\njulia> getbit(inst, 1)\n3\n\n\nSee also\n\ngetbits, getqubit, getqubits,\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.getbits","page":"Public","title":"MimiqCircuitsBase.getbits","text":"getbits(instruction)\n\nTuple of the classical bits which the instruction is applied to.\n\nExamples\n\njulia> inst = Instruction(Measure(), 1, 3)\nMeasure @ q[1], c[3]\n\njulia> getbits(inst)\n(3,)\n\n\nSee also\n\ngetbit, getqubits, getqubit\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.getqubit","page":"Public","title":"MimiqCircuitsBase.getqubit","text":"getqubit(instruction, i)\n\ni-th target qubit of an instruction.\n\nExamples\n\njulia> inst = Instruction(GateCX(), 1, 3)\nCX @ q[1], q[3]\n\njulia> getqubit(inst, 2)\n3\n\n\nSee also\n\ngetqubits, getbit, getbits\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.getqubits","page":"Public","title":"MimiqCircuitsBase.getqubits","text":"getqubits(instruction)\n\nTuple of quantum bits which the instruction is applied to.\n\njulia> inst = Instruction(GateCX(), 1, 3)\nCX @ q[1], q[3]\n\njulia> getqubits(inst)\n(1, 3)\n\n\nSee also\n\ngetqubit, getbits, getbit\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.Circuit","page":"Public","title":"MimiqCircuitsBase.Circuit","text":"Circuit([instructions])\n\nRepresentation of a quantum circuit as a vector of instructions applied to the qubits.\n\nThe circuit can be initialized with an optional vector of instructions.\n\nSee OPERATIONS, GATES, or GENERALIZED for the list of operations to add to circuits.\n\nExamples\n\nOperation can be added one by one to a circuit with the push!(circuit, operation, targets...) function\n\njulia> c = Circuit()\nempty circuit\n\n\njulia> push!(c, GateH(), 1)\n1-qubit circuit with 1 instructions:\n└── H @ q[1]\n\njulia> push!(c, GateCX(), 1, 2)\n2-qubit circuit with 2 instructions:\n├── H @ q[1]\n└── CX @ q[1], q[2]\n\njulia> push!(c, GateRX(π / 4), 1)\n2-qubit circuit with 3 instructions:\n├── H @ q[1]\n├── CX @ q[1], q[2]\n└── RX(π/4) @ q[1]\n\njulia> push!(c, Barrier(2), 1, 3)\n3-qubit circuit with 4 instructions:\n├── H @ q[1]\n├── CX @ q[1], q[2]\n├── RX(π/4) @ q[1]\n└── Barrier @ q[1,3]\n\njulia> push!(c, Measure(), 1, 1)\n3-qubit circuit with 5 instructions:\n├── H @ q[1]\n├── CX @ q[1], q[2]\n├── RX(π/4) @ q[1]\n├── Barrier @ q[1,3]\n└── Measure @ q[1], c[1]\n\n\nTargets are not restricted to be single values, but also vectors. In this case a single push! will add multiple operations.\n\njulia> push!(Circuit(), GateCCX(), 1, 2:4, 4:10)\n6-qubit circuit with 3 instructions:\n├── C₂X @ q[1:2], q[4]\n├── C₂X @ q[1,3], q[5]\n└── C₂X @ q[1,4], q[6]\n\nis equivalent to\n\nfor (i, j) in zip(2:4, 4:10)\n    push!(c, GateCX(), 1, i)\nend\n\nNotice how the range 4:10 is not fully used, since 2:4 is shorter.\n\nDisplay\n\nTo display a a LaTeX representation of the circuit, we can just use Quantikz.jl\n\nusing Quantikz\nc = Circuit()\n...\ndisplaycircuit(c)\n\nor\n\nsavecircuit(c, \"circuit.pdf\")\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.depth-Tuple{Circuit}","page":"Public","title":"MimiqCircuitsBase.depth","text":"depth(circuit)\n\nCompute the depth of a quantum circuit.\n\nThe depth of a quantum circuit is a metric computing the maximum time (in units of quantum gates application) between the input and output of the circuit.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#MimiqCircuitsBase.draw","page":"Public","title":"MimiqCircuitsBase.draw","text":"draw(circuit)\n\nDraw an ascii representation of a circuit.\n\nNOTE it automatically detects the screen width and will split the circuit if it is too wide.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.emplace!","page":"Public","title":"MimiqCircuitsBase.emplace!","text":"emplace!(circuit, operation, registers...)\n\nEmplace an operation at the end of a circuit and applies it to the given registers.\n\njulia> emplace!(Circuit(), control(3, GateSWAP()), [1,2,3], [4,5])\n5-qubit circuit with 1 instructions:\n└── C₃SWAP @ q[1:3], q[4:5]\n\njulia> QFT()\nlazy QFT(?)\n\njulia> emplace!(Circuit(), QFT(), [1,2,3])\n3-qubit circuit with 1 instructions:\n└── QFT @ q[1:3]\n\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Operations","page":"Public","title":"Operations","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"operation.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.Operation","page":"Public","title":"MimiqCircuitsBase.Operation","text":"Operation{N,M}\n\nAbstract supertype for all the quantum operations acting on N qubits and M classical bits.\n\nMethods\n\niswrapper, isunitary, numbits, numqubits, opname\n\nSee also\n\nAbstractGate\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.cregsizes-Tuple{T} where T","page":"Public","title":"MimiqCircuitsBase.cregsizes","text":"cregsizes(operation)\ncregsizes(operationtype)\n\nLength of the classicalregisters the given operation acts on.\n\nSee also\n\nqregsizes, numqubits, numbits\n\n\n\n\n\n","category":"method"},{"location":"library/public/#MimiqCircuitsBase.getparam","page":"Public","title":"MimiqCircuitsBase.getparam","text":"getparam(operation, name)\n\nValue of the corresponding parameter in the given parametric operation.\n\nExamples\n\ngetparam(GateRX(π/8), :θ)\n\nSee also\n\nparnames, numparams, getparams\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.getparams","page":"Public","title":"MimiqCircuitsBase.getparams","text":"getparams(operation)\n\nValue of the parameters in the given parametric operation.\n\nExamples\n\ngetparam(GateU(π/8, 3.1, sqrt(2)))\n\nSee also\n\nparnames, numparams, getparam\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.hilbertspacedim","page":"Public","title":"MimiqCircuitsBase.hilbertspacedim","text":"hilbertspacedim(operation)\nhilbertspacedim(operationtype)\nhilbertspacedim(N::Integer)\n\nHilbert space dimension for the given operation. For an operation actiing on N qubits, it is 2^N.\n\nExamples\n\nhilbertspacedim(Operation{2, 1})\nhilbertspacedim(GateH)\nhilbertspacedim(GateH())\nhilbertspacedim(GateRX)\nhilbertspacedim(GateCX)\nhilbertspacedim(4)\n\nSee also\n\nnumqubits, numbits, Operation, AbstractGate\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.iswrapper","page":"Public","title":"MimiqCircuitsBase.iswrapper","text":"iswrapper(operation)\niswrapper(operationtype)\n\nChecks if a given operation is a wrapper or not.\n\nExamples\n\niswrapper(Control)\niswrapper(GateX)\niswrapper(GateSX) # SX is defined as Power(1//2, GateX())\niswrapper(GateCX) # CX is defined as Control(1, GateX())\n\nSee also\n\nisunitary, getoperation\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.numparams","page":"Public","title":"MimiqCircuitsBase.numparams","text":"numparams(operation)\nnumparams(operationtype)\n\nNumber of parameters for the given parametric operation. Zero for non parametric operations.\n\nBy default it returns the number of fields of the operations.\n\nExamples\n\njulia> numparams(GateH)\n0\n\njulia> numparams(GateU)\n4\n\njulia> numparams(GateRX)\n1\n\njulia> numparams(Measure)\n0\n\n\nSee also\n\nparnames, getparam\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.parnames","page":"Public","title":"MimiqCircuitsBase.parnames","text":"parnames(operation)\nparnames(operationtype)\n\nName of the parameters allowed for the given operation.\n\nBy default it returns the fieldnames of the operation type.\n\nExamples\n\nparnames(GateH)\nparnames(GateRX)\nparnames(GateCRX)\nparnames(Measure)\n\nSee also\n\nnumparams, getparam\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.qregsizes-Tuple{T} where T","page":"Public","title":"MimiqCircuitsBase.qregsizes","text":"qregsizes(operation)\nqregsizes(operationtype)\n\nLength of the quantum registers the given operation acts on.\n\ndetails: Details\nSome operations, such as adders or multipliers, acts on different groups of qubits (quantum registers).\n\nExamples\n\njulia> qregsizes(GateRX(0.1))\n(1,)\n\njulia> qregsizes(GateCRX(0.1))\n(1, 1)\n\njulia> qregsizes(QFT(4))\n(4,)\n\nSee also\n\ncregsizes, numqubits, numbits\n\n\n\n\n\n","category":"method"},{"location":"library/public/#Decompositions","page":"Public","title":"Decompositions","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"decompose.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.decompose","page":"Public","title":"MimiqCircuitsBase.decompose","text":"decompose(operation)\ndecompose(circuit)\n\nDecompose the given operation or circuit into a circuit of more elementary gates. If applied recursively, it will decompose the given object into a circuit of GateCX and GateU gates.\n\nSee also decompose!.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.decompose!","page":"Public","title":"MimiqCircuitsBase.decompose!","text":"decompose!(circuit, operation[, qtargets, ctargets])\n\nIn place version of decompose.\n\nIt decomposes the given object, appending all the resulting operations to the given circuit. The optional qtargets and ctargets arguments can be used to map the qubits and classical bits of the decomposed operation to the ones of the target circuit.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Gates","page":"Public","title":"Gates","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"gate.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.AbstractGate","page":"Public","title":"MimiqCircuitsBase.AbstractGate","text":"AbstractGate{N} <: Operation{N,0}\n\nSupertype for all the N-qubit unitary gates.\n\nSee also hilbertspacedim, inverse, isunitary, matrix, numqubits, opname\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.matrix","page":"Public","title":"MimiqCircuitsBase.matrix","text":"matrix(gate)\n\nMatrix associated to the given gate.\n\nnote: Note\nif the gate is parametric, the matrix elements are is wrapped in a Symbolics.Num object. To manipulate expressions use the Symbolics package.\n\nExamples\n\nMatrix of a simple gate\n\njulia> matrix(GateH())\n2×2 Matrix{Float64}:\n 0.707107   0.707107\n 0.707107  -0.707107\n\njulia> matrix(GateRX(π/2))\n2×2 Matrix{ComplexF64}:\n 0.707107+0.0im            0.0-0.707107im\n      0.0-0.707107im  0.707107+0.0im\n\njulia> matrix(GateCX())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  1.0\n 0.0  0.0  1.0  0.0\n\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Wrappers","page":"Public","title":"Wrappers","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\n    \"operations/control.jl\",\n    \"operations/inverse.jl\",\n    \"operations/power.jl\",\n    \"operations/parallel.jl\",\n    \"operations/ifstatement.jl\",\n]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.Control","page":"Public","title":"MimiqCircuitsBase.Control","text":"Control(numcontrols, gate) <: AbstractGate\n\nControl modifier, similar to OpenQASM 3.0 ctrl @ gate. It wraps a given gate and adds a number of controls to it.\n\nnote: Note\nBy default the first numcontrols qubits are used as controls, and the remaining ones as targets for the wrapped gate.\n\nSee also Power, Inverse, getoperation, iswrapper, numcontrols, numtargets.\n\nExamples\n\njulia> Control(1, GateX())\nCX\n\njulia> Control(3, GateH())\nC₃H\n\njulia> Control(24, GateSWAP())\nC₂₄SWAP\n\nDecomposition\n\nThe default decomposition of a Control gate is build by applying recursively Lemma 7.3 of [1]. This requires to decompose multicontrolled-X gates, which is done recursively, according to Lemma 7.2 and 7.3 of [1].\n\nHere we give a simple example of a decomposition of a C_5T gate.\n\njulia> decompose(Control(3,GateT()))\n4-qubit circuit with 9 instructions:\n├── C(Z^(1//8)) @ q[3], q[4]\n├── C₂X @ q[1:2], q[3]\n├── C((Z^(1//8))†) @ q[3], q[4]\n├── C₂X @ q[1:2], q[3]\n├── C(Z^(1//16)) @ q[2], q[4]\n├── CX @ q[1], q[2]\n├── C((Z^(1//16))†) @ q[2], q[4]\n├── CX @ q[1], q[2]\n└── C(Z^(1//16)) @ q[1], q[4]\n\ndetail: Detail\nSome decompositions have been overrided with optimized versions, to reduce the number of gates used.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.Control-Union{Tuple{Operation{N, 0}}, Tuple{N}} where N","page":"Public","title":"MimiqCircuitsBase.Control","text":"Control(gate)\n\nBuild a controlled gate with 1 control.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#MimiqCircuitsBase.control","page":"Public","title":"MimiqCircuitsBase.control","text":"control([numcontrols], gate)\n\nBuild a multicontrolled gate.\n\nThe number of controls can be omitted to be lazily evaluated later.\n\nExamples\n\nStandard examples, with all the arguments spefcified.\n\njulia> control(1, GateX())\nCX\n\njulia> control(2, GateX())\nC₂X\n\njulia> control(3, GateCH())\nC₄H\n\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.numcontrols","page":"Public","title":"MimiqCircuitsBase.numcontrols","text":"numcontrols(control)\n\nNumber of controls of a given multicontrolled gate.\n\nSee also\n\nControl, numtargets, numqubits\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.numtargets","page":"Public","title":"MimiqCircuitsBase.numtargets","text":"numtargets(control)\n\nGet the number of targets of a given multicontrolled gate.\n\nExamples\n\nnumcontro\n\nSee also\n\nControl, numtargets, numqubits\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.Inverse","page":"Public","title":"MimiqCircuitsBase.Inverse","text":"Inverse(operation)\n\nInverse of the wrapped quantum operation.\n\nThe inversion is not performed right away, but only when the circuit is cached or executed.\n\nSome simplifications are already carried out at construction, for example, Inverse(Inverse(op)) is simplified as Inverse(op).\n\nwarn: Warn\nUsers should not use directly Inverse but the inverse method, which performs already all the simplifications.\n\nSee also inverse, iswrapper, Control, Power.\n\nExamples\n\njulia> Inverse(GateX())\nX†\n\njulia> Inverse(GateH())\nH†\n\njulia> Inverse(GateSX())\nSX†\n\njulia> Inverse(GateCSX())\n(CSX)†\n\njulia> Inverse(QFT(4))\nQFT†\n\n\nDecomposition\n\nDecomposition of the inverse is carring out by inverting the decomposition of the wrapped operation.\n\njulia> decompose(Inverse(GateCSX()))\n2-qubit circuit with 3 instructions:\n├── H @ q[2]\n├── CU1(-1π/2) @ q[1], q[2]\n└── H @ q[2]\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.Power","page":"Public","title":"MimiqCircuitsBase.Power","text":"Power(pow, operation)\n\nWraps an operation and raises it to the given power.\n\nSome simplifications are already carried out at construction, for example Power(pow2, Power(pow1, op)) is simplified as Power(pow1 * pow2, op).\n\nnote: Note\nFor allowing simplifications, always prefer rational powers, such as 1//2 over floating point ones, such as 0.5.\n\nwarn: Warn\nUsers should not use directly Power but the power method, which performs already all the simplifications. Gates should implement the _power method instead.\n\nSee also power, Inverse , inverse.\n\nExample\n\njulia> Power(GateZ(), 1//2)\nS\n\njulia> Power(GateZ(), 2)\nZ^2\n\njulia> Power(GateCH(), 1//2)\n(CH)^(1//2)\n\njulia> Power(GateCX(), 1//2)\n(CX)^(1//2)\n\nDecomposition\n\nIn the general case, if a decomposition is not known for a given operation and power, the Power operation is not decomposed.\n\nIf the exponent is an integer, then the gate is decomposed by repeating it.\n\njulia> decompose(Power(GateH(), 2))\n1-qubit circuit with 2 instructions:\n├── H @ q[1]\n└── H @ q[1]\n\njulia> decompose(Power(GateH(), 1//2))\n1-qubit circuit with 1 instructions:\n└── U(π/2, 0, π)^(1//2) @ q[1]\n\njulia> decompose(Power(GateX(), 1//2)) # same as decomposing GateSX\n1-qubit circuit with 4 instructions:\n├── S† @ q[1]\n├── H @ q[1]\n├── S† @ q[1]\n└── U(0, 0, 0, π/4) @ q[1]\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.Parallel","page":"Public","title":"MimiqCircuitsBase.Parallel","text":"Parallel(repeats, operation)\n\nWrapper that applies the same operation on multiple qubits.\n\nIf the operation is a N-qubit operation, then the resulting operation is applied over N * repeats qubits.\n\nExamples\n\njulia> Parallel(5, GateX())\nParallel(5, X)\n\njulia> Parallel(3, GateRX(λ))\nParallel(3, RX(λ))\n\njulia> Parallel(2, Parallel(3, GateX()))\nParallel(2, Parallel(3, X))\n\n\nDecomposition\n\nA parallel is decomposed into a sequence of operation, one for each group of qubits.\n\njulia> decompose(Parallel(2, GateX()))\n2-qubit circuit with 2 instructions:\n├── X @ q[1]\n└── X @ q[2]\n\njulia> decompose(Parallel(3, GateSWAP()))\n6-qubit circuit with 3 instructions:\n├── SWAP @ q[1:2]\n├── SWAP @ q[3:4]\n└── SWAP @ q[5:6]\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.numrepeats","page":"Public","title":"MimiqCircuitsBase.numrepeats","text":"numrepeats(paralleloperation)\n\nGet the number of repetitions of a parallel operation.\n\nSee also Parallel.\n\nExamples\n\njulia> numrepeats(Parallel(5, GateX()))\n5\n\njulia> numrepeats(Parallel(3, GateSWAP()))\n3\n\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.parallel","page":"Public","title":"MimiqCircuitsBase.parallel","text":"parallel(repeats, operation)\n\nBuild a parallel operation.\n\nThe resulting operation is applied over N * repeats qubits.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.IfStatement","page":"Public","title":"MimiqCircuitsBase.IfStatement","text":"IfStatement(numbits, op, num)\n\nApplies the wrapper operation, only if the classical register is equal to num.\n\nwarn: Warn\nCurrentely not supported by the state vector and MPS simulators.\n\nExamples\n\npush!(IfStatement(GateX(), 10), 1,1,2,3,4,5) is the equivalent of OpenQASM 2.0\n\ncreg c[5];\nif (c==10) x q[0];\n\njulia> IfStatement(10, GateX(), 999)\nIF(c == 999) X\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Global-phase","page":"Public","title":"Global phase","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\n    \"operations/gphase.jl\"\n]","category":"page"},{"location":"library/public/#Standard-Gates","page":"Public","title":"Standard Gates","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\n    \"operations/gates/standard/u.jl\",\n    \"operations/gates/standard/phase.jl\",\n    \"operations/gates/standard/deprecated.jl\",\n    \"operations/gates/standard/pauli.jl\",\n    \"operations/gates/standard/hadamard.jl\",\n    \"operations/gates/standard/id.jl\",\n    \"operations/gates/standard/s.jl\",\n    \"operations/gates/standard/t.jl\",\n    \"operations/gates/standard/sx.jl\",\n    \"operations/gates/standard/rotations.jl\",\n    \"operations/gates/standard/swap.jl\",\n    \"operations/gates/standard/iswap.jl\",\n    \"operations/gates/standard/cpauli.jl\",\n    \"operations/gates/standard/chadamard.jl\",\n    \"operations/gates/standard/cs.jl\",\n    \"operations/gates/standard/csx.jl\",\n    \"operations/gates/standard/cu.jl\",\n    \"operations/gates/standard/cphase.jl\",\n    \"operations/gates/standard/crotations.jl\",\n    \"operations/gates/standard/ecr.jl\",\n    \"operations/gates/standard/dcx.jl\",\n    \"operations/gates/standard/interactions.jl\",\n    \"operations/gates/standard/cswap.jl\",\n    \"operations/gates/standard/cnx.jl\",\n    \"operations/gates/standard/cnp.jl\",\n]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.GateU","page":"Public","title":"MimiqCircuitsBase.GateU","text":"GateU(θ, ϕ, λ[, γ = 0])\n\nSingle qubit generic unitary gate U(theta phi lambda gamma = 0), where theta, phi, and lambda are the Euler angles specified in radians, and gamma is a global phase.\n\nSee also GateU3, GateP, GateU2, GateU1\n\nMatrix representation\n\noperatornameU(theta phi lambda gamma = 0) =\nmathrme^igamma\nbeginpmatrix\n    cosleft(fractheta2right)  -mathrme^ilambdasinleft(fractheta2right) \n    mathrme^iphisinleft(fractheta2right)  mathrme^i(phi+lambda)cosleft(fractheta2right)\nendpmatrix\n\nExamples\n\njulia> @variables θ ϕ λ\n3-element Vector{Symbolics.Num}:\n θ\n ϕ\n λ\n\njulia> GateU(θ, ϕ, λ)\nU(θ, ϕ, λ)\n\njulia> matrix(GateU(2.023, 0.5, 0.1))\n2×2 Matrix{ComplexF64}:\n  0.53059+0.0im       -0.843394-0.0846217im\n 0.743864+0.406375im   0.437915+0.299594im\n\njulia> c = push!(Circuit(), GateU(θ, ϕ, λ), 1)\n1-qubit circuit with 1 instructions:\n└── U(θ, ϕ, λ) @ q[1]\n\njulia> push!(c, GateU(π/8, π/2, π/4), 2)\n2-qubit circuit with 2 instructions:\n├── U(θ, ϕ, λ) @ q[1]\n└── U(π/8, π/2, π/4) @ q[2]\n\njulia> power(GateU(θ, ϕ, λ), 2), inverse(GateU(θ, ϕ, λ))\n(U(θ, ϕ, λ)^2, U(-θ, -λ, -ϕ))\n\n\nDecomposition\n\nSince U gate, is the most general single qubit unitary matrix, all other matrices are defined from it.\n\njulia> decompose(GateU(θ, λ, ϕ))\n1-qubit circuit with 1 instructions:\n└── U(θ, λ, ϕ) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateP","page":"Public","title":"MimiqCircuitsBase.GateP","text":"GateP(λ)\n\nSingle qubit Phase gate.\n\nλ is the phase angle in radians.\n\nMatrix representation\n\noperatornameP(lambda) =\noperatornameU(0 0 lambda) =\nbeginpmatrix\n    1  0 \n    0  mathrme^ilambda\nendpmatrix\n\nExamples\n\njulia> @variables λ\n1-element Vector{Symbolics.Num}:\n λ\n\njulia> GateP(λ)\nP(λ)\n\njulia> matrix(GateP(1.989))\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im       0.0+0.0im\n 0.0+0.0im  -0.40612+0.91382im\n\njulia> c = push!(Circuit(), GateP(λ), 1)\n1-qubit circuit with 1 instructions:\n└── P(λ) @ q[1]\n\njulia> push!(c, GateP(π/2), 2)\n2-qubit circuit with 2 instructions:\n├── P(λ) @ q[1]\n└── P(π/2) @ q[2]\n\n\nDecomposition\n\njulia> decompose(GateP(λ))\n1-qubit circuit with 1 instructions:\n└── U(0, 0, λ) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateU1","page":"Public","title":"MimiqCircuitsBase.GateU1","text":"GateU1(λ)\n\nSingle qubit rotation \\operatorname{U1}(\\lambda) about the Z axis.\n\nEquivalent to GateP.\n\nMatrix representation\n\noperatornameU1(lambda) =\nbeginpmatrix\n    1  0 \n    0  e^ilambda\nendpmatrix\n\nExamples\n\njulia> @variables λ\n1-element Vector{Symbolics.Num}:\n λ\n\njulia> GateU1(λ)\nU1(λ)\n\njulia> matrix(GateU1(0.519))\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.868316+0.496012im\n\njulia> c = push!(Circuit(), GateU1(λ), 1)\n1-qubit circuit with 1 instructions:\n└── U1(λ) @ q[1]\n\njulia> push!(c, GateU1(π/2), 2)\n2-qubit circuit with 2 instructions:\n├── U1(λ) @ q[1]\n└── U1(π/2) @ q[2]\n\njulia> power(GateU1(λ), 2), inverse(GateU1(λ))\n(U1(λ)^2, U1(-λ))\n\n\nDecomposition\n\njulia> decompose(GateU1(λ))\n1-qubit circuit with 1 instructions:\n└── U(0, 0, λ) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateU2","page":"Public","title":"MimiqCircuitsBase.GateU2","text":"GateU2(ϕ, λ)\n\nSingle qubit rotation \\operatorname{U2}(\\phi, \\lambda) about the X+Z axis.\n\nMatrix representation\n\noperatornameU2(philambda) = frac1sqrt2e^-(phi+lambda)2beginpmatrix\n1  -e^ilambda \ne^iphi  e^i(phi+lambda)\nendpmatrix\n\nExamples\n\njulia> @variables ϕ λ\n2-element Vector{Symbolics.Num}:\n ϕ\n λ\n\njulia> GateU2(ϕ, λ)\nU2(ϕ, λ)\n\njulia> matrix(GateU2(2.023, 0.5))\n2×2 Matrix{ComplexF64}:\n  0.707107+0.0im       -0.620545-0.339005im\n -0.308969+0.636033im  -0.576077+0.410044im\n\njulia> c = push!(Circuit(), GateU2(ϕ, λ), 1)\n1-qubit circuit with 1 instructions:\n└── U2(ϕ, λ) @ q[1]\n\njulia> push!(c, GateU2(π/2, π/4), 2)\n2-qubit circuit with 2 instructions:\n├── U2(ϕ, λ) @ q[1]\n└── U2(π/2, π/4) @ q[2]\n\njulia> power(GateU2(ϕ, λ), 2), inverse(GateU2(ϕ, λ))\n(U2(ϕ, λ)^2, U2(-3.141592653589793 - λ, π - ϕ))\n\n\nDecomposition\n\njulia> decompose(GateU2(ϕ, λ))\n1-qubit circuit with 1 instructions:\n└── U3(π/2, ϕ, λ) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateU3","page":"Public","title":"MimiqCircuitsBase.GateU3","text":"GateU3(θ, ϕ, λ)\n\nSingle qubit generic unitary gate U3(\\theta, \\phi, \\lambda).\n\nThis gate is equivalent to the generic unitary gate GateU, differing from it only by a global phase of fracphi + lambda + theta2.\n\nMatrix representation\n\noperatornameU3(thetaphilambda) =\nbeginpmatrix\n    cosleft(fractheta2right)  -e^ilambdasinleft(fractheta2right) \n    mathrme^iphisinleft(fractheta2right)  mathrme^i(phi+lambda)cosleft(fractheta2right)\nendpmatrix\n\nExamples\n\njulia> @variables θ ϕ λ\n3-element Vector{Symbolics.Num}:\n θ\n ϕ\n λ\n\njulia> GateU3(θ, ϕ, λ)\nU3(θ, ϕ, λ)\n\njulia> matrix(GateU3(2.023, 0.5, 0.1))\n2×2 Matrix{ComplexF64}:\n  0.53059+0.0im       -0.843394-0.0846217im\n 0.743864+0.406375im   0.437915+0.299594im\n\njulia> c = push!(Circuit(), GateU3(θ, ϕ, λ), 1)\n1-qubit circuit with 1 instructions:\n└── U3(θ, ϕ, λ) @ q[1]\n\njulia> push!(c, GateU3(π/8, π/2, π/4), 2)\n2-qubit circuit with 2 instructions:\n├── U3(θ, ϕ, λ) @ q[1]\n└── U3(π/8, π/2, π/4) @ q[2]\n\njulia> power(GateU3(θ, ϕ, λ), 2), inverse(GateU3(θ, ϕ, λ))\n(U3(θ, ϕ, λ)^2, U3(-θ, -λ, -ϕ))\n\n\nDecomposition\n\njulia> decompose(GateU3(θ, ϕ, λ))\n1-qubit circuit with 1 instructions:\n└── U(θ, ϕ, λ) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateX","page":"Public","title":"MimiqCircuitsBase.GateX","text":"GateX()\n\nSingle qubit Pauli-X gate.\n\nMatrix representation\n\noperatornameX =\nbeginpmatrix\n    0  1 \n    1  0\nendpmatrix\n\nExamples\n\njulia> GateX()\nX\n\njulia> matrix(GateX())\n2×2 Matrix{Int64}:\n 0  1\n 1  0\n\njulia> c = push!(Circuit(), GateX(), 1)\n1-qubit circuit with 1 instructions:\n└── X @ q[1]\n\njulia> push!(c, GateX, 2)\n2-qubit circuit with 2 instructions:\n├── X @ q[1]\n└── X @ q[2]\n\n\nDecomposition\n\njulia> decompose(GateX())\n1-qubit circuit with 1 instructions:\n└── U(π, 0, π) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateY","page":"Public","title":"MimiqCircuitsBase.GateY","text":"GateY()\n\nSingle qubit Pauli-Y gate.\n\nMatrix representation\n\noperatornameY =\nbeginpmatrix\n    0  -i \n    i  0\nendpmatrix\n\nExamples\n\njulia> GateY()\nY\n\njulia> matrix(GateY())\n2×2 Matrix{ComplexF64}:\n 0.0+0.0im  0.0-1.0im\n 0.0+1.0im  0.0+0.0im\n\njulia> c = push!(Circuit(), GateY(), 1)\n1-qubit circuit with 1 instructions:\n└── Y @ q[1]\n\njulia> push!(c, GateY, 2)\n2-qubit circuit with 2 instructions:\n├── Y @ q[1]\n└── Y @ q[2]\n\n\nDecomposition\n\njulia> decompose(GateY())\n1-qubit circuit with 1 instructions:\n└── U(π, π/2, π/2) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateZ","page":"Public","title":"MimiqCircuitsBase.GateZ","text":"GateZ()\n\nSingle qubit Pauli-Z gate.\n\nMatrix representation\n\noperatornameZ =\nbeginpmatrix\n    1  0 \n    0  -1\nendpmatrix\n\nExamples\n\njulia> GateZ()\nZ\n\njulia> matrix(GateZ())\n2×2 Matrix{Float64}:\n 1.0   0.0\n 0.0  -1.0\n\njulia> c = push!(Circuit(), GateZ(), 1)\n1-qubit circuit with 1 instructions:\n└── Z @ q[1]\n\njulia> push!(c, GateZ, 2)\n2-qubit circuit with 2 instructions:\n├── Z @ q[1]\n└── Z @ q[2]\n\n\nDecomposition\n\njulia> decompose(GateZ())\n1-qubit circuit with 1 instructions:\n└── P(π) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateH","page":"Public","title":"MimiqCircuitsBase.GateH","text":"GateH()\n\nSingle qubit Hadamard gate.\n\nMatrix representation\n\noperatorname H =\nfrac1sqrt2\nbeginpmatrix\n    1  1 \n    1  -1\nendpmatrix\n\nExamples\n\njulia> GateH()\nH\n\njulia> matrix(GateH())\n2×2 Matrix{Float64}:\n 0.707107   0.707107\n 0.707107  -0.707107\n\njulia> c = push!(Circuit(), GateH(), 1)\n1-qubit circuit with 1 instructions:\n└── H @ q[1]\n\njulia> push!(c, GateH, 1)\n1-qubit circuit with 2 instructions:\n├── H @ q[1]\n└── H @ q[1]\n\njulia> power(GateH(), 2), inverse(GateH())\n(H^2, H)\n\n\nDecomposition\n\njulia> decompose(GateH())\n1-qubit circuit with 1 instructions:\n└── U(π/2, 0, π) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateID","page":"Public","title":"MimiqCircuitsBase.GateID","text":"GateID()\n\nSingle qubit identity gate\n\nMatrix representation\n\noperatornameI =\nbeginpmatrix\n    1  0 \n    0  1\nendpmatrix\n\nExamples\n\njulia> GateID()\nID\n\njulia> matrix(GateID())\n2×2 Matrix{Float64}:\n 1.0  -0.0\n 0.0   1.0\n\njulia> c = push!(Circuit(), GateID(), 1)\n1-qubit circuit with 1 instructions:\n└── ID @ q[1]\n\njulia> power(GateID(), 2), inverse(GateID())\n(ID, ID)\n\n\nDecomposition\n\njulia> decompose(GateID())\n1-qubit circuit with 1 instructions:\n└── U(0, 0, 0) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateS","page":"Public","title":"MimiqCircuitsBase.GateS","text":"GateS()\n\nSingle qubit S gate (or phase gate). It is defined as the square root of the Z gate.\n\nSee also GateSDG, GateZ, Power\n\nMatrix representation\n\noperatornameS =\nsqrtoperatornameZ =\nbeginpmatrix\n    1  0 \n    0  i\nendpmatrix\n\nExamples\n\njulia> GateS()\nS\n\njulia> matrix(GateS())\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+1.0im\n\njulia> c = push!(Circuit(), GateS(), 1)\n1-qubit circuit with 1 instructions:\n└── S @ q[1]\n\njulia> push!(c, GateS, 2)\n2-qubit circuit with 2 instructions:\n├── S @ q[1]\n└── S @ q[2]\n\njulia> power(GateS(), 2), inverse(GateS())\n(Z, S†)\n\n\nDecomposition\n\njulia> decompose(GateS())\n1-qubit circuit with 1 instructions:\n└── U(0, 0, π/2) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateSDG","page":"Public","title":"MimiqCircuitsBase.GateSDG","text":"GateSDG()\n\nSingle qubit S-dagger gate (conjugate transpose of the S gate).\n\nSee also GateS, GateZ, Power, Inverse\n\nMatrix representation\n\noperatorname S^dagger =\nbeginpmatrix\n    1  0 \n    0  -i\nendpmatrix\n\nExamples\n\njulia> GateSDG()\nS†\n\njulia> matrix(GateSDG())\n2×2 adjoint(::Matrix{ComplexF64}) with eltype ComplexF64:\n 1.0-0.0im  0.0-0.0im\n 0.0-0.0im  0.0-1.0im\n\njulia> c = push!(Circuit(), GateSDG(), 1)\n1-qubit circuit with 1 instructions:\n└── S† @ q[1]\n\njulia> push!(c, GateSDG, 2)\n2-qubit circuit with 2 instructions:\n├── S† @ q[1]\n└── S† @ q[2]\n\njulia> power(GateSDG(), 2), inverse(GateSDG())\n((S†)^2, S)\n\n\nDecomposition\n\njulia> decompose(GateSDG())\n1-qubit circuit with 1 instructions:\n└── U(0, 0, -1π/2) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateT","page":"Public","title":"MimiqCircuitsBase.GateT","text":"GateT()\n\nSingle qubit T gate. It is defined as the square root of the S gate, Z^frac14.\n\nSee also GateTDG, GateS, GateZ, Power\n\nMatrix representation\n\noperatornameZ =\noperatornameZ^frac14 =\nbeginpmatrix\n    1  0 \n    0  exp(fracipi4)\nendpmatrix\n\nExamples\n\njulia> GateT()\nT\n\njulia> matrix(GateT())\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.707107+0.707107im\n\njulia> c = push!(Circuit(), GateT(), 1)\n1-qubit circuit with 1 instructions:\n└── T @ q[1]\n\njulia> push!(c, GateT, 2)\n2-qubit circuit with 2 instructions:\n├── T @ q[1]\n└── T @ q[2]\n\njulia> power(GateT(), 2), power(GateT(), 4), inverse(GateT())\n(S, Z, T†)\n\n\nDecomposition\n\njulia> decompose(GateT())\n1-qubit circuit with 1 instructions:\n└── U(0, 0, π/4) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateTDG","page":"Public","title":"MimiqCircuitsBase.GateTDG","text":"GateTDG()\n\nSingle qubit T-dagger gate (conjugate transpose of the T gate).\n\nSee also GateT\n\nMatrix Representation\n\noperatorname T^dagger =\nbeginpmatrix\n    1  0 \n    0  exp(frac-ipi4)\nendpmatrix\n\nExamples\n\njulia> GateTDG()\nT†\n\njulia> matrix(GateTDG())\n2×2 adjoint(::Matrix{ComplexF64}) with eltype ComplexF64:\n 1.0-0.0im       0.0-0.0im\n 0.0-0.0im  0.707107-0.707107im\n\njulia> c = push!(Circuit(), GateTDG(), 1)\n1-qubit circuit with 1 instructions:\n└── T† @ q[1]\n\njulia> push!(c, GateTDG, 2)\n2-qubit circuit with 2 instructions:\n├── T† @ q[1]\n└── T† @ q[2]\n\njulia> power(GateTDG(), 2), power(GateTDG(), 4), inverse(GateTDG())\n((T†)^2, (T†)^4, T)\n\n\nDecomposition\n\njulia> decompose(GateTDG())\n1-qubit circuit with 1 instructions:\n└── U(0, 0, -1π/4) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateSX","page":"Public","title":"MimiqCircuitsBase.GateSX","text":"GateSX()\n\nSingle qubit sqrtX gate.\n\nSee also GateSXDG, GateX, Power\n\nMatrix representation\n\noperatornameSX =\nsqrtoperatornameX =\nfrac12\nbeginpmatrix\n    1+i  1-i \n    1-i  1+i\nendpmatrix\n\nExamples\n\njulia> GateSX()\nSX\n\njulia> matrix(GateSX())\n2×2 Matrix{ComplexF64}:\n 0.5+0.5im  0.5-0.5im\n 0.5-0.5im  0.5+0.5im\n\njulia> c = push!(Circuit(), GateSX(), 1)\n1-qubit circuit with 1 instructions:\n└── SX @ q[1]\n\njulia> push!(c, GateSX, 2)\n2-qubit circuit with 2 instructions:\n├── SX @ q[1]\n└── SX @ q[2]\n\njulia> power(GateSX(), 2), inverse(GateSX())\n(X, SX†)\n\n\nDecomposition\n\njulia> decompose(GateSX())\n1-qubit circuit with 4 instructions:\n├── S† @ q[1]\n├── H @ q[1]\n├── S† @ q[1]\n└── U(0, 0, 0, π/4) @ q[1]\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateSXDG","page":"Public","title":"MimiqCircuitsBase.GateSXDG","text":"GateSXDG()\n\nSingle qubit sqrtX^dagger gate (conjugate transpose of the sqrtX gate)\n\nSee also GateSX, GateX, Power, Inverse\n\nMatrix representation\n\noperatornameSXDG =\nsqrtoperatornameX^dagger =\nfrac12\nbeginpmatrix\n    1-i  1+i \n    1+i  1-i\nendpmatrix\n\nExamples\n\njulia> GateSXDG()\nSX†\n\njulia> matrix(GateSXDG())\n2×2 adjoint(::Matrix{ComplexF64}) with eltype ComplexF64:\n 0.5-0.5im  0.5+0.5im\n 0.5+0.5im  0.5-0.5im\n\njulia> c = push!(Circuit(), GateSXDG(), 1)\n1-qubit circuit with 1 instructions:\n└── SX† @ q[1]\n\njulia> push!(c, GateSXDG, 2)\n2-qubit circuit with 2 instructions:\n├── SX† @ q[1]\n└── SX† @ q[2]\n\njulia> power(GateSXDG(), 2), inverse(GateSXDG())\n((SX†)^2, SX)\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateR","page":"Public","title":"MimiqCircuitsBase.GateR","text":"GateR(θ, ϕ)\n\nSingle qubit parametric rotation operatornameR(theta lambda) gate.\n\nIt performs a rotation of theta radians for the target qubit around an XY-plane axis of the Bloch sphere determined by cos(phi)mathbfx + sin(phi)mathbfy.\n\nMatrix representation\n\noperatornameR(thetaphi) =\nbeginpmatrix\n    cosfractheta2  -ie^-iphisinfractheta2 \n    -ie^iphisinfractheta2  cosfractheta2\nendpmatrix\n\nExamples\n\njulia> @variables θ ϕ\n2-element Vector{Symbolics.Num}:\n θ\n ϕ\n\njulia> GateR(θ, ϕ)\nR(θ, ϕ)\n\njulia> matrix(GateR(2.023, 1.989))\n2×2 Matrix{ComplexF64}:\n 0.53059+0.0im       -0.77458+0.344239im\n 0.77458+0.344239im   0.53059+0.0im\n\njulia> c = push!(Circuit(), GateR(θ, ϕ), 1)\n1-qubit circuit with 1 instructions:\n└── R(θ, ϕ) @ q[1]\n\njulia> push!(c, GateR(π/2, π/4), 2)\n2-qubit circuit with 2 instructions:\n├── R(θ, ϕ) @ q[1]\n└── R(π/2, π/4) @ q[2]\n\n\nDecomposition\n\njulia> decompose(GateR(θ, ϕ))\n1-qubit circuit with 1 instructions:\n└── U3(θ, -1.5707963267948966 + ϕ, 1.5707963267948966 - ϕ) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateRX","page":"Public","title":"MimiqCircuitsBase.GateRX","text":"GateRX(θ)\n\nSingle qubit parametric rotation operatornameR_X(theta) gate.\n\nIt performs a rotation of theta radians around the X-axis of the Bloch sphere of the target qubit.\n\nMatrix representation\n\noperatornameR_X(theta) =\nbeginpmatrix\n    cosfractheta2  -isinfractheta2 \n    -isinfractheta2  cosfractheta2\nendpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateRX(θ)\nRX(θ)\n\njulia> matrix(GateRX(1.989))\n2×2 Matrix{ComplexF64}:\n 0.544922+0.0im            0.0-0.838487im\n      0.0-0.838487im  0.544922+0.0im\n\njulia> c = push!(Circuit(), GateRX(θ), 1)\n1-qubit circuit with 1 instructions:\n└── RX(θ) @ q[1]\n\njulia> push!(c, GateRX(π/2), 2)\n2-qubit circuit with 2 instructions:\n├── RX(θ) @ q[1]\n└── RX(π/2) @ q[2]\n\n\nDecomposition\n\njulia> decompose(GateRX(θ))\n1-qubit circuit with 1 instructions:\n└── U(θ, -1π/2, π/2) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateRY","page":"Public","title":"MimiqCircuitsBase.GateRY","text":"GateRY(θ)\n\nSingle qubit parametric rotation operatornameR_Y(theta) gate.\n\nIt performss a rotation of theta radians around the Y-axis of the Bloch sphere of the target qubit.\n\nMatrix representation\n\noperatornameR_Y(theta) =\nbeginpmatrix\n    cosfractheta2  -sinfractheta2 \n    sinfractheta2  cosfractheta2\nendpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateRY(θ)\nRY(θ)\n\njulia> matrix(GateRY(1.989))\n2×2 Matrix{Float64}:\n 0.544922  -0.838487\n 0.838487   0.544922\n\njulia> c = push!(Circuit(), GateRY(θ), 1)\n1-qubit circuit with 1 instructions:\n└── RY(θ) @ q[1]\n\njulia> push!(c, GateRY(π/2), 2)\n2-qubit circuit with 2 instructions:\n├── RY(θ) @ q[1]\n└── RY(π/2) @ q[2]\n\n\nDecomposition\n\njulia> decompose(GateRY(θ))\n1-qubit circuit with 1 instructions:\n└── U(θ, 0, 0) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateRZ","page":"Public","title":"MimiqCircuitsBase.GateRZ","text":"GateRZ(λ)\n\nSingle qubit parametric rotation operatornameR_Z(lambda) gate.\n\nIt performs a rotation of lambda radians around the Z-axis of the Bloch sphere for the target qubit.\n\nMatrix representation\n\noperatornameRZ(lambda) =\nbeginpmatrix\n    e^-ifraclambda2  0 \n    0  e^ifraclambda2\nendpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateRZ(θ)\nRZ(θ)\n\njulia> matrix(GateRZ(1.989))\n2×2 Matrix{ComplexF64}:\n 0.544922-0.838487im       0.0+0.0im\n      0.0+0.0im       0.544922+0.838487im\n\njulia> c = push!(Circuit(), GateRZ(θ), 1)\n1-qubit circuit with 1 instructions:\n└── RZ(θ) @ q[1]\n\njulia> push!(c, GateRZ(π/2), 2)\n2-qubit circuit with 2 instructions:\n├── RZ(θ) @ q[1]\n└── RZ(π/2) @ q[2]\n\n\nDecomposition\n\njulia> decompose(GateRZ(θ))\n1-qubit circuit with 1 instructions:\n└── U(0, 0, θ, (-1//2)*θ) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateSWAP","page":"Public","title":"MimiqCircuitsBase.GateSWAP","text":"GateSWAP()\n\nTwo qubit SWAP gate.\n\nSee also GateISWAP, GateCSWAP\n\nMatrix representation\n\noperatornameSWAP = frac1sqrt2\nbeginpmatrix\n    1  0  0  0 \n    0  0  1  0 \n    0  1  0  0 \n    0  0  0  1\nendpmatrix\n\nExamples\n\njulia> GateSWAP()\nSWAP\n\njulia> matrix(GateSWAP())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  1.0\n\njulia> c = push!(Circuit(), GateSWAP(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── SWAP @ q[1:2]\n\njulia> push!(c, GateSWAP, 3, 4)\n4-qubit circuit with 2 instructions:\n├── SWAP @ q[1:2]\n└── SWAP @ q[3:4]\n\njulia> power(GateSWAP(), 2), inverse(GateSWAP())\n(Parallel(2, ID), SWAP)\n\n\nDecomposition\n\njulia> decompose(GateSWAP())\n2-qubit circuit with 3 instructions:\n├── CX @ q[1], q[2]\n├── CX @ q[2], q[1]\n└── CX @ q[1], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateISWAP","page":"Public","title":"MimiqCircuitsBase.GateISWAP","text":"GateISWAP()\n\nTwo qubit ISWAP gate.\n\nSee also GateSWAP.\n\nMatrix representation\n\noperatornameISWAP = frac1sqrt2\nbeginpmatrix\n    1  0  0  0 \n    0  0  i  0 \n    0  i  0  0 \n    0  0  0  1\nendpmatrix\n\nExamples\n\njulia> GateISWAP()\nISWAP\n\njulia> matrix(GateISWAP())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+1.0im  0.0+0.0im\n 0.0+0.0im  0.0+1.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  1.0+0.0im\n\njulia> c = push!(Circuit(), GateISWAP(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── ISWAP @ q[1:2]\n\njulia> push!(c, GateISWAP, 3, 4)\n4-qubit circuit with 2 instructions:\n├── ISWAP @ q[1:2]\n└── ISWAP @ q[3:4]\n\njulia> power(GateISWAP(), 2), inverse(GateISWAP())\n(ISWAP^2, ISWAP†)\n\n\nDecomposition\n\njulia> decompose(GateISWAP())\n2-qubit circuit with 6 instructions:\n├── S @ q[1]\n├── S @ q[2]\n├── H @ q[1]\n├── CX @ q[1], q[2]\n├── CX @ q[2], q[1]\n└── H @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCX","page":"Public","title":"MimiqCircuitsBase.GateCX","text":"GateCX()\n\nTwo qubit Controlled-X gate (or CNOT).\n\ndetails: Details\nImplemented as an alias to Control(1, GateX()).\n\nnote: Note\nBy convention we refer to the first qubit as the control qubit and the second qubit as the target.\n\nMatrix representation\n\noperatornameCX =\nbeginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  0  1 \n    0  0  1  0\nendpmatrix\n\nExamples\n\njulia> GateCX(), numcontrols(GateCX()), numtargets(GateCX())\n(CX, 1, 1)\n\njulia> matrix(GateCX())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  1.0\n 0.0  0.0  1.0  0.0\n\njulia> c = push!(Circuit(), GateCX(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CX @ q[1], q[2]\n\njulia> power(GateCX(), 2), inverse(GateCX())\n(CID, CX)\n\n\nDecomposition\n\njulia> decompose(GateCX())\n2-qubit circuit with 1 instructions:\n└── CX @ q[1], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCY","page":"Public","title":"MimiqCircuitsBase.GateCY","text":"GateCY()\n\nTwo qubit Controlled-Y gate.\n\ndetails: Details\nImplemented as an alias to Control(1, GateY()).\n\nnote: Note\nBy convention we refer to the first qubit as the control qubit and the second qubit as the target.\n\nMatrix representation\n\noperatornameCY = beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  0  -i \n    0  0  i  0\nendpmatrix\n\nExamples\n\njulia> GateCY(), numcontrols(GateCY()), numtargets(GateCY())\n(CY, 1, 1)\n\njulia> matrix(GateCY())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0-1.0im\n 0.0+0.0im  0.0+0.0im  0.0+1.0im  0.0+0.0im\n\njulia> c = push!(Circuit(), GateCY(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CY @ q[1], q[2]\n\njulia> power(GateCY(), 2), inverse(GateCY())\n(CID, CY)\n\n\nDecomposition\n\njulia> decompose(GateCY())\n2-qubit circuit with 3 instructions:\n├── S† @ q[2]\n├── CX @ q[1], q[2]\n└── S @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCZ","page":"Public","title":"MimiqCircuitsBase.GateCZ","text":"GateCZ()\n\nTwo qubit Controlled-Z gate.\n\ndetails: Details\nImplemented as an alias to Control(1, GateZ()).\n\nnote: Note\nBy convention we refer to the first qubit as the control qubit and the second qubit as the target.\n\nMatrix representation\n\noperatornameCZ = beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  1  0 \n    0  0  0  -1\nendpmatrix\n\nExamples\n\njulia> GateCZ(), numcontrols(GateCZ()), numtargets(GateCZ())\n(CZ, 1, 1)\n\njulia> matrix(GateCZ())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0   0.0\n 0.0  1.0  0.0   0.0\n 0.0  0.0  1.0   0.0\n 0.0  0.0  0.0  -1.0\n\njulia> c = push!(Circuit(), GateCZ(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CZ @ q[1], q[2]\n\njulia> power(GateCZ(), 2), inverse(GateCZ())\n(CID, CZ)\n\n\nDecomposition\n\njulia> decompose(GateCZ())\n2-qubit circuit with 3 instructions:\n├── H @ q[2]\n├── CX @ q[1], q[2]\n└── H @ q[2]\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCH","page":"Public","title":"MimiqCircuitsBase.GateCH","text":"GateCH()\n\nTwo qubit controlled-Hadamard gate.\n\ndetails: Details\nImplemented as an alias to Control(1, GateH()).\n\nnote: Note\nBy convention, the first qubit is the control and the second is the target.\n\nMatrix representation\n\noperatornameCH = beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  frac1sqrt2  frac1sqrt2 \n    0  0  frac1sqrt2  -frac1sqrt2\nendpmatrix\n\nExamples\n\njulia> GateCH(), numcontrols(GateCH), numtargets(GateCH)\n(CH, 1, 1)\n\njulia> matrix(GateCH())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0        0.0\n 0.0  1.0  0.0        0.0\n 0.0  0.0  0.707107   0.707107\n 0.0  0.0  0.707107  -0.707107\n\njulia> c = push!(Circuit(), GateCH(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CH @ q[1], q[2]\n\njulia> power(GateCH(), 2), inverse(GateCH())\n(C(H^2), CH)\n\n\nDecomposition\n\njulia> decompose(GateCH())\n2-qubit circuit with 7 instructions:\n├── S @ q[2]\n├── H @ q[2]\n├── T @ q[2]\n├── CX @ q[1], q[2]\n├── T† @ q[2]\n├── H @ q[2]\n└── S† @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCS","page":"Public","title":"MimiqCircuitsBase.GateCS","text":"GateCS()\n\nTwo qubit Controlled-S gate.\n\ndetails: Details\nImplemented as an alias to Control(1, GateS()).\n\nSee also GateS, Control.\n\nMatrix representation\n\noperatornameCS =beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  1  0 \n    0  0  0  i\nendpmatrix\n\nExamples\n\njulia> GateCS(), numcontrols(GateCS()), numtargets(GateCS())\n(CS, 1, 1)\n\njulia> matrix(GateCS())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+1.0im\n\njulia> c = push!(Circuit(), GateCS(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CS @ q[1], q[2]\n\njulia> power(GateCS(), 2), inverse(GateCS())\n(CZ, C(S†))\n\n\nDecomposition\n\njulia> decompose(GateCS())\n2-qubit circuit with 1 instructions:\n└── CP(π/2) @ q[1], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCSDG","page":"Public","title":"MimiqCircuitsBase.GateCSDG","text":"GateCSDG()\n\nAdjoint of two qubit Controlled-S gate.\n\ndetails: Details\nImplemented as an alias to inverse(Control(1, GateS())).\n\nSee also GateS, Control.\n\nMatrix representation\n\noperatornameCS^dagger = beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  1  0 \n    0  0  0  -i\nendpmatrix\n\nExamples\n\njulia> GateCSDG(), numcontrols(GateCSDG()), numtargets(GateCSDG())\n(C(S†), 1, 1)\n\njulia> matrix(GateCSDG())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0-0.0im  0.0-0.0im\n 0.0+0.0im  0.0+0.0im  0.0-0.0im  0.0-1.0im\n\njulia> c = push!(Circuit(), GateCSDG(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── C(S†) @ q[1], q[2]\n\njulia> power(GateCSDG(), 2), inverse(GateCSDG())\n(C((S†)^2), CS)\n\n\nDecomposition\n\njulia> decompose(GateCSDG())\n2-qubit circuit with 1 instructions:\n└── CP(-1π/2) @ q[1], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCSX","page":"Public","title":"MimiqCircuitsBase.GateCSX","text":"GateCSX()\n\nTwo qubit Controled-SX gate.\n\ndetails: Details\nImplemented as an alias to Control(1, GateSX()).\n\nSee also GateSX, GateCSXDG, Control.\n\nMatrix representation\n\noperatornameCSX =beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  frac1+i2  frac1-i2 \n    0  0  frac1-i2  frac1+i2\nendpmatrix\n\nExamples\n\njulia> GateCSX(), numcontrols(GateCSX()), numtargets(GateCSX())\n(CSX, 1, 1)\n\njulia> matrix(GateCSX())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.5+0.5im  0.5-0.5im\n 0.0+0.0im  0.0+0.0im  0.5-0.5im  0.5+0.5im\n\njulia> c = push!(Circuit(), GateCSX(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CSX @ q[1], q[2]\n\njulia> power(GateCSX(), 2), inverse(GateCSX())\n(CX, C(SX†))\n\n\nDecomposition\n\njulia> decompose(GateCSX())\n2-qubit circuit with 3 instructions:\n├── H @ q[2]\n├── CU1(π/2) @ q[1], q[2]\n└── H @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCSXDG","page":"Public","title":"MimiqCircuitsBase.GateCSXDG","text":"GateCSXDG()\n\nTwo qubit CSX-dagger gate. (Control on second qubit)\n\ndetails: Details\nImplemented as an alias to Control(1, GateSXDG()).\n\nSee also GateSX, GateCSXDG, Control.\n\nMatrix representation\n\noperatornameCSX^dagger = beginpmatrix\n    1  0  0  0 \n    0  1  0  0\n    0  0  frac1-i2  frac1+i2 \n    0  0  frac1+i2  frac1-i2\nendpmatrix\n\nExamples\n\njulia> GateCSXDG(), numcontrols(GateCSXDG()), numtargets(GateCSXDG())\n(C(SX†), 1, 1)\n\njulia> matrix(GateCSXDG())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.5-0.5im  0.5+0.5im\n 0.0+0.0im  0.0+0.0im  0.5+0.5im  0.5-0.5im\n\njulia> c = push!(Circuit(), GateCSXDG(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── C(SX†) @ q[1], q[2]\n\njulia> power(GateCSXDG(), 2), inverse(GateCSXDG())\n(C((SX†)^2), CSX)\n\n\nDecomposition\n\njulia> decompose(GateCSXDG())\n2-qubit circuit with 3 instructions:\n├── H @ q[2]\n├── CU1(-1π/2) @ q[1], q[2]\n└── H @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCU","page":"Public","title":"MimiqCircuitsBase.GateCU","text":"GateCU(θ, ϕ, λ)\n\nControlled-operatornameU(theta phi lambda) gate.\n\ndetails: Details\nImplemented as an alias to Control(1, GateU(θ, ϕ, λ, γ)).\n\nSee also Control, GateU.\n\noperatornameCU(theta phi lambda gamma) =\nfrac12 beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  e^igamma cosleft(fractheta2right)  -e^igamma e^ilambdasinleft(fractheta2right) \n    0  0  e^igamma mathrme^iphisinleft(fractheta2right)  e^igamma mathrme^i(phi+lambda)cosleft(fractheta2right)\nendpmatrix\n\nExamples\n\njulia> @variables θ ϕ λ γ\n4-element Vector{Symbolics.Num}:\n θ\n ϕ\n λ\n γ\n\njulia> GateCU(θ, ϕ, λ, γ), numcontrols(GateCU(θ, ϕ, λ, γ)), numtargets(GateCU(θ, ϕ, λ, γ))\n(CU(θ, ϕ, λ, γ), 1, 1)\n\njulia> matrix(GateCU(2.023, 0.5, 0.1, 0.2))\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im       0.0+0.0im             0.0+0.0im\n 0.0+0.0im  1.0+0.0im       0.0+0.0im             0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.520013+0.105412im  -0.809771-0.250491im\n 0.0+0.0im  0.0+0.0im  0.648302+0.546057im   0.369666+0.380622im\n\njulia> c = push!(Circuit(), GateCU(θ, ϕ, λ, γ), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CU(θ, ϕ, λ, γ) @ q[1], q[2]\n\njulia> push!(c, GateCU(π/8, π/2, π/4, π/7), 1, 2)\n2-qubit circuit with 2 instructions:\n├── CU(θ, ϕ, λ, γ) @ q[1], q[2]\n└── CU(π/8, π/2, π/4, π/7) @ q[1], q[2]\n\njulia> power(GateCU(θ, ϕ, λ, γ), 2), inverse(GateCU(θ, ϕ, λ, γ))\n(C(U(θ, ϕ, λ, γ)^2), CU(-θ, -λ, -ϕ, -γ))\n\n\nDecomposition\n\njulia> decompose(GateCU(θ, λ, ϕ, γ))\n2-qubit circuit with 7 instructions:\n├── P(γ) @ q[1]\n├── P((1//2)*(λ + ϕ)) @ q[1]\n├── P((1//2)*(-λ + ϕ)) @ q[2]\n├── CX @ q[1], q[2]\n├── U((-1//2)*θ, 0, (1//2)*(-λ - ϕ)) @ q[2]\n├── CX @ q[1], q[2]\n└── U((1//2)*θ, λ, 0) @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCP","page":"Public","title":"MimiqCircuitsBase.GateCP","text":"GateCP(θ)\n\nControlled-operatornameP(lambda) gate.\n\ndetails: Details\nImplemented as an alias to Control(GateP(θ)).\n\nSee also Control, GateRZ.\n\nExamples\n\njulia> @variables λ\n1-element Vector{Symbolics.Num}:\n λ\n\njulia> GateCP(λ), numcontrols(GateCP(λ)), numtargets(GateCP(λ))\n(CP(λ), 1, 1)\n\njulia> matrix(GateCP(1.989))\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im       0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  -0.40612+0.91382im\n\njulia> c = push!(Circuit(), GateCP(λ), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CP(λ) @ q[1], q[2]\n\njulia> push!(c, GateCP(π/8), 1, 2)\n2-qubit circuit with 2 instructions:\n├── CP(λ) @ q[1], q[2]\n└── CP(π/8) @ q[1], q[2]\n\njulia> power(GateCP(λ), 2), inverse(GateCP(λ))\n(CP(2λ), CP(-λ))\n\n\nDecomposition\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> decompose(GateCP(θ))\n2-qubit circuit with 5 instructions:\n├── P((1//2)*θ) @ q[1]\n├── CX @ q[1], q[2]\n├── P((-1//2)*θ) @ q[2]\n├── CX @ q[1], q[2]\n└── P((1//2)*θ) @ q[2]\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCRX","page":"Public","title":"MimiqCircuitsBase.GateCRX","text":"GateCRX(θ)\n\nControlled-operatornameR_X(theta) gate.\n\ndetails: Details\nImplemented as an alias to Control(GateRX(θ)).\n\nSee also Control, GateRX.\n\nMatrix representation\n\noperatornameCRX(theta) = beginpmatrix\n            1  0  0  0 \n            0  1  0  0 \n            0  0  cosfractheta2  -isinfractheta2 \n            0  0  -isinfractheta2  cosfractheta2\n        endpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateCRX(θ), numcontrols(GateCRX(θ)), numtargets(GateCRX(θ))\n(CRX(θ), 1, 1)\n\njulia> matrix(GateCRX(1.989))\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im       0.0+0.0im            0.0+0.0im\n 0.0+0.0im  1.0+0.0im       0.0+0.0im            0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.544922+0.0im            0.0-0.838487im\n 0.0+0.0im  0.0+0.0im       0.0-0.838487im  0.544922+0.0im\n\njulia> c = push!(Circuit(), GateCRX(θ), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CRX(θ) @ q[1], q[2]\n\njulia> push!(c, GateCRX(π/8), 1, 2)\n2-qubit circuit with 2 instructions:\n├── CRX(θ) @ q[1], q[2]\n└── CRX(π/8) @ q[1], q[2]\n\njulia> power(GateCRX(θ), 2), inverse(GateCRX(θ))\n(CRX(2θ), CRX(-θ))\n\n\nDecomposition\n\njulia> decompose(GateCRX(θ))\n2-qubit circuit with 5 instructions:\n├── P(π/2) @ q[2]\n├── CX @ q[1], q[2]\n├── U((-1//2)*θ, 0, 0) @ q[2]\n├── CX @ q[1], q[2]\n└── U((1//2)*θ, -1π/2, 0) @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCRY","page":"Public","title":"MimiqCircuitsBase.GateCRY","text":"GateCRY(θ)\n\nControlled-operatornameR_Y(theta) gate.\n\ndetails: Details\nImplemented as an alias to Control(GateRY(θ)).\n\nSee also Control, GateRY.\n\nMatrix representation\n\noperatornameCRY(theta) = beginpmatrix\n            1  0  0  0 \n            0  1  0  0 \n            0  0  cosfractheta2  -sinfractheta2 \n            0  0   sinfractheta2  cosfractheta2\n        endpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateCRY(θ), numcontrols(GateCRY(θ)), numtargets(GateCRY(θ))\n(CRY(θ), 1, 1)\n\njulia> matrix(GateCRY(1.989))\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0        0.0\n 0.0  1.0  0.0        0.0\n 0.0  0.0  0.544922  -0.838487\n 0.0  0.0  0.838487   0.544922\n\njulia> c = push!(Circuit(), GateCRY(θ), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CRY(θ) @ q[1], q[2]\n\njulia> push!(c, GateCRY(π/8), 1, 2)\n2-qubit circuit with 2 instructions:\n├── CRY(θ) @ q[1], q[2]\n└── CRY(π/8) @ q[1], q[2]\n\njulia> power(GateCRY(θ), 2), inverse(GateCRY(θ))\n(CRY(2θ), CRY(-θ))\n\n\nDecomposition\n\njulia> decompose(GateCRY(θ))\n2-qubit circuit with 4 instructions:\n├── RY((1//2)*θ) @ q[2]\n├── CX @ q[1], q[2]\n├── RY((-1//2)*θ) @ q[2]\n└── CX @ q[1], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCRZ","page":"Public","title":"MimiqCircuitsBase.GateCRZ","text":"GateCRZ(θ)\n\nControlled-operatornameR_Z(theta) gate.\n\ndetails: Details\nImplemented as an alias to Control(GateRZ(θ)).\n\nSee also Control, GateRZ.\n\nMatrix representation\n\n    operatornameCRZ(theta) = beginpmatrix\n            1  0  0  0 \n            0  1  0  0 \n            0  0  e^-ifraclambda2  0 \n            0  0  0  e^ifraclambda2\n        endpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateCRZ(θ), numcontrols(GateCRZ(θ)), numtargets(GateCRZ(θ))\n(CRZ(θ), 1, 1)\n\njulia> matrix(GateCRZ(1.989))\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im       0.0+0.0im            0.0+0.0im\n 0.0+0.0im  1.0+0.0im       0.0+0.0im            0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.544922-0.838487im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im       0.0+0.0im       0.544922+0.838487im\n\njulia> c = push!(Circuit(), GateCRZ(θ), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CRZ(θ) @ q[1], q[2]\n\njulia> push!(c, GateCRZ(π/8), 1, 2)\n2-qubit circuit with 2 instructions:\n├── CRZ(θ) @ q[1], q[2]\n└── CRZ(π/8) @ q[1], q[2]\n\njulia> power(GateCRZ(θ), 2), inverse(GateCRZ(θ))\n(CRZ(2θ), CRZ(-θ))\n\n\nDecomposition\n\njulia> decompose(GateCRZ(θ))\n2-qubit circuit with 4 instructions:\n├── RZ((1//2)*θ) @ q[2]\n├── CX @ q[1], q[2]\n├── RZ((-1//2)*θ) @ q[2]\n└── CX @ q[1], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateECR","page":"Public","title":"MimiqCircuitsBase.GateECR","text":"GateECR()\n\nTwo qubit ECR echo gate.\n\nMatrix representation\n\noperatornameECR = frac1sqrt2\nbeginpmatrix\n    0  1  0  i \n    1  0  -i  0 \n    0  i  0  1 \n    -i  0  1  0\nendpmatrix\n\nExamples\n\njulia> GateECR()\nECR\n\njulia> matrix(GateECR())\n4×4 Matrix{ComplexF64}:\n      0.0+0.0im            0.0+0.0im       …       0.0+0.707107im\n      0.0+0.0im            0.0+0.0im          0.707107+0.0im\n 0.707107+0.0im            0.0-0.707107im          0.0+0.0im\n      0.0-0.707107im  0.707107+0.0im               0.0+0.0im\n\njulia> c = push!(Circuit(), GateECR(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── ECR @ q[1:2]\n\njulia> power(GateECR(), 2), inverse(GateECR())\n(Parallel(2, ID), ECR)\n\n\nDecomposition\n\njulia> decompose(GateECR())\n2-qubit circuit with 3 instructions:\n├── RZX(π/4) @ q[1:2]\n├── X @ q[1]\n└── RZX(-1π/4) @ q[1:2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateDCX","page":"Public","title":"MimiqCircuitsBase.GateDCX","text":"GateDCX()\n\nTwo qubit double-CNOT (control on first qubit and then second) OR DCX gate.\n\nMatrix representation\n\noperatornameDCX= beginpmatrix\n    1  0  0  0 \n    0  0  1  0 \n    0  0  0  1 \n    0  1  0  0\nendpmatrix\n\nExamples\n\njulia> GateDCX()\nDCX\n\njulia> matrix(GateDCX())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  1.0\n 0.0  1.0  0.0  0.0\n\njulia> c = push!(Circuit(), GateDCX(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── DCX @ q[1:2]\n\njulia> power(GateDCX(), 2), inverse(GateDCX())\n(DCX†, DCX†)\n\n\nDecomposition\n\njulia> decompose(GateDCX())\n2-qubit circuit with 2 instructions:\n├── CX @ q[1], q[2]\n└── CX @ q[2], q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateRXX","page":"Public","title":"MimiqCircuitsBase.GateRXX","text":"GateRXX(θ)\n\nParametric two qubit X otimes X interaction \\operatorname{R}_{XX}(\\theta) gate.\n\nIt corresponds to a rotation of theta radians along the XX axis of the two-qubit Bloch sphere.\n\nSee also GateRYY, GateRZZ, GateRZX, GateXXplusYY, GateXXminusYY.\n\nMatrix representation\n\noperatornameR_XX(theta) =\nbeginpmatrix\n    cos(fractheta2)  0  0  -isin(fractheta2) \n    0  cos(fractheta2)  -isin(fractheta2)  0 \n    0  -isin(fractheta2)  cos(fractheta2)  0 \n    -isin(fractheta2)  0  0  cos(fractheta2)\nendpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateRXX(θ)\nRXX(θ)\n\njulia> matrix(GateRXX(θ))\n4×4 Matrix{Complex{Symbolics.Num}}:\n     cos((1//2)*θ)                  0                  0  -im*sin((1//2)*θ)\n                 0      cos((1//2)*θ)  -im*sin((1//2)*θ)                  0\n                 0  -im*sin((1//2)*θ)      cos((1//2)*θ)                  0\n -im*sin((1//2)*θ)                  0                  0      cos((1//2)*θ)\n\njulia> c = push!(Circuit(), GateRXX(θ), 1, 2)\n2-qubit circuit with 1 instructions:\n└── RXX(θ) @ q[1:2]\n\njulia> push!(c, GateRXX(π/2), 1, 2)\n2-qubit circuit with 2 instructions:\n├── RXX(θ) @ q[1:2]\n└── RXX(π/2) @ q[1:2]\n\n\nDecomposition\n\njulia> decompose(GateRXX(θ))\n2-qubit circuit with 7 instructions:\n├── H @ q[1]\n├── H @ q[2]\n├── CX @ q[1], q[2]\n├── RZ(θ) @ q[2]\n├── CX @ q[1], q[2]\n├── H @ q[2]\n└── H @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateRYY","page":"Public","title":"MimiqCircuitsBase.GateRYY","text":"GateRYY(θ)\n\nParametric two qubit Y otimes Y interaction \\operatorname{R}_{YY}(\\theta) gate.\n\nIt corresponds to a rotation of theta radians along the YY axis of the two-qubit Bloch sphere.\n\nSee also GateRXX, GateRZZ, GateRZX, GateXXplusYY, GateXXminusYY.\n\nMatrix representation\n\noperatornameR_YY(theta) =\nbeginpmatrix\n    cos(fractheta2)  0  0  isin(fractheta2) \n    0  cos(fractheta2)  -isin(fractheta2)  0 \n    0  -isin(fractheta2)  cos(fractheta2)  0 \n    isin(fractheta2)  0  0  cos(fractheta2)\nendpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateRYY(θ)\nRYY(θ)\n\njulia> matrix(GateRYY(θ))\n4×4 Matrix{Complex{Symbolics.Num}}:\n    cos((1//2)*θ)                  0                  0  im*sin((1//2)*θ)\n                0      cos((1//2)*θ)  -im*sin((1//2)*θ)                 0\n                0  -im*sin((1//2)*θ)      cos((1//2)*θ)                 0\n im*sin((1//2)*θ)                  0                  0     cos((1//2)*θ)\n\njulia> c = push!(Circuit(), GateRYY(θ), 1, 2)\n2-qubit circuit with 1 instructions:\n└── RYY(θ) @ q[1:2]\n\njulia> push!(c, GateRYY(π/2), 1, 2)\n2-qubit circuit with 2 instructions:\n├── RYY(θ) @ q[1:2]\n└── RYY(π/2) @ q[1:2]\n\n\nDecomposition\n\njulia> decompose(GateRYY(θ))\n2-qubit circuit with 7 instructions:\n├── RX(π/2) @ q[1]\n├── RX(π/2) @ q[2]\n├── CX @ q[1], q[2]\n├── RZ(θ) @ q[2]\n├── CX @ q[1], q[2]\n├── RX(-1π/2) @ q[1]\n└── RX(-1π/2) @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateRZX","page":"Public","title":"MimiqCircuitsBase.GateRZX","text":"GateRZX(θ)\n\nParametric two qubit Z otimes X interaction \\operatorname{R}_{ZX}(\\theta) gate.\n\nIt corresponds to a rotation of theta radians about ZX.\n\nSee also GateRXX, GateRYY, GateRZZ, GateXXplusYY, GateXXminusYY.\n\nMatrix representation\n\noperatornameRZX(theta) =beginpmatrix\n            cos(fractheta2)  -isin(fractheta2)  0  0 \n            -isin(fractheta2)  cos(fractheta2)  0  0 \n            0  0  cos(fractheta2)  isin(fractheta2) \n            0  0  isin(fractheta2)  cos(fractheta2)\n        endpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateRZX(θ)\nRZX(θ)\n\njulia> matrix(GateRZX(θ))\n4×4 Matrix{Complex{Symbolics.Num}}:\n     cos((1//2)*θ)  -im*sin((1//2)*θ)                 0                 0\n -im*sin((1//2)*θ)      cos((1//2)*θ)                 0                 0\n                 0                  0     cos((1//2)*θ)  im*sin((1//2)*θ)\n                 0                  0  im*sin((1//2)*θ)     cos((1//2)*θ)\n\njulia> c = push!(Circuit(), GateRZX(θ), 1, 2)\n2-qubit circuit with 1 instructions:\n└── RZX(θ) @ q[1:2]\n\njulia> push!(c, GateRZX(π/2), 1, 2)\n2-qubit circuit with 2 instructions:\n├── RZX(θ) @ q[1:2]\n└── RZX(π/2) @ q[1:2]\n\n\nDecomposition\n\njulia> decompose(GateRZX(θ))\n2-qubit circuit with 5 instructions:\n├── H @ q[2]\n├── CX @ q[1], q[2]\n├── RZ(θ) @ q[2]\n├── CX @ q[1], q[2]\n└── H @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateRZZ","page":"Public","title":"MimiqCircuitsBase.GateRZZ","text":"GateRZZ(θ)\n\nParametric two qubit Z otimes Z interaction \\operatorname{R}_{ZZ}(\\theta) gate.\n\nIt corresponds to a rotation of theta radians along the ZZ axis of the two-qubit Bloch sphere.\n\nSee also GateRXX, GateRYY, GateRZX, GateXXplusYY, GateXXminusYY.\n\nMatrix representation\n\noperatornameR_ZZ(theta) =\nbeginpmatrix\n    e^-ifractheta2  0  0  0 \n    0  e^ifractheta2  0  0 \n    0  0  e^ifractheta2  0 \n    0  0  0  e^-ifractheta2\nendpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateRZZ(θ)\nRZZ(θ)\n\njulia> matrix(GateRZZ(θ))\n4×4 Matrix{Complex{Symbolics.Num}}:\n cos((-1//2)*θ) + im*sin((-1//2)*θ)  …                           0\n                          0                                      0\n                          0                                      0\n                          0             cos((-1//2)*θ) + im*sin((-1//2)*θ)\n\njulia> c = push!(Circuit(), GateRZZ(θ), 1, 2)\n2-qubit circuit with 1 instructions:\n└── RZZ(θ) @ q[1:2]\n\njulia> push!(c, GateRZZ(π/2), 1, 2)\n2-qubit circuit with 2 instructions:\n├── RZZ(θ) @ q[1:2]\n└── RZZ(π/2) @ q[1:2]\n\n\nDecomposition\n\njulia> decompose(GateRZZ(θ))\n2-qubit circuit with 3 instructions:\n├── CX @ q[1], q[2]\n├── RZ(θ) @ q[2]\n└── CX @ q[1], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateXXminusYY","page":"Public","title":"MimiqCircuitsBase.GateXXminusYY","text":"GateXXminusYY(θ, β)\n\nParametric two qubit X otimes X - Y otimes Y interaction operatorname(XX-YY)(theta beta) gate, where theta and beta are the rotation and phase angles.\n\nSee also GateRXX, GateRYY, GateRZZ, GateRZX, GateXXplusYY.\n\nMatrix Representation\n\noperatorname(XX-YY)(theta beta) =\nbeginpmatrix\n    cos(fractheta2)  0  0  -isin(fractheta2)e^-ibeta \n    0  1  0  0 \n    0  0  1  0 \n    -isin(fractheta2)e^ibeta  0  0  cos(fractheta2)\nendpmatrix\n\nExamples\n\njulia> @variables θ β\n2-element Vector{Symbolics.Num}:\n θ\n β\n\njulia> GateXXminusYY(θ, β)\nXXminusYY(θ, β)\n\njulia> matrix(GateXXminusYY(θ, β))\n4×4 Matrix{Complex{Symbolics.Num}}:\n          cos((1//2)*θ)                          …  sin(-β)*sin((1//2)*θ) - im*cos(-β)*sin((1//2)*θ)\n                      0                                                            0\n                      0                                                            0\n sin(β)*sin((1//2)*θ) - im*cos(β)*sin((1//2)*θ)                        cos((1//2)*θ)\n\njulia> c = push!(Circuit(), GateXXminusYY(θ, β), 1, 2)\n2-qubit circuit with 1 instructions:\n└── XXminusYY(θ, β) @ q[1:2]\n\njulia> push!(c, GateXXminusYY(π/2, 0.0), 1, 2)\n2-qubit circuit with 2 instructions:\n├── XXminusYY(θ, β) @ q[1:2]\n└── XXminusYY(π/2, 0π) @ q[1:2]\n\n\nDecomposition\n\njulia> decompose(GateXXminusYY(θ, β))\n2-qubit circuit with 14 instructions:\n├── RZ(-β) @ q[2]\n├── RZ(-1π/2) @ q[1]\n├── SX @ q[1]\n├── RZ(π/2) @ q[1]\n├── S @ q[2]\n├── CX @ q[1], q[2]\n├── RY((1//2)*θ) @ q[1]\n├── RY((-1//2)*θ) @ q[2]\n├── CX @ q[1], q[2]\n├── S† @ q[2]\n├── RZ(-1π/2) @ q[1]\n├── SX† @ q[1]\n├── RZ(π/2) @ q[1]\n└── RZ(β) @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateXXplusYY","page":"Public","title":"MimiqCircuitsBase.GateXXplusYY","text":"GateXXplusYY(θ, β)\n\nParametric two qubit X otimes X + Y otimes Y interaction operatorname(XX+YY)(theta beta) gate, where theta and beta are the rotation and phase angles.\n\nSee also GateRXX, GateRYY, GateRZZ, GateRZX, GateXXminusYY.\n\nMatrix representation\n\noperatorname(XX+YY)(theta beta) =\nbeginpmatrix\n    1  0  0  0 \n    0  cos(fractheta2)  -isin(fractheta2)e^ibeta  0 \n    0  -isin(fractheta2)e^-ibeta  cos(fractheta2)  0 \n    0  0  0  1\nendpmatrix\n\nExamples\n\njulia> @variables θ β\n2-element Vector{Symbolics.Num}:\n θ\n β\n\njulia> GateXXplusYY(θ, β)\nXXplusYY(θ, β)\n\njulia> matrix(GateXXplusYY(θ, β))\n4×4 Matrix{Complex{Symbolics.Num}}:\n 1                                 0                  …  0\n 0                     cos((1//2)*θ)                     0\n 0  sin(-β)*sin((1//2)*θ) - im*cos(-β)*sin((1//2)*θ)     0\n 0                                 0                     1\n\njulia> c = push!(Circuit(), GateXXplusYY(θ, β), 1, 2)\n2-qubit circuit with 1 instructions:\n└── XXplusYY(θ, β) @ q[1:2]\n\njulia> push!(c, GateXXplusYY(π/2, 0), 1, 2)\n2-qubit circuit with 2 instructions:\n├── XXplusYY(θ, β) @ q[1:2]\n└── XXplusYY(π/2, 0) @ q[1:2]\n\n\nDecomposition\n\njulia> decompose(GateXXplusYY(θ, β))\n2-qubit circuit with 14 instructions:\n├── RZ(β) @ q[1]\n├── RZ(-1π/2) @ q[2]\n├── SX @ q[2]\n├── RZ(π/2) @ q[2]\n├── S @ q[1]\n├── CX @ q[2], q[1]\n├── RY((-1//2)*θ) @ q[2]\n├── RY((-1//2)*θ) @ q[1]\n├── CX @ q[2], q[1]\n├── S† @ q[1]\n├── RZ(-1π/2) @ q[2]\n├── SX† @ q[2]\n├── RZ(π/2) @ q[2]\n└── RZ(-β) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCSWAP","page":"Public","title":"MimiqCircuitsBase.GateCSWAP","text":"GateCSWAP()\n\nThree-qubit, controlled-operatornameSWAP gate.\n\ndetails: Details\nImplemented as an alias to Control{1,2,3,GateSWAP}.\n\nSee also Control, GateU.\n\nnote: Note\nBy convention, the first qubit is the control and the last two are targets.\n\nExamples\n\njulia> GateCSWAP(), numcontrols(GateCSWAP()), numtargets(GateCSWAP())\n(CSWAP, 1, 2)\n\njulia> matrix(GateCSWAP())\n8×8 Matrix{Float64}:\n 1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0\n\njulia> c = push!(Circuit(), GateCSWAP(), 1, 2, 3)\n3-qubit circuit with 1 instructions:\n└── CSWAP @ q[1], q[2:3]\n\njulia> power(GateCSWAP(), 2), inverse(GateCSWAP())\n(C(Parallel(2, ID)), CSWAP)\n\n\nDecomposition\n\njulia> decompose(GateCSWAP())\n3-qubit circuit with 3 instructions:\n├── CX @ q[3], q[2]\n├── C₂X @ q[1:2], q[3]\n└── CX @ q[3], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateC3X","page":"Public","title":"MimiqCircuitsBase.GateC3X","text":"GateC3X()\n\nFour qubit, triply-controlled X gate.\n\ndetails: Details\nImplemented as an alias to Control(3 GateX()).\n\nnote: Note\nBy convention, the first three qubits are the controls and the fourth is the target.\n\nExamples\n\njulia> GateC3X(), numcontrols(GateC3X()), numtargets(GateC3X())\n(C₃X, 3, 1)\n\njulia> matrix(GateC3X())\n16×16 Matrix{Float64}:\n 1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  1.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  1.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  1.0  0.0\n\njulia> c = push!(Circuit(), GateC3X(), 1, 2, 3, 4)\n4-qubit circuit with 1 instructions:\n└── C₃X @ q[1:3], q[4]\n\njulia> power(GateC3X(), 2), inverse(GateC3X())\n(C₃ID, C₃X)\n\n\nDecomposition\n\njulia> decompose(GateC3X())\n4-qubit circuit with 31 instructions:\n├── H @ q[4]\n├── P(π/8) @ q[1]\n├── P(π/8) @ q[2]\n├── P(π/8) @ q[3]\n├── P(π/8) @ q[4]\n├── CX @ q[1], q[2]\n├── P(-1π/8) @ q[2]\n├── CX @ q[1], q[2]\n├── CX @ q[2], q[3]\n⋮   ⋮\n├── CX @ q[1], q[4]\n├── P(π/8) @ q[4]\n├── CX @ q[3], q[4]\n├── P(-1π/8) @ q[4]\n├── CX @ q[2], q[4]\n├── P(π/8) @ q[4]\n├── CX @ q[3], q[4]\n├── P(-1π/8) @ q[4]\n├── CX @ q[1], q[4]\n└── H @ q[4]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCCX","page":"Public","title":"MimiqCircuitsBase.GateCCX","text":"GateCCX()\n\nThree-qubit, doubly-controlled X gate.\n\ndetails: Details\nImplemented as an alias to Control(2 GateX()).\n\nnote: Note\nBy convention, the first two qubits are the controls and the third is the target.\n\nExamples\n\njulia> GateCCX(), numcontrols(GateCCX()), numtargets(GateCCX())\n(C₂X, 2, 1)\n\njulia> matrix(GateCCX())\n8×8 Matrix{Float64}:\n 1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0\n 0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0\n\njulia> c = push!(Circuit(), GateCCX(), 1, 2, 3)\n3-qubit circuit with 1 instructions:\n└── C₂X @ q[1:2], q[3]\n\njulia> power(GateCCX(), 2), inverse(GateCCX())\n(C₂ID, C₂X)\n\n\nDecomposition\n\njulia> decompose(GateCCX())\n3-qubit circuit with 15 instructions:\n├── H @ q[3]\n├── CX @ q[2], q[3]\n├── T† @ q[3]\n├── CX @ q[1], q[3]\n├── T @ q[3]\n├── CX @ q[2], q[3]\n├── T† @ q[3]\n├── CX @ q[1], q[3]\n├── T @ q[2]\n├── T @ q[3]\n├── H @ q[3]\n├── CX @ q[1], q[2]\n├── T @ q[1]\n├── T† @ q[2]\n└── CX @ q[1], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCCP","page":"Public","title":"MimiqCircuitsBase.GateCCP","text":"GateCCP(λ)\n\nThree-qubit, doubly-controlled phase gate.\n\ndetails: Details\nImplemented as an alias to Control(2 GateP(λ)).\n\nnote: Note\nBy convention, the first two qubits are the controls and the third is the target.\n\nExamples\n\njulia> @variables λ\n1-element Vector{Symbolics.Num}:\n λ\n\njulia> GateCCP(λ), numcontrols(GateCCP(λ)), numtargets(GateCCP(λ))\n(C₂P(λ), 2, 1)\n\njulia> matrix(GateCCP(1.989))\n8×8 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  …  0.0+0.0im       0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im     0.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im     0.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  1.0+0.0im     0.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im     0.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  …  0.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im     1.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im     0.0+0.0im  -0.40612+0.91382im\n\njulia> c = push!(Circuit(), GateCCP(λ), 1, 2, 3)\n3-qubit circuit with 1 instructions:\n└── C₂P(λ) @ q[1:2], q[3]\n\njulia> push!(c, GateCCP(π/8), 1, 2, 3)\n3-qubit circuit with 2 instructions:\n├── C₂P(λ) @ q[1:2], q[3]\n└── C₂P(π/8) @ q[1:2], q[3]\n\njulia> power(GateCCP(λ), 2), inverse(GateCCP(λ))\n(C₂P(2λ), C₂P(-λ))\n\n\nDecomposition\n\njulia> @variables λ\n1-element Vector{Symbolics.Num}:\n λ\n\njulia> decompose(GateCCP(λ))\n3-qubit circuit with 5 instructions:\n├── CP((1//2)*λ) @ q[2], q[3]\n├── CX @ q[1], q[2]\n├── CP((-1//2)*λ) @ q[2], q[3]\n├── CX @ q[1], q[2]\n└── CP((1//2)*λ) @ q[1], q[3]\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Custom-gates","page":"Public","title":"Custom gates","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"custom.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.GateCustom","page":"Public","title":"MimiqCircuitsBase.GateCustom","text":"struct GateCustom{N,T} <: AbstractGate{N}\n\nN qubit gate specified by a 2^N times 2^N matrix with elements of type T.\n\nUse this to construct your own gates based on unitary matrices. Currently only N=1,2 (M=2,4) are recognised.\n\nMIMIQ uses textbook convention for specifying gates.\n\nOne qubit gate matrices are defined in the basis 0rangle, 1rangle e.g.,\n\noperatornameZ =\nbeginpmatrix\n    10\n    0-1\nendpmatrix\n\nTwo qubit gate matrices are defined in the basis 00rangle, 01rangle>, 10rangle, 11rangle where the left-most qubit is the first to appear in the target list e.g.,\n\noperatornameCNOT =\nbeginpmatrix\n    1000\n    0100\n    0001\n    0010\nendpmatrix\n\njulia> CNOT = [1 0 0 0; 0 1 0 0; 0 0 0 1; 0 0 1 0]\n4×4 Matrix{Int64}:\n 1  0  0  0\n 0  1  0  0\n 0  0  0  1\n 0  0  1  0\n\njulia> # CNOT gate with control on q1 and target on q2\n\njulia> Instruction(GateCustom(CNOT), 1, 2)\nGateCustom([1 0 0 0; 0 1 0 0; 0 0 0 1; 0 0 1 0]) @ q1, q2\n\n# Examples\n\n\njldoctest julia> g = GateCustom([1 0; 0 1]) Custom([1.0 0.0; 0.0 1.0])\n\njulia> push!(Circuit(), g, 1) 1-qubit circuit with 1 instructions: └── Custom([1.0 0.0; 0.0 1.0]) @ q1 ```\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Generalized-gates","page":"Public","title":"Generalized gates","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\n    \"operations/generalized/qft.jl\",\n    \"operations/generalized/phasegradient.jl\",\n    \"operations/generalized/polynomialoracle.jl\",\n    \"operations/generalized/diffusion.jl\",\n]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.QFT","page":"Public","title":"MimiqCircuitsBase.QFT","text":"QFT(n)\n\nQuantum Fourier transform.\n\nPerforms the quantum Fourier transform on a register of n qubits.\n\nThe inverse quantum Fourier transform is simply given inverse(qft).\n\nIt implements the unitary transformation.\n\nfrac12^n2 sum_x=0^2^n-1 sum_y=0^2^n-1 e^2pi i fracxy2^n ketybrax\n\nExamples\n\njulia> c = push!(Circuit(), QFT(10), 1:10...)\n10-qubit circuit with 1 instructions:\n└── QFT @ q[1:10]\n\njulia> push!(c, inverse(QFT(10)), 1:10...)\n10-qubit circuit with 2 instructions:\n├── QFT @ q[1:10]\n└── QFT† @ q[1:10]\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.PhaseGradient","page":"Public","title":"MimiqCircuitsBase.PhaseGradient","text":"PhaseGradient(n)\n\nA phase gradient gate applies a phase shift to a quantum register of n qubits, where each computational basis state ketk experiences a phase proportional to its integer value k:\n\noperatornamePhaseGradient =\nsumk=0^n-1 mathrme^i frac2 piN k ketkbrak\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.PolynomialOracle","page":"Public","title":"MimiqCircuitsBase.PolynomialOracle","text":"PolynomialOracle(xregsize, yregsize, a, b, c, d)\nPolynomialOracle(a, b, c, d) # lazy\n\nQuantum oracle for a polynomial function of two registers.\n\nApplies a pi phase shift to any basis state which satifies a xy + bx + cy + d == 0, where ketx and kety are the states of the two registers.\n\nExamples\n\njulia> c = push!(Circuit(), PolynomialOracle(5,5,1,2,3,4), 1:10...)\n10-qubit circuit with 1 instructions:\n└── PolynomialOracle(1, 2, 3, 4) @ q[1:5], q[6:10]\n\njulia> push!(c, inverse(PolynomialOracle(5,5,1,2,3,4)), 1:10...)\n10-qubit circuit with 2 instructions:\n├── PolynomialOracle(1, 2, 3, 4) @ q[1:5], q[6:10]\n└── PolynomialOracle(1, 2, 3, 4) @ q[1:5], q[6:10]\n\nwarn: Warn\nThis operation is not yet implemented for decomposition. Might not work with some backends, where is not specifically implemented.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.Diffusion","page":"Public","title":"MimiqCircuitsBase.Diffusion","text":"Diffusion(n)\nDiffusion() # lazy\n\nGrover's diffusion operator.\n\nIt implements the unitary transformation.\n\nH^otimes n (1-2bra0^nket0^n) H^otimes n\n\nExamples\n\njulia> c = push!(Circuit(), Diffusion(10), 1:10...)\n10-qubit circuit with 1 instructions:\n└── Diffusion @ q[1:10]\n\njulia> push!(c, inverse(Diffusion(10)), 1:10...)\n10-qubit circuit with 2 instructions:\n├── Diffusion @ q[1:10]\n└── Diffusion† @ q[1:10]\n\njulia> decompose(Diffusion(4))\n4-qubit circuit with 9 instructions:\n├── RY(π/2) @ q[1]\n├── RY(π/2) @ q[2]\n├── RY(π/2) @ q[3]\n├── RY(π/2) @ q[4]\n├── C₃Z @ q[1:3], q[4]\n├── RY(π/2) @ q[1]\n├── RY(π/2) @ q[2]\n├── RY(π/2) @ q[3]\n└── RY(π/2) @ q[4]\n\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Gate-definitions","page":"Public","title":"Gate definitions","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"gatedecl.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.GateCall","page":"Public","title":"MimiqCircuitsBase.GateCall","text":"GateCall(decl, args...)\n\nGate corresponding to a call to a GateDecl definition.\n\nIt is created by calling a GateDecl with the proper number of arguments.\n\nExamples\n\njulia> decl = @gatedecl ansatz(θ) = begin\n           insts = Instruction[]\n           push!(insts, Instruction(GateX(), 1))\n           push!(insts, Instruction(GateRX(θ), 2))\n           return insts\n       end;\n\n\njulia> @variables λ;\n\n\njulia> decl(λ)\nansatz(λ)\n\n\nSee also\n\nGateDecl\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateDecl","page":"Public","title":"MimiqCircuitsBase.GateDecl","text":"GateDecl(name, args, instructions)\n\nDefine a new gate of given name, arguments and instructions.\n\nExamples\n\nA simple gate declaration, via the @gatedecl macro:\n\njulia> decl = @gatedecl ansatz(θ) = begin\n           insts = Instruction[]\n           push!(insts, Instruction(GateX(), 1))\n           push!(insts, Instruction(GateRX(θ), 2))\n           return insts\n       end\ngate ansatz(θ) =\n├── X @ q[1]\n└── RX(θ) @ q[2]\n\njulia> @variables λ;\n\n\njulia> decompose(decl(λ))\n2-qubit circuit with 2 instructions:\n├── X @ q[1]\n└── RX(λ) @ q[2]\n\n\nSee also\n\nGateCall\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Non-unitary-operations","page":"Public","title":"Non-unitary operations","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"reset.jl\", \"measure.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.Reset","page":"Public","title":"MimiqCircuitsBase.Reset","text":"Reset()\n\nQuantum operation that resets the status of one qubit to the ket0 state.\n\nSee also Operation, Measure.\n\nExamples\n\njulia> Reset()\nReset\n\njulia> c = push!(Circuit(), Reset, 1)\n1-qubit circuit with 1 instructions:\n└── Reset @ q[1]\n\njulia> push!(c, Reset(), 3)\n3-qubit circuit with 2 instructions:\n├── Reset @ q[1]\n└── Reset @ q[3]\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.Measure","page":"Public","title":"MimiqCircuitsBase.Measure","text":"Measure()\n\nSingle qubit measurement operation in the computational basis\n\nThe operation projects the quantum states and stores the result of such measurement is stored in a classical register.\n\nwarn: Warn\nMeasure is non-reversible.\n\nSee also Operation, Reset.\n\nExamples\n\njulia> Measure()\nMeasure\n\njulia> c = push!(Circuit(), Measure, 1, 1)\n1-qubit circuit with 1 instructions:\n└── Measure @ q[1], c[1]\n\njulia> push!(c, Measure(), 3, 4)\n3-qubit circuit with 2 instructions:\n├── Measure @ q[1], c[1]\n└── Measure @ q[3], c[4]\n\n\n\n\n\n","category":"type"},{"location":"library/public/#No-ops","page":"Public","title":"No-ops","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"barrier.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.Barrier","page":"Public","title":"MimiqCircuitsBase.Barrier","text":"Barrier(numqubits)\n\nNo-op operation that does not affect the quantum state or the execution of a circuit, but prevents compression or optimization across it.\n\nExamples\n\njulia> Barrier(1)\nBarrier\n\njulia> Barrier(2)\nBarrier\n\njulia> c = push!(Circuit(), Barrier(1), 1)\n1-qubit circuit with 1 instructions:\n└── Barrier @ q[1]\n\njulia> push!(c, Barrier(1), 1:3)\n3-qubit circuit with 4 instructions:\n├── Barrier @ q[1]\n├── Barrier @ q[1]\n├── Barrier @ q[2]\n└── Barrier @ q[3]\n\njulia> push!(c, Barrier(3), 1,2,3)\n3-qubit circuit with 5 instructions:\n├── Barrier @ q[1]\n├── Barrier @ q[1]\n├── Barrier @ q[2]\n├── Barrier @ q[3]\n└── Barrier @ q[1:3]\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Bit-Strings","page":"Public","title":"Bit Strings","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"bitstrings.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.BitString","page":"Public","title":"MimiqCircuitsBase.BitString","text":"BitString(numbits)\n\nRepresentation of the state of a register of bits. Can also represent the state of a register of qubits with defined values for each qubit (0 or 1).\n\nExamples\n\njulia> BitString(16)\n16-bits BitString with integer value 0:\n  00000000 00000000\n\njulia> bs = BitString(16, [1,2,3,4])\n16-bits BitString with integer value 15:\n  11110000 00000000\n\njulia> bs[10] = 1\n1\n\njulia> bs\n16-bits BitString with integer value 527:\n  11110000 01000000\n\njulia> bitstring_to_integer(bs)\n527\n\njulia> typeof(ans)\nBigInt\n\njulia> bitstring_to_integer(bs, Int)\n527\n\njulia> typeof(ans)\nInt64\n\nThere are many different ways to get bit states:\n\njulia> bs = BitString(30, 2344574)\n30-bits BitString with integer value 2344574:\n  01111110 01100011 11000100 000000\n\njulia> ones(BitString, 10) # or also trues(BitString, 10)\n10-bits BitString with integer value 1023:\n  11111111 11\n\njulia> zeros(BitString, 10) # or also falses(BitString, 10)\n10-bits BitString with integer value 0:\n  00000000 00\n\njulia> BitString(16) do i\n           iseven(i)\n       end\n16-bits BitString with integer value 43690:\n  01010101 01010101\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.bitstring_to_index-Tuple{BitString}","page":"Public","title":"MimiqCircuitsBase.bitstring_to_index","text":"bitstring_to_index(bitstring)\n\nConvert a bitstring into the corresponding index.\n\nThis is useful for indexing, for example, a vector of states.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#MimiqCircuitsBase.bitstring_to_integer","page":"Public","title":"MimiqCircuitsBase.bitstring_to_integer","text":"bitstring_to_integer(bitstring[, T])\n\nConvert a bitstring into its corresponding integer.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.nonzeros-Tuple{BitString}","page":"Public","title":"MimiqCircuitsBase.nonzeros","text":"nonzeros(bitstring)\n\nReturn the indices of the non-zero qubits in a bit state.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#MimiqCircuitsBase.to01-Tuple{BitString}","page":"Public","title":"MimiqCircuitsBase.to01","text":"to01(bitstring[, endianess=:big])\n\nConverts a BitString into a string of 0 and 1 characters. Optionally endianess can be specified, which can be either :big or :little.\n\nExamples\n\njulia> to01(bs\"10011\")\n\"10011\"\n\njulia> to01(bs\"10011\"; endianess=:big)\n\"10011\"\n\njulia> to01(bs\"10011\"; endianess=:little)\n\"11001\"\n\n\n\n\n\n","category":"method"},{"location":"library/public/#MimiqCircuitsBase.tobits-Tuple{BitString}","page":"Public","title":"MimiqCircuitsBase.tobits","text":"tobits(bitstring)\n\nGet the underlying BitVector of a bit state.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#MimiqCircuitsBase.@bs_str-Tuple{Any}","page":"Public","title":"MimiqCircuitsBase.@bs_str","text":"macro bs_str(s)\n\nConvert a string into a bit state.\n\nExamples\n\njulia> bs\"101011\"\n6-bits BitString with integer value 53:\n  101011\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#Results-of-simulations","page":"Public","title":"Results of simulations","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"qcsresults.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.QCSResults","page":"Public","title":"MimiqCircuitsBase.QCSResults","text":"QCSRresults()\nQCSRresults(simulator, version, fidelities, avggateerrors, cstates, zstates, amplitudes, timings)\n\nStorage for the results of a quantum circuit simulation.\n\nFields\n\nsimulator: name of the simulator used,\nversion: version of the simulator used,\nfidelities: fidelity estimates,\navggateerrors: average multiqubit gate errors,\ncstates: classical states content,\nzstates: complex valued states content (not used),\namplitudes: amplitudes,\ntimings: precise timings of the execution.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Symbolics","page":"Public","title":"Symbolics","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"symbolics.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.issymbolic","page":"Public","title":"MimiqCircuitsBase.issymbolic","text":"Check whether the circuit contains any symbolic (unevaluated) parameters.\n\nThis method examines each instruction in the circuit to determine if any parameter remains symbolic (i.e., unevaluated). It recursively checks through each instruction and its nested  operations, if any. Returns True if any parameter is symbolic (unevaluated), False if all parameters are fully evaluated.\n\nExamples\n\njulia> c = Circuit()\nempty circuit\n\n\njulia> push!(c, GateH(), 1)\n1-qubit circuit with 1 instructions:\n└── H @ q[1]\n\njulia> issymbolic(c)\nfalse\n\njulia> @variables x y\n2-element Vector{Symbolics.Num}:\n x\n y\n\njulia> push!(c,Control(3,GateP(x+y)),1,2,3,4)\n4-qubit circuit with 2 instructions:\n├── H @ q[1]\n└── C₃P(x + y) @ q[1:3], q[4]\n\njulia> issymbolic(c)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Serialization-Functions","page":"Public","title":"Serialization Functions","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"proto/proto.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.loadproto-Tuple{Any, Type{Circuit}}","page":"Public","title":"MimiqCircuitsBase.loadproto","text":"See saveproto, for the Examples\n\n\n\n\n\n","category":"method"},{"location":"library/public/#MimiqCircuitsBase.saveproto-Tuple{Any, Circuit}","page":"Public","title":"MimiqCircuitsBase.saveproto","text":"saveproto(fname, c::Circuit)\nsaveproto(fname, c::QCSResults)\nloadproto(fname, ::typeof(Circuit))\nloadproto(fname, ::typeof(QCSResults))\n\nSave and load a quantum circuit or QCSResults to/from a protocol buffer file.\n\nsaveproto\n\nThe saveproto function saves a given object, such as a Circuit or QCSResults, to a protocol buffer file.\n\nloadproto\n\nThe loadproto function loads a specified type of object from a protocol buffer file.\n\nExamples\n\njulia> c = Circuit()\nempty circuit\n\njulia> push!(c, GateX(), 1)\n1-qubit circuit with 1 instructions:\n└── X @ q[1]\n\njulia> push!(c, GateXXplusYY(1.0, 4), 1, 2:5)\n5-qubit circuit with 5 instructions:\n├── X @ q[1]\n├── XXplusYY(1.0, 4) @ q[1:2]\n├── XXplusYY(1.0, 4) @ q[1,3]\n├── XXplusYY(1.0, 4) @ q[1,4]\n└── XXplusYY(1.0, 4) @ q[1,5]\n\njulia> mktemp() do path, io\n           saveproto(path, c)\n           println( saveproto(path, c))\n           loaded_circuit = loadproto(path, Circuit)\n           println(loaded_circuit)\n       end\n135\n5-qubit circuit with 5 instructions:\n├── X @ q[1]\n├── XXplusYY(1.0, 4) @ q[1:2]\n├── XXplusYY(1.0, 4) @ q[1,3]\n├── XXplusYY(1.0, 4) @ q[1,4]\n└── XXplusYY(1.0, 4) @ q[1,5]\n\nnote: Note\nThis example uses a temporary file to demonstrate the save and load functionality. You can save your file with any name at any location using:saveproto(\"example.pb\", c)\n\nloadproto(\"example.pb\", typeof(c))\n\n\n\n\n\n","category":"method"}]
}
