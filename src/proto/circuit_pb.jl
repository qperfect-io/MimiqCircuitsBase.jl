# Autogenerated using ProtoBuf.jl v1.0.16 on 2024-10-22T20:04:05.284
# original file: /home/gdmsl/QPerfect/Code/MimiqCircuitsBase.jl/src/proto/circuit.proto (proto3 syntax)

module circuit_pb


import ..bitvector_pb
import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export Rational, KrausChannelType, Symbol, OperationType, GateType, AnnotationType, Note
export Amplitude, PauliString, ArgValue, FunctionType, Irrational, OperatorType, Barrier
export ObservableInclude, Detector, SimpleAnnotation, IfStatement, ArgFunction
export RescaledGate, CustomKrausChannel, CustomGate, ExpectationValue, Operation
export SimpleOperator, Operator, CustomOperator, Control, Parallel, MixedUnitaryChannel
export Gate, KrausChannel, PauliChannel, SimpleOperation, Inverse, DepolarizingChannel
export SimpleKrausChannel, ComplexArg, Power, Instruction, Generalized, SimpleGate, Circuit
export GateCall, Arg, GateDecl

# Abstract types to help resolve mutually recursive definitions
abstract type var"##AbstractIfStatement" end
abstract type var"##AbstractArgFunction" end
abstract type var"##AbstractRescaledGate" end
abstract type var"##AbstractCustomKrausChannel" end
abstract type var"##AbstractCustomGate" end
abstract type var"##AbstractExpectationValue" end
abstract type var"##AbstractOperation" end
abstract type var"##AbstractSimpleOperator" end
abstract type var"##AbstractOperator" end
abstract type var"##AbstractCustomOperator" end
abstract type var"##AbstractControl" end
abstract type var"##AbstractParallel" end
abstract type var"##AbstractMixedUnitaryChannel" end
abstract type var"##AbstractGate" end
abstract type var"##AbstractKrausChannel" end
abstract type var"##AbstractPauliChannel" end
abstract type var"##AbstractSimpleOperation" end
abstract type var"##AbstractInverse" end
abstract type var"##AbstractDepolarizingChannel" end
abstract type var"##AbstractSimpleKrausChannel" end
abstract type var"##AbstractComplexArg" end
abstract type var"##AbstractPower" end
abstract type var"##AbstractInstruction" end
abstract type var"##AbstractGeneralized" end
abstract type var"##AbstractSimpleGate" end
abstract type var"##AbstractCircuit" end
abstract type var"##AbstractGateCall" end
abstract type var"##AbstractArg" end
abstract type var"##AbstractGateDecl" end


struct Rational
    num::Int64
    den::Int64
end
PB.default_values(::Type{Rational}) = (;num = zero(Int64), den = zero(Int64))
PB.field_numbers(::Type{Rational}) = (;num = 1, den = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Rational})
    num = zero(Int64)
    den = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            num = PB.decode(d, Int64)
        elseif field_number == 2
            den = PB.decode(d, Int64)
        else
            PB.skip(d, wire_type)
        end
    end
    return Rational(num, den)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Rational)
    initpos = position(e.io)
    x.num != zero(Int64) && PB.encode(e, 1, x.num)
    x.den != zero(Int64) && PB.encode(e, 2, x.den)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Rational)
    encoded_size = 0
    x.num != zero(Int64) && (encoded_size += PB._encoded_size(x.num, 1))
    x.den != zero(Int64) && (encoded_size += PB._encoded_size(x.den, 2))
    return encoded_size
end

@enumx KrausChannelType ResetX=0 ResetY=1 ResetZ=2 AmplitudeDamping=3 GeneralizedAmplitudeDamping=4 PhaseAmplitudeDamping=5 ThermalNoise=6 PauliX=7 PauliY=8 PauliZ=9 ProjectiveNoiseX=10 ProjectiveNoiseY=11 ProjectiveNoiseZ=12

struct Symbol
    value::String
end
PB.default_values(::Type{Symbol}) = (;value = "")
PB.field_numbers(::Type{Symbol}) = (;value = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Symbol})
    value = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            value = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return Symbol(value)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Symbol)
    initpos = position(e.io)
    !isempty(x.value) && PB.encode(e, 1, x.value)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Symbol)
    encoded_size = 0
    !isempty(x.value) && (encoded_size += PB._encoded_size(x.value, 1))
    return encoded_size
end

@enumx OperationType MeasureX=0 MeasureY=1 MeasureZ=2 MeasureXX=3 MeasureYY=4 MeasureZZ=5 MeasureResetX=6 MeasureResetY=7 MeasureResetZ=8 BondDim=9 SchmidtRank=10 VonNeumannEntropy=11 Not=12

@enumx GateType GateID=0 GateX=1 GateY=2 GateZ=3 GateH=4 GateHXY=5 GateHYZ=6 GateS=7 GateT=8 Delay=9 GateU=10 GateP=11 GateRX=12 GateRY=13 GateRZ=14 GateR=15 GateU1=16 GateU2=17 GateU3=18 GateSWAP=19 GateISWAP=20 GateECR=21 GateDCX=22 GateRXX=23 GateRYY=24 GateRZZ=25 GateRZX=26 GateXXplusYY=27 GateXXminusYY=28

@enumx AnnotationType QubitCoordinates=0 ShiftCoordinates=1 Tick=3

struct Note
    note::Union{Nothing,OneOf{<:Union{Int64,Float64}}}
end
PB.oneof_field_types(::Type{Note}) = (;
    note = (;int_note=Int64, double_note=Float64),
)
PB.default_values(::Type{Note}) = (;int_note = zero(Int64), double_note = zero(Float64))
PB.field_numbers(::Type{Note}) = (;int_note = 1, double_note = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Note})
    note = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            note = OneOf(:int_note, PB.decode(d, Int64))
        elseif field_number == 2
            note = OneOf(:double_note, PB.decode(d, Float64))
        else
            PB.skip(d, wire_type)
        end
    end
    return Note(note)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Note)
    initpos = position(e.io)
    if isnothing(x.note);
    elseif x.note.name === :int_note
        PB.encode(e, 1, x.note[]::Int64)
    elseif x.note.name === :double_note
        PB.encode(e, 2, x.note[]::Float64)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Note)
    encoded_size = 0
    if isnothing(x.note);
    elseif x.note.name === :int_note
        encoded_size += PB._encoded_size(x.note[]::Int64, 1)
    elseif x.note.name === :double_note
        encoded_size += PB._encoded_size(x.note[]::Float64, 2)
    end
    return encoded_size
end

struct Amplitude
    bs::Union{Nothing,bitvector_pb.BitVector}
end
PB.default_values(::Type{Amplitude}) = (;bs = nothing)
PB.field_numbers(::Type{Amplitude}) = (;bs = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Amplitude})
    bs = Ref{Union{Nothing,bitvector_pb.BitVector}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, bs)
        else
            PB.skip(d, wire_type)
        end
    end
    return Amplitude(bs[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Amplitude)
    initpos = position(e.io)
    !isnothing(x.bs) && PB.encode(e, 1, x.bs)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Amplitude)
    encoded_size = 0
    !isnothing(x.bs) && (encoded_size += PB._encoded_size(x.bs, 1))
    return encoded_size
end

struct PauliString
    numqubits::Int64
    pauli::String
end
PB.default_values(::Type{PauliString}) = (;numqubits = zero(Int64), pauli = "")
PB.field_numbers(::Type{PauliString}) = (;numqubits = 1, pauli = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:PauliString})
    numqubits = zero(Int64)
    pauli = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            numqubits = PB.decode(d, Int64)
        elseif field_number == 2
            pauli = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return PauliString(numqubits, pauli)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::PauliString)
    initpos = position(e.io)
    x.numqubits != zero(Int64) && PB.encode(e, 1, x.numqubits)
    !isempty(x.pauli) && PB.encode(e, 2, x.pauli)
    return position(e.io) - initpos
end
function PB._encoded_size(x::PauliString)
    encoded_size = 0
    x.numqubits != zero(Int64) && (encoded_size += PB._encoded_size(x.numqubits, 1))
    !isempty(x.pauli) && (encoded_size += PB._encoded_size(x.pauli, 2))
    return encoded_size
end

struct ArgValue
    arg_value::Union{Nothing,OneOf{<:Union{Int64,Float64,Bool}}}
end
PB.oneof_field_types(::Type{ArgValue}) = (;
    arg_value = (;integer_value=Int64, double_value=Float64, bool_value=Bool),
)
PB.default_values(::Type{ArgValue}) = (;integer_value = zero(Int64), double_value = zero(Float64), bool_value = false)
PB.field_numbers(::Type{ArgValue}) = (;integer_value = 1, double_value = 2, bool_value = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ArgValue})
    arg_value = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            arg_value = OneOf(:integer_value, PB.decode(d, Int64))
        elseif field_number == 2
            arg_value = OneOf(:double_value, PB.decode(d, Float64))
        elseif field_number == 3
            arg_value = OneOf(:bool_value, PB.decode(d, Bool))
        else
            PB.skip(d, wire_type)
        end
    end
    return ArgValue(arg_value)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ArgValue)
    initpos = position(e.io)
    if isnothing(x.arg_value);
    elseif x.arg_value.name === :integer_value
        PB.encode(e, 1, x.arg_value[]::Int64)
    elseif x.arg_value.name === :double_value
        PB.encode(e, 2, x.arg_value[]::Float64)
    elseif x.arg_value.name === :bool_value
        PB.encode(e, 3, x.arg_value[]::Bool)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::ArgValue)
    encoded_size = 0
    if isnothing(x.arg_value);
    elseif x.arg_value.name === :integer_value
        encoded_size += PB._encoded_size(x.arg_value[]::Int64, 1)
    elseif x.arg_value.name === :double_value
        encoded_size += PB._encoded_size(x.arg_value[]::Float64, 2)
    elseif x.arg_value.name === :bool_value
        encoded_size += PB._encoded_size(x.arg_value[]::Bool, 3)
    end
    return encoded_size
end

@enumx FunctionType ADD=0 MUL=1 DIV=2 POW=3 SIN=5 COS=6 TAN=7 EXP=8 LOG=9 IDENTITY=10

@enumx Irrational PI=0 EULER=1

@enumx OperatorType SigmaMinus=0 SigmaPlus=1 Sigma0001=2 Sigma0010=3 Sigma0011=4 Sigma0110=5 Sigma0111=6 Sigma1011=7 Projector0=8 Projector1=9 Projector00=10 Projector01=11 Projector10=12 Projector11=13 ProjectorX0=14 ProjectorX1=15 ProjectorY0=16 ProjectorY1=17 DiagonalOp=18

struct Barrier
    numqubits::Int64
end
PB.default_values(::Type{Barrier}) = (;numqubits = zero(Int64))
PB.field_numbers(::Type{Barrier}) = (;numqubits = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Barrier})
    numqubits = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            numqubits = PB.decode(d, Int64)
        else
            PB.skip(d, wire_type)
        end
    end
    return Barrier(numqubits)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Barrier)
    initpos = position(e.io)
    x.numqubits != zero(Int64) && PB.encode(e, 1, x.numqubits)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Barrier)
    encoded_size = 0
    x.numqubits != zero(Int64) && (encoded_size += PB._encoded_size(x.numqubits, 1))
    return encoded_size
end

struct ObservableInclude
    numbits::Int64
    notes::Vector{Note}
end
PB.default_values(::Type{ObservableInclude}) = (;numbits = zero(Int64), notes = Vector{Note}())
PB.field_numbers(::Type{ObservableInclude}) = (;numbits = 1, notes = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ObservableInclude})
    numbits = zero(Int64)
    notes = PB.BufferedVector{Note}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            numbits = PB.decode(d, Int64)
        elseif field_number == 2
            PB.decode!(d, notes)
        else
            PB.skip(d, wire_type)
        end
    end
    return ObservableInclude(numbits, notes[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ObservableInclude)
    initpos = position(e.io)
    x.numbits != zero(Int64) && PB.encode(e, 1, x.numbits)
    !isempty(x.notes) && PB.encode(e, 2, x.notes)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ObservableInclude)
    encoded_size = 0
    x.numbits != zero(Int64) && (encoded_size += PB._encoded_size(x.numbits, 1))
    !isempty(x.notes) && (encoded_size += PB._encoded_size(x.notes, 2))
    return encoded_size
end

struct Detector
    numqubits::Int64
    notes::Vector{Note}
end
PB.default_values(::Type{Detector}) = (;numqubits = zero(Int64), notes = Vector{Note}())
PB.field_numbers(::Type{Detector}) = (;numqubits = 1, notes = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Detector})
    numqubits = zero(Int64)
    notes = PB.BufferedVector{Note}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            numqubits = PB.decode(d, Int64)
        elseif field_number == 2
            PB.decode!(d, notes)
        else
            PB.skip(d, wire_type)
        end
    end
    return Detector(numqubits, notes[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Detector)
    initpos = position(e.io)
    x.numqubits != zero(Int64) && PB.encode(e, 1, x.numqubits)
    !isempty(x.notes) && PB.encode(e, 2, x.notes)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Detector)
    encoded_size = 0
    x.numqubits != zero(Int64) && (encoded_size += PB._encoded_size(x.numqubits, 1))
    !isempty(x.notes) && (encoded_size += PB._encoded_size(x.notes, 2))
    return encoded_size
end

struct SimpleAnnotation
    mtype::AnnotationType.T
    notes::Vector{Note}
end
PB.default_values(::Type{SimpleAnnotation}) = (;mtype = AnnotationType.QubitCoordinates, notes = Vector{Note}())
PB.field_numbers(::Type{SimpleAnnotation}) = (;mtype = 1, notes = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SimpleAnnotation})
    mtype = AnnotationType.QubitCoordinates
    notes = PB.BufferedVector{Note}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            mtype = PB.decode(d, AnnotationType.T)
        elseif field_number == 2
            PB.decode!(d, notes)
        else
            PB.skip(d, wire_type)
        end
    end
    return SimpleAnnotation(mtype, notes[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SimpleAnnotation)
    initpos = position(e.io)
    x.mtype != AnnotationType.QubitCoordinates && PB.encode(e, 1, x.mtype)
    !isempty(x.notes) && PB.encode(e, 2, x.notes)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SimpleAnnotation)
    encoded_size = 0
    x.mtype != AnnotationType.QubitCoordinates && (encoded_size += PB._encoded_size(x.mtype, 1))
    !isempty(x.notes) && (encoded_size += PB._encoded_size(x.notes, 2))
    return encoded_size
end

struct IfStatement{T1<:Union{Nothing,var"##AbstractOperation"}} <: var"##AbstractIfStatement"
    operation::T1
    bitstring::Union{Nothing,bitvector_pb.BitVector}
end
PB.default_values(::Type{IfStatement}) = (;operation = nothing, bitstring = nothing)
PB.field_numbers(::Type{IfStatement}) = (;operation = 1, bitstring = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:IfStatement})
    operation = Ref{Union{Nothing,Operation}}(nothing)
    bitstring = Ref{Union{Nothing,bitvector_pb.BitVector}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, operation)
        elseif field_number == 2
            PB.decode!(d, bitstring)
        else
            PB.skip(d, wire_type)
        end
    end
    return IfStatement(operation[], bitstring[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::IfStatement)
    initpos = position(e.io)
    !isnothing(x.operation) && PB.encode(e, 1, x.operation)
    !isnothing(x.bitstring) && PB.encode(e, 2, x.bitstring)
    return position(e.io) - initpos
end
function PB._encoded_size(x::IfStatement)
    encoded_size = 0
    !isnothing(x.operation) && (encoded_size += PB._encoded_size(x.operation, 1))
    !isnothing(x.bitstring) && (encoded_size += PB._encoded_size(x.bitstring, 2))
    return encoded_size
end

struct ArgFunction{T1<:Union{Nothing,var"##AbstractArg"}} <: var"##AbstractArgFunction"
    mtype::FunctionType.T
    args::Vector{T1}
end
PB.default_values(::Type{ArgFunction}) = (;mtype = FunctionType.ADD, args = Vector{Arg}())
PB.field_numbers(::Type{ArgFunction}) = (;mtype = 1, args = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ArgFunction})
    mtype = FunctionType.ADD
    args = PB.BufferedVector{Arg}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            mtype = PB.decode(d, FunctionType.T)
        elseif field_number == 2
            PB.decode!(d, args)
        else
            PB.skip(d, wire_type)
        end
    end
    return ArgFunction(mtype, args[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ArgFunction)
    initpos = position(e.io)
    x.mtype != FunctionType.ADD && PB.encode(e, 1, x.mtype)
    !isempty(x.args) && PB.encode(e, 2, x.args)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ArgFunction)
    encoded_size = 0
    x.mtype != FunctionType.ADD && (encoded_size += PB._encoded_size(x.mtype, 1))
    !isempty(x.args) && (encoded_size += PB._encoded_size(x.args, 2))
    return encoded_size
end

struct RescaledGate{T1<:Union{Nothing,var"##AbstractGate"},T2<:Union{Nothing,var"##AbstractArg"}} <: var"##AbstractRescaledGate"
    operation::T1
    scale::T2
end
PB.default_values(::Type{RescaledGate}) = (;operation = nothing, scale = nothing)
PB.field_numbers(::Type{RescaledGate}) = (;operation = 1, scale = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RescaledGate})
    operation = Ref{Union{Nothing,Gate}}(nothing)
    scale = Ref{Union{Nothing,Arg}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, operation)
        elseif field_number == 2
            PB.decode!(d, scale)
        else
            PB.skip(d, wire_type)
        end
    end
    return RescaledGate(operation[], scale[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RescaledGate)
    initpos = position(e.io)
    !isnothing(x.operation) && PB.encode(e, 1, x.operation)
    !isnothing(x.scale) && PB.encode(e, 2, x.scale)
    return position(e.io) - initpos
end
function PB._encoded_size(x::RescaledGate)
    encoded_size = 0
    !isnothing(x.operation) && (encoded_size += PB._encoded_size(x.operation, 1))
    !isnothing(x.scale) && (encoded_size += PB._encoded_size(x.scale, 2))
    return encoded_size
end

struct CustomKrausChannel{T1<:Union{Nothing,var"##AbstractOperator"}} <: var"##AbstractCustomKrausChannel"
    numqubits::Int64
    operators::Vector{T1}
end
PB.default_values(::Type{CustomKrausChannel}) = (;numqubits = zero(Int64), operators = Vector{Operator}())
PB.field_numbers(::Type{CustomKrausChannel}) = (;numqubits = 1, operators = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CustomKrausChannel})
    numqubits = zero(Int64)
    operators = PB.BufferedVector{Operator}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            numqubits = PB.decode(d, Int64)
        elseif field_number == 2
            PB.decode!(d, operators)
        else
            PB.skip(d, wire_type)
        end
    end
    return CustomKrausChannel(numqubits, operators[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CustomKrausChannel)
    initpos = position(e.io)
    x.numqubits != zero(Int64) && PB.encode(e, 1, x.numqubits)
    !isempty(x.operators) && PB.encode(e, 2, x.operators)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CustomKrausChannel)
    encoded_size = 0
    x.numqubits != zero(Int64) && (encoded_size += PB._encoded_size(x.numqubits, 1))
    !isempty(x.operators) && (encoded_size += PB._encoded_size(x.operators, 2))
    return encoded_size
end

struct CustomGate{T1<:Union{Nothing,var"##AbstractComplexArg"}} <: var"##AbstractCustomGate"
    numqubits::Int64
    matrix::Vector{T1}
end
PB.default_values(::Type{CustomGate}) = (;numqubits = zero(Int64), matrix = Vector{ComplexArg}())
PB.field_numbers(::Type{CustomGate}) = (;numqubits = 1, matrix = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CustomGate})
    numqubits = zero(Int64)
    matrix = PB.BufferedVector{ComplexArg}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            numqubits = PB.decode(d, Int64)
        elseif field_number == 2
            PB.decode!(d, matrix)
        else
            PB.skip(d, wire_type)
        end
    end
    return CustomGate(numqubits, matrix[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CustomGate)
    initpos = position(e.io)
    x.numqubits != zero(Int64) && PB.encode(e, 1, x.numqubits)
    !isempty(x.matrix) && PB.encode(e, 2, x.matrix)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CustomGate)
    encoded_size = 0
    x.numqubits != zero(Int64) && (encoded_size += PB._encoded_size(x.numqubits, 1))
    !isempty(x.matrix) && (encoded_size += PB._encoded_size(x.matrix, 2))
    return encoded_size
end

struct ExpectationValue{T1<:Union{Nothing,var"##AbstractOperator"}} <: var"##AbstractExpectationValue"
    operator::T1
end
PB.default_values(::Type{ExpectationValue}) = (;operator = nothing)
PB.field_numbers(::Type{ExpectationValue}) = (;operator = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ExpectationValue})
    operator = Ref{Union{Nothing,Operator}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, operator)
        else
            PB.skip(d, wire_type)
        end
    end
    return ExpectationValue(operator[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ExpectationValue)
    initpos = position(e.io)
    !isnothing(x.operator) && PB.encode(e, 1, x.operator)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ExpectationValue)
    encoded_size = 0
    !isnothing(x.operator) && (encoded_size += PB._encoded_size(x.operator, 1))
    return encoded_size
end

struct Operation <: var"##AbstractOperation"
    operation::Union{Nothing,OneOf{<:Union{var"##AbstractSimpleGate",var"##AbstractCustomGate",var"##AbstractGeneralized",var"##AbstractControl",var"##AbstractPower",var"##AbstractInverse",var"##AbstractParallel",var"##AbstractGateCall",PauliString,var"##AbstractSimpleKrausChannel",var"##AbstractCustomKrausChannel",var"##AbstractDepolarizingChannel",var"##AbstractMixedUnitaryChannel",var"##AbstractPauliChannel",var"##AbstractSimpleOperator",var"##AbstractCustomOperator",var"##AbstractRescaledGate",var"##AbstractSimpleOperation",var"##AbstractIfStatement",Barrier,Amplitude,var"##AbstractExpectationValue",Detector,ObservableInclude,SimpleAnnotation}}}
end
PB.oneof_field_types(::Type{Operation}) = (;
    operation = (;simplegate=SimpleGate, customgate=CustomGate, generalized=Generalized, control=Control, power=Power, inverse=Inverse, parallel=Parallel, gatecall=GateCall, paulistring=PauliString, simplekrauschannel=SimpleKrausChannel, customkrauschannel=CustomKrausChannel, depolarizingchannel=DepolarizingChannel, mixedunitarychannel=MixedUnitaryChannel, paulichannel=PauliChannel, simpleoperator=SimpleOperator, customoperator=CustomOperator, rescaledgate=RescaledGate, simpleoperation=SimpleOperation, ifstatement=IfStatement, barrier=Barrier, amplitude=Amplitude, expectationvalue=ExpectationValue, detector=Detector, observableinc=ObservableInclude, simpleannotation=SimpleAnnotation),
)
PB.default_values(::Type{Operation}) = (;simplegate = nothing, customgate = nothing, generalized = nothing, control = nothing, power = nothing, inverse = nothing, parallel = nothing, gatecall = nothing, paulistring = nothing, simplekrauschannel = nothing, customkrauschannel = nothing, depolarizingchannel = nothing, mixedunitarychannel = nothing, paulichannel = nothing, simpleoperator = nothing, customoperator = nothing, rescaledgate = nothing, simpleoperation = nothing, ifstatement = nothing, barrier = nothing, amplitude = nothing, expectationvalue = nothing, detector = nothing, observableinc = nothing, simpleannotation = nothing)
PB.field_numbers(::Type{Operation}) = (;simplegate = 1, customgate = 2, generalized = 3, control = 4, power = 5, inverse = 6, parallel = 7, gatecall = 8, paulistring = 9, simplekrauschannel = 10, customkrauschannel = 11, depolarizingchannel = 12, mixedunitarychannel = 13, paulichannel = 14, simpleoperator = 15, customoperator = 16, rescaledgate = 17, simpleoperation = 18, ifstatement = 19, barrier = 20, amplitude = 21, expectationvalue = 22, detector = 23, observableinc = 24, simpleannotation = 25)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Operation})
    operation = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            operation = OneOf(:simplegate, PB.decode(d, Ref{SimpleGate}))
        elseif field_number == 2
            operation = OneOf(:customgate, PB.decode(d, Ref{CustomGate}))
        elseif field_number == 3
            operation = OneOf(:generalized, PB.decode(d, Ref{Generalized}))
        elseif field_number == 4
            operation = OneOf(:control, PB.decode(d, Ref{Control}))
        elseif field_number == 5
            operation = OneOf(:power, PB.decode(d, Ref{Power}))
        elseif field_number == 6
            operation = OneOf(:inverse, PB.decode(d, Ref{Inverse}))
        elseif field_number == 7
            operation = OneOf(:parallel, PB.decode(d, Ref{Parallel}))
        elseif field_number == 8
            operation = OneOf(:gatecall, PB.decode(d, Ref{GateCall}))
        elseif field_number == 9
            operation = OneOf(:paulistring, PB.decode(d, Ref{PauliString}))
        elseif field_number == 10
            operation = OneOf(:simplekrauschannel, PB.decode(d, Ref{SimpleKrausChannel}))
        elseif field_number == 11
            operation = OneOf(:customkrauschannel, PB.decode(d, Ref{CustomKrausChannel}))
        elseif field_number == 12
            operation = OneOf(:depolarizingchannel, PB.decode(d, Ref{DepolarizingChannel}))
        elseif field_number == 13
            operation = OneOf(:mixedunitarychannel, PB.decode(d, Ref{MixedUnitaryChannel}))
        elseif field_number == 14
            operation = OneOf(:paulichannel, PB.decode(d, Ref{PauliChannel}))
        elseif field_number == 15
            operation = OneOf(:simpleoperator, PB.decode(d, Ref{SimpleOperator}))
        elseif field_number == 16
            operation = OneOf(:customoperator, PB.decode(d, Ref{CustomOperator}))
        elseif field_number == 17
            operation = OneOf(:rescaledgate, PB.decode(d, Ref{RescaledGate}))
        elseif field_number == 18
            operation = OneOf(:simpleoperation, PB.decode(d, Ref{SimpleOperation}))
        elseif field_number == 19
            operation = OneOf(:ifstatement, PB.decode(d, Ref{IfStatement}))
        elseif field_number == 20
            operation = OneOf(:barrier, PB.decode(d, Ref{Barrier}))
        elseif field_number == 21
            operation = OneOf(:amplitude, PB.decode(d, Ref{Amplitude}))
        elseif field_number == 22
            operation = OneOf(:expectationvalue, PB.decode(d, Ref{ExpectationValue}))
        elseif field_number == 23
            operation = OneOf(:detector, PB.decode(d, Ref{Detector}))
        elseif field_number == 24
            operation = OneOf(:observableinc, PB.decode(d, Ref{ObservableInclude}))
        elseif field_number == 25
            operation = OneOf(:simpleannotation, PB.decode(d, Ref{SimpleAnnotation}))
        else
            PB.skip(d, wire_type)
        end
    end
    return Operation(operation)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Operation)
    initpos = position(e.io)
    if isnothing(x.operation);
    elseif x.operation.name === :simplegate
        PB.encode(e, 1, x.operation[]::SimpleGate)
    elseif x.operation.name === :customgate
        PB.encode(e, 2, x.operation[]::CustomGate)
    elseif x.operation.name === :generalized
        PB.encode(e, 3, x.operation[]::Generalized)
    elseif x.operation.name === :control
        PB.encode(e, 4, x.operation[]::Control)
    elseif x.operation.name === :power
        PB.encode(e, 5, x.operation[]::Power)
    elseif x.operation.name === :inverse
        PB.encode(e, 6, x.operation[]::Inverse)
    elseif x.operation.name === :parallel
        PB.encode(e, 7, x.operation[]::Parallel)
    elseif x.operation.name === :gatecall
        PB.encode(e, 8, x.operation[]::GateCall)
    elseif x.operation.name === :paulistring
        PB.encode(e, 9, x.operation[]::PauliString)
    elseif x.operation.name === :simplekrauschannel
        PB.encode(e, 10, x.operation[]::SimpleKrausChannel)
    elseif x.operation.name === :customkrauschannel
        PB.encode(e, 11, x.operation[]::CustomKrausChannel)
    elseif x.operation.name === :depolarizingchannel
        PB.encode(e, 12, x.operation[]::DepolarizingChannel)
    elseif x.operation.name === :mixedunitarychannel
        PB.encode(e, 13, x.operation[]::MixedUnitaryChannel)
    elseif x.operation.name === :paulichannel
        PB.encode(e, 14, x.operation[]::PauliChannel)
    elseif x.operation.name === :simpleoperator
        PB.encode(e, 15, x.operation[]::SimpleOperator)
    elseif x.operation.name === :customoperator
        PB.encode(e, 16, x.operation[]::CustomOperator)
    elseif x.operation.name === :rescaledgate
        PB.encode(e, 17, x.operation[]::RescaledGate)
    elseif x.operation.name === :simpleoperation
        PB.encode(e, 18, x.operation[]::SimpleOperation)
    elseif x.operation.name === :ifstatement
        PB.encode(e, 19, x.operation[]::IfStatement)
    elseif x.operation.name === :barrier
        PB.encode(e, 20, x.operation[]::Barrier)
    elseif x.operation.name === :amplitude
        PB.encode(e, 21, x.operation[]::Amplitude)
    elseif x.operation.name === :expectationvalue
        PB.encode(e, 22, x.operation[]::ExpectationValue)
    elseif x.operation.name === :detector
        PB.encode(e, 23, x.operation[]::Detector)
    elseif x.operation.name === :observableinc
        PB.encode(e, 24, x.operation[]::ObservableInclude)
    elseif x.operation.name === :simpleannotation
        PB.encode(e, 25, x.operation[]::SimpleAnnotation)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Operation)
    encoded_size = 0
    if isnothing(x.operation);
    elseif x.operation.name === :simplegate
        encoded_size += PB._encoded_size(x.operation[]::SimpleGate, 1)
    elseif x.operation.name === :customgate
        encoded_size += PB._encoded_size(x.operation[]::CustomGate, 2)
    elseif x.operation.name === :generalized
        encoded_size += PB._encoded_size(x.operation[]::Generalized, 3)
    elseif x.operation.name === :control
        encoded_size += PB._encoded_size(x.operation[]::Control, 4)
    elseif x.operation.name === :power
        encoded_size += PB._encoded_size(x.operation[]::Power, 5)
    elseif x.operation.name === :inverse
        encoded_size += PB._encoded_size(x.operation[]::Inverse, 6)
    elseif x.operation.name === :parallel
        encoded_size += PB._encoded_size(x.operation[]::Parallel, 7)
    elseif x.operation.name === :gatecall
        encoded_size += PB._encoded_size(x.operation[]::GateCall, 8)
    elseif x.operation.name === :paulistring
        encoded_size += PB._encoded_size(x.operation[]::PauliString, 9)
    elseif x.operation.name === :simplekrauschannel
        encoded_size += PB._encoded_size(x.operation[]::SimpleKrausChannel, 10)
    elseif x.operation.name === :customkrauschannel
        encoded_size += PB._encoded_size(x.operation[]::CustomKrausChannel, 11)
    elseif x.operation.name === :depolarizingchannel
        encoded_size += PB._encoded_size(x.operation[]::DepolarizingChannel, 12)
    elseif x.operation.name === :mixedunitarychannel
        encoded_size += PB._encoded_size(x.operation[]::MixedUnitaryChannel, 13)
    elseif x.operation.name === :paulichannel
        encoded_size += PB._encoded_size(x.operation[]::PauliChannel, 14)
    elseif x.operation.name === :simpleoperator
        encoded_size += PB._encoded_size(x.operation[]::SimpleOperator, 15)
    elseif x.operation.name === :customoperator
        encoded_size += PB._encoded_size(x.operation[]::CustomOperator, 16)
    elseif x.operation.name === :rescaledgate
        encoded_size += PB._encoded_size(x.operation[]::RescaledGate, 17)
    elseif x.operation.name === :simpleoperation
        encoded_size += PB._encoded_size(x.operation[]::SimpleOperation, 18)
    elseif x.operation.name === :ifstatement
        encoded_size += PB._encoded_size(x.operation[]::IfStatement, 19)
    elseif x.operation.name === :barrier
        encoded_size += PB._encoded_size(x.operation[]::Barrier, 20)
    elseif x.operation.name === :amplitude
        encoded_size += PB._encoded_size(x.operation[]::Amplitude, 21)
    elseif x.operation.name === :expectationvalue
        encoded_size += PB._encoded_size(x.operation[]::ExpectationValue, 22)
    elseif x.operation.name === :detector
        encoded_size += PB._encoded_size(x.operation[]::Detector, 23)
    elseif x.operation.name === :observableinc
        encoded_size += PB._encoded_size(x.operation[]::ObservableInclude, 24)
    elseif x.operation.name === :simpleannotation
        encoded_size += PB._encoded_size(x.operation[]::SimpleAnnotation, 25)
    end
    return encoded_size
end

struct SimpleOperator{T1<:Union{Nothing,var"##AbstractArg"}} <: var"##AbstractSimpleOperator"
    mtype::OperatorType.T
    parameters::Vector{T1}
end
PB.default_values(::Type{SimpleOperator}) = (;mtype = OperatorType.SigmaMinus, parameters = Vector{Arg}())
PB.field_numbers(::Type{SimpleOperator}) = (;mtype = 1, parameters = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SimpleOperator})
    mtype = OperatorType.SigmaMinus
    parameters = PB.BufferedVector{Arg}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            mtype = PB.decode(d, OperatorType.T)
        elseif field_number == 2
            PB.decode!(d, parameters)
        else
            PB.skip(d, wire_type)
        end
    end
    return SimpleOperator(mtype, parameters[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SimpleOperator)
    initpos = position(e.io)
    x.mtype != OperatorType.SigmaMinus && PB.encode(e, 1, x.mtype)
    !isempty(x.parameters) && PB.encode(e, 2, x.parameters)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SimpleOperator)
    encoded_size = 0
    x.mtype != OperatorType.SigmaMinus && (encoded_size += PB._encoded_size(x.mtype, 1))
    !isempty(x.parameters) && (encoded_size += PB._encoded_size(x.parameters, 2))
    return encoded_size
end

struct Operator <: var"##AbstractOperator"
    operator::Union{Nothing,OneOf{<:Union{var"##AbstractSimpleGate",var"##AbstractCustomGate",var"##AbstractGeneralized",var"##AbstractControl",var"##AbstractPower",var"##AbstractInverse",var"##AbstractParallel",var"##AbstractGateCall",PauliString,var"##AbstractSimpleOperator",var"##AbstractCustomOperator",var"##AbstractRescaledGate"}}}
end
PB.oneof_field_types(::Type{Operator}) = (;
    operator = (;simplegate=SimpleGate, customgate=CustomGate, generalized=Generalized, control=Control, power=Power, inverse=Inverse, parallel=Parallel, gatecall=GateCall, paulistring=PauliString, simpleoperator=SimpleOperator, customoperator=CustomOperator, rescaledgate=RescaledGate),
)
PB.default_values(::Type{Operator}) = (;simplegate = nothing, customgate = nothing, generalized = nothing, control = nothing, power = nothing, inverse = nothing, parallel = nothing, gatecall = nothing, paulistring = nothing, simpleoperator = nothing, customoperator = nothing, rescaledgate = nothing)
PB.field_numbers(::Type{Operator}) = (;simplegate = 1, customgate = 2, generalized = 3, control = 4, power = 5, inverse = 6, parallel = 7, gatecall = 8, paulistring = 9, simpleoperator = 10, customoperator = 11, rescaledgate = 12)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Operator})
    operator = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            operator = OneOf(:simplegate, PB.decode(d, Ref{SimpleGate}))
        elseif field_number == 2
            operator = OneOf(:customgate, PB.decode(d, Ref{CustomGate}))
        elseif field_number == 3
            operator = OneOf(:generalized, PB.decode(d, Ref{Generalized}))
        elseif field_number == 4
            operator = OneOf(:control, PB.decode(d, Ref{Control}))
        elseif field_number == 5
            operator = OneOf(:power, PB.decode(d, Ref{Power}))
        elseif field_number == 6
            operator = OneOf(:inverse, PB.decode(d, Ref{Inverse}))
        elseif field_number == 7
            operator = OneOf(:parallel, PB.decode(d, Ref{Parallel}))
        elseif field_number == 8
            operator = OneOf(:gatecall, PB.decode(d, Ref{GateCall}))
        elseif field_number == 9
            operator = OneOf(:paulistring, PB.decode(d, Ref{PauliString}))
        elseif field_number == 10
            operator = OneOf(:simpleoperator, PB.decode(d, Ref{SimpleOperator}))
        elseif field_number == 11
            operator = OneOf(:customoperator, PB.decode(d, Ref{CustomOperator}))
        elseif field_number == 12
            operator = OneOf(:rescaledgate, PB.decode(d, Ref{RescaledGate}))
        else
            PB.skip(d, wire_type)
        end
    end
    return Operator(operator)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Operator)
    initpos = position(e.io)
    if isnothing(x.operator);
    elseif x.operator.name === :simplegate
        PB.encode(e, 1, x.operator[]::SimpleGate)
    elseif x.operator.name === :customgate
        PB.encode(e, 2, x.operator[]::CustomGate)
    elseif x.operator.name === :generalized
        PB.encode(e, 3, x.operator[]::Generalized)
    elseif x.operator.name === :control
        PB.encode(e, 4, x.operator[]::Control)
    elseif x.operator.name === :power
        PB.encode(e, 5, x.operator[]::Power)
    elseif x.operator.name === :inverse
        PB.encode(e, 6, x.operator[]::Inverse)
    elseif x.operator.name === :parallel
        PB.encode(e, 7, x.operator[]::Parallel)
    elseif x.operator.name === :gatecall
        PB.encode(e, 8, x.operator[]::GateCall)
    elseif x.operator.name === :paulistring
        PB.encode(e, 9, x.operator[]::PauliString)
    elseif x.operator.name === :simpleoperator
        PB.encode(e, 10, x.operator[]::SimpleOperator)
    elseif x.operator.name === :customoperator
        PB.encode(e, 11, x.operator[]::CustomOperator)
    elseif x.operator.name === :rescaledgate
        PB.encode(e, 12, x.operator[]::RescaledGate)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Operator)
    encoded_size = 0
    if isnothing(x.operator);
    elseif x.operator.name === :simplegate
        encoded_size += PB._encoded_size(x.operator[]::SimpleGate, 1)
    elseif x.operator.name === :customgate
        encoded_size += PB._encoded_size(x.operator[]::CustomGate, 2)
    elseif x.operator.name === :generalized
        encoded_size += PB._encoded_size(x.operator[]::Generalized, 3)
    elseif x.operator.name === :control
        encoded_size += PB._encoded_size(x.operator[]::Control, 4)
    elseif x.operator.name === :power
        encoded_size += PB._encoded_size(x.operator[]::Power, 5)
    elseif x.operator.name === :inverse
        encoded_size += PB._encoded_size(x.operator[]::Inverse, 6)
    elseif x.operator.name === :parallel
        encoded_size += PB._encoded_size(x.operator[]::Parallel, 7)
    elseif x.operator.name === :gatecall
        encoded_size += PB._encoded_size(x.operator[]::GateCall, 8)
    elseif x.operator.name === :paulistring
        encoded_size += PB._encoded_size(x.operator[]::PauliString, 9)
    elseif x.operator.name === :simpleoperator
        encoded_size += PB._encoded_size(x.operator[]::SimpleOperator, 10)
    elseif x.operator.name === :customoperator
        encoded_size += PB._encoded_size(x.operator[]::CustomOperator, 11)
    elseif x.operator.name === :rescaledgate
        encoded_size += PB._encoded_size(x.operator[]::RescaledGate, 12)
    end
    return encoded_size
end

struct CustomOperator{T1<:Union{Nothing,var"##AbstractComplexArg"}} <: var"##AbstractCustomOperator"
    numqubits::Int64
    matrix::Vector{T1}
end
PB.default_values(::Type{CustomOperator}) = (;numqubits = zero(Int64), matrix = Vector{ComplexArg}())
PB.field_numbers(::Type{CustomOperator}) = (;numqubits = 1, matrix = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CustomOperator})
    numqubits = zero(Int64)
    matrix = PB.BufferedVector{ComplexArg}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            numqubits = PB.decode(d, Int64)
        elseif field_number == 2
            PB.decode!(d, matrix)
        else
            PB.skip(d, wire_type)
        end
    end
    return CustomOperator(numqubits, matrix[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CustomOperator)
    initpos = position(e.io)
    x.numqubits != zero(Int64) && PB.encode(e, 1, x.numqubits)
    !isempty(x.matrix) && PB.encode(e, 2, x.matrix)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CustomOperator)
    encoded_size = 0
    x.numqubits != zero(Int64) && (encoded_size += PB._encoded_size(x.numqubits, 1))
    !isempty(x.matrix) && (encoded_size += PB._encoded_size(x.matrix, 2))
    return encoded_size
end

struct Control{T1<:Union{Nothing,var"##AbstractGate"}} <: var"##AbstractControl"
    operation::T1
    numcontrols::Int64
end
PB.default_values(::Type{Control}) = (;operation = nothing, numcontrols = zero(Int64))
PB.field_numbers(::Type{Control}) = (;operation = 1, numcontrols = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Control})
    operation = Ref{Union{Nothing,Gate}}(nothing)
    numcontrols = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, operation)
        elseif field_number == 2
            numcontrols = PB.decode(d, Int64)
        else
            PB.skip(d, wire_type)
        end
    end
    return Control(operation[], numcontrols)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Control)
    initpos = position(e.io)
    !isnothing(x.operation) && PB.encode(e, 1, x.operation)
    x.numcontrols != zero(Int64) && PB.encode(e, 2, x.numcontrols)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Control)
    encoded_size = 0
    !isnothing(x.operation) && (encoded_size += PB._encoded_size(x.operation, 1))
    x.numcontrols != zero(Int64) && (encoded_size += PB._encoded_size(x.numcontrols, 2))
    return encoded_size
end

struct Parallel{T1<:Union{Nothing,var"##AbstractGate"}} <: var"##AbstractParallel"
    operation::T1
    numrepeats::Int64
end
PB.default_values(::Type{Parallel}) = (;operation = nothing, numrepeats = zero(Int64))
PB.field_numbers(::Type{Parallel}) = (;operation = 1, numrepeats = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Parallel})
    operation = Ref{Union{Nothing,Gate}}(nothing)
    numrepeats = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, operation)
        elseif field_number == 2
            numrepeats = PB.decode(d, Int64)
        else
            PB.skip(d, wire_type)
        end
    end
    return Parallel(operation[], numrepeats)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Parallel)
    initpos = position(e.io)
    !isnothing(x.operation) && PB.encode(e, 1, x.operation)
    x.numrepeats != zero(Int64) && PB.encode(e, 2, x.numrepeats)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Parallel)
    encoded_size = 0
    !isnothing(x.operation) && (encoded_size += PB._encoded_size(x.operation, 1))
    x.numrepeats != zero(Int64) && (encoded_size += PB._encoded_size(x.numrepeats, 2))
    return encoded_size
end

struct MixedUnitaryChannel <: var"##AbstractMixedUnitaryChannel"
    operators::Vector{<:RescaledGate}
end
PB.default_values(::Type{MixedUnitaryChannel}) = (;operators = Vector{RescaledGate}())
PB.field_numbers(::Type{MixedUnitaryChannel}) = (;operators = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MixedUnitaryChannel})
    operators = PB.BufferedVector{RescaledGate}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, operators)
        else
            PB.skip(d, wire_type)
        end
    end
    return MixedUnitaryChannel(operators[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MixedUnitaryChannel)
    initpos = position(e.io)
    !isempty(x.operators) && PB.encode(e, 1, x.operators)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MixedUnitaryChannel)
    encoded_size = 0
    !isempty(x.operators) && (encoded_size += PB._encoded_size(x.operators, 1))
    return encoded_size
end

struct Gate <: var"##AbstractGate"
    gate::Union{Nothing,OneOf{<:Union{var"##AbstractSimpleGate",var"##AbstractCustomGate",var"##AbstractGeneralized",var"##AbstractControl",var"##AbstractPower",var"##AbstractInverse",var"##AbstractParallel",var"##AbstractGateCall",PauliString}}}
end
PB.oneof_field_types(::Type{Gate}) = (;
    gate = (;simplegate=SimpleGate, customgate=CustomGate, generalized=Generalized, control=Control, power=Power, inverse=Inverse, parallel=Parallel, gatecall=GateCall, paulistring=PauliString),
)
PB.default_values(::Type{Gate}) = (;simplegate = nothing, customgate = nothing, generalized = nothing, control = nothing, power = nothing, inverse = nothing, parallel = nothing, gatecall = nothing, paulistring = nothing)
PB.field_numbers(::Type{Gate}) = (;simplegate = 1, customgate = 2, generalized = 3, control = 4, power = 5, inverse = 6, parallel = 7, gatecall = 8, paulistring = 9)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Gate})
    gate = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            gate = OneOf(:simplegate, PB.decode(d, Ref{SimpleGate}))
        elseif field_number == 2
            gate = OneOf(:customgate, PB.decode(d, Ref{CustomGate}))
        elseif field_number == 3
            gate = OneOf(:generalized, PB.decode(d, Ref{Generalized}))
        elseif field_number == 4
            gate = OneOf(:control, PB.decode(d, Ref{Control}))
        elseif field_number == 5
            gate = OneOf(:power, PB.decode(d, Ref{Power}))
        elseif field_number == 6
            gate = OneOf(:inverse, PB.decode(d, Ref{Inverse}))
        elseif field_number == 7
            gate = OneOf(:parallel, PB.decode(d, Ref{Parallel}))
        elseif field_number == 8
            gate = OneOf(:gatecall, PB.decode(d, Ref{GateCall}))
        elseif field_number == 9
            gate = OneOf(:paulistring, PB.decode(d, Ref{PauliString}))
        else
            PB.skip(d, wire_type)
        end
    end
    return Gate(gate)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Gate)
    initpos = position(e.io)
    if isnothing(x.gate);
    elseif x.gate.name === :simplegate
        PB.encode(e, 1, x.gate[]::SimpleGate)
    elseif x.gate.name === :customgate
        PB.encode(e, 2, x.gate[]::CustomGate)
    elseif x.gate.name === :generalized
        PB.encode(e, 3, x.gate[]::Generalized)
    elseif x.gate.name === :control
        PB.encode(e, 4, x.gate[]::Control)
    elseif x.gate.name === :power
        PB.encode(e, 5, x.gate[]::Power)
    elseif x.gate.name === :inverse
        PB.encode(e, 6, x.gate[]::Inverse)
    elseif x.gate.name === :parallel
        PB.encode(e, 7, x.gate[]::Parallel)
    elseif x.gate.name === :gatecall
        PB.encode(e, 8, x.gate[]::GateCall)
    elseif x.gate.name === :paulistring
        PB.encode(e, 9, x.gate[]::PauliString)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Gate)
    encoded_size = 0
    if isnothing(x.gate);
    elseif x.gate.name === :simplegate
        encoded_size += PB._encoded_size(x.gate[]::SimpleGate, 1)
    elseif x.gate.name === :customgate
        encoded_size += PB._encoded_size(x.gate[]::CustomGate, 2)
    elseif x.gate.name === :generalized
        encoded_size += PB._encoded_size(x.gate[]::Generalized, 3)
    elseif x.gate.name === :control
        encoded_size += PB._encoded_size(x.gate[]::Control, 4)
    elseif x.gate.name === :power
        encoded_size += PB._encoded_size(x.gate[]::Power, 5)
    elseif x.gate.name === :inverse
        encoded_size += PB._encoded_size(x.gate[]::Inverse, 6)
    elseif x.gate.name === :parallel
        encoded_size += PB._encoded_size(x.gate[]::Parallel, 7)
    elseif x.gate.name === :gatecall
        encoded_size += PB._encoded_size(x.gate[]::GateCall, 8)
    elseif x.gate.name === :paulistring
        encoded_size += PB._encoded_size(x.gate[]::PauliString, 9)
    end
    return encoded_size
end

struct KrausChannel <: var"##AbstractKrausChannel"
    krauschannel::Union{Nothing,OneOf{<:Union{var"##AbstractSimpleKrausChannel",var"##AbstractCustomKrausChannel",var"##AbstractDepolarizingChannel",var"##AbstractMixedUnitaryChannel",var"##AbstractPauliChannel"}}}
end
PB.oneof_field_types(::Type{KrausChannel}) = (;
    krauschannel = (;simplekrauschannel=SimpleKrausChannel, customkrauschannel=CustomKrausChannel, depolarizingchannel=DepolarizingChannel, mixedunitarychannel=MixedUnitaryChannel, paulichannel=PauliChannel),
)
PB.default_values(::Type{KrausChannel}) = (;simplekrauschannel = nothing, customkrauschannel = nothing, depolarizingchannel = nothing, mixedunitarychannel = nothing, paulichannel = nothing)
PB.field_numbers(::Type{KrausChannel}) = (;simplekrauschannel = 1, customkrauschannel = 2, depolarizingchannel = 3, mixedunitarychannel = 4, paulichannel = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:KrausChannel})
    krauschannel = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            krauschannel = OneOf(:simplekrauschannel, PB.decode(d, Ref{SimpleKrausChannel}))
        elseif field_number == 2
            krauschannel = OneOf(:customkrauschannel, PB.decode(d, Ref{CustomKrausChannel}))
        elseif field_number == 3
            krauschannel = OneOf(:depolarizingchannel, PB.decode(d, Ref{DepolarizingChannel}))
        elseif field_number == 4
            krauschannel = OneOf(:mixedunitarychannel, PB.decode(d, Ref{MixedUnitaryChannel}))
        elseif field_number == 5
            krauschannel = OneOf(:paulichannel, PB.decode(d, Ref{PauliChannel}))
        else
            PB.skip(d, wire_type)
        end
    end
    return KrausChannel(krauschannel)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::KrausChannel)
    initpos = position(e.io)
    if isnothing(x.krauschannel);
    elseif x.krauschannel.name === :simplekrauschannel
        PB.encode(e, 1, x.krauschannel[]::SimpleKrausChannel)
    elseif x.krauschannel.name === :customkrauschannel
        PB.encode(e, 2, x.krauschannel[]::CustomKrausChannel)
    elseif x.krauschannel.name === :depolarizingchannel
        PB.encode(e, 3, x.krauschannel[]::DepolarizingChannel)
    elseif x.krauschannel.name === :mixedunitarychannel
        PB.encode(e, 4, x.krauschannel[]::MixedUnitaryChannel)
    elseif x.krauschannel.name === :paulichannel
        PB.encode(e, 5, x.krauschannel[]::PauliChannel)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::KrausChannel)
    encoded_size = 0
    if isnothing(x.krauschannel);
    elseif x.krauschannel.name === :simplekrauschannel
        encoded_size += PB._encoded_size(x.krauschannel[]::SimpleKrausChannel, 1)
    elseif x.krauschannel.name === :customkrauschannel
        encoded_size += PB._encoded_size(x.krauschannel[]::CustomKrausChannel, 2)
    elseif x.krauschannel.name === :depolarizingchannel
        encoded_size += PB._encoded_size(x.krauschannel[]::DepolarizingChannel, 3)
    elseif x.krauschannel.name === :mixedunitarychannel
        encoded_size += PB._encoded_size(x.krauschannel[]::MixedUnitaryChannel, 4)
    elseif x.krauschannel.name === :paulichannel
        encoded_size += PB._encoded_size(x.krauschannel[]::PauliChannel, 5)
    end
    return encoded_size
end

struct PauliChannel{T1<:Union{Nothing,var"##AbstractArg"}} <: var"##AbstractPauliChannel"
    probabilities::Vector{T1}
    paulistrings::Vector{PauliString}
end
PB.default_values(::Type{PauliChannel}) = (;probabilities = Vector{Arg}(), paulistrings = Vector{PauliString}())
PB.field_numbers(::Type{PauliChannel}) = (;probabilities = 1, paulistrings = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:PauliChannel})
    probabilities = PB.BufferedVector{Arg}()
    paulistrings = PB.BufferedVector{PauliString}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, probabilities)
        elseif field_number == 2
            PB.decode!(d, paulistrings)
        else
            PB.skip(d, wire_type)
        end
    end
    return PauliChannel(probabilities[], paulistrings[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::PauliChannel)
    initpos = position(e.io)
    !isempty(x.probabilities) && PB.encode(e, 1, x.probabilities)
    !isempty(x.paulistrings) && PB.encode(e, 2, x.paulistrings)
    return position(e.io) - initpos
end
function PB._encoded_size(x::PauliChannel)
    encoded_size = 0
    !isempty(x.probabilities) && (encoded_size += PB._encoded_size(x.probabilities, 1))
    !isempty(x.paulistrings) && (encoded_size += PB._encoded_size(x.paulistrings, 2))
    return encoded_size
end

struct SimpleOperation{T1<:Union{Nothing,var"##AbstractArg"}} <: var"##AbstractSimpleOperation"
    mtype::OperationType.T
    parameters::Vector{T1}
end
PB.default_values(::Type{SimpleOperation}) = (;mtype = OperationType.MeasureX, parameters = Vector{Arg}())
PB.field_numbers(::Type{SimpleOperation}) = (;mtype = 1, parameters = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SimpleOperation})
    mtype = OperationType.MeasureX
    parameters = PB.BufferedVector{Arg}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            mtype = PB.decode(d, OperationType.T)
        elseif field_number == 2
            PB.decode!(d, parameters)
        else
            PB.skip(d, wire_type)
        end
    end
    return SimpleOperation(mtype, parameters[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SimpleOperation)
    initpos = position(e.io)
    x.mtype != OperationType.MeasureX && PB.encode(e, 1, x.mtype)
    !isempty(x.parameters) && PB.encode(e, 2, x.parameters)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SimpleOperation)
    encoded_size = 0
    x.mtype != OperationType.MeasureX && (encoded_size += PB._encoded_size(x.mtype, 1))
    !isempty(x.parameters) && (encoded_size += PB._encoded_size(x.parameters, 2))
    return encoded_size
end

struct Inverse <: var"##AbstractInverse"
    operation::Union{Nothing,Gate}
end
PB.default_values(::Type{Inverse}) = (;operation = nothing)
PB.field_numbers(::Type{Inverse}) = (;operation = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Inverse})
    operation = Ref{Union{Nothing,Gate}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, operation)
        else
            PB.skip(d, wire_type)
        end
    end
    return Inverse(operation[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Inverse)
    initpos = position(e.io)
    !isnothing(x.operation) && PB.encode(e, 1, x.operation)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Inverse)
    encoded_size = 0
    !isnothing(x.operation) && (encoded_size += PB._encoded_size(x.operation, 1))
    return encoded_size
end

struct DepolarizingChannel{T1<:Union{Nothing,var"##AbstractArg"}} <: var"##AbstractDepolarizingChannel"
    numqubits::Int64
    probability::T1
end
PB.default_values(::Type{DepolarizingChannel}) = (;numqubits = zero(Int64), probability = nothing)
PB.field_numbers(::Type{DepolarizingChannel}) = (;numqubits = 1, probability = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DepolarizingChannel})
    numqubits = zero(Int64)
    probability = Ref{Union{Nothing,Arg}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            numqubits = PB.decode(d, Int64)
        elseif field_number == 2
            PB.decode!(d, probability)
        else
            PB.skip(d, wire_type)
        end
    end
    return DepolarizingChannel(numqubits, probability[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DepolarizingChannel)
    initpos = position(e.io)
    x.numqubits != zero(Int64) && PB.encode(e, 1, x.numqubits)
    !isnothing(x.probability) && PB.encode(e, 2, x.probability)
    return position(e.io) - initpos
end
function PB._encoded_size(x::DepolarizingChannel)
    encoded_size = 0
    x.numqubits != zero(Int64) && (encoded_size += PB._encoded_size(x.numqubits, 1))
    !isnothing(x.probability) && (encoded_size += PB._encoded_size(x.probability, 2))
    return encoded_size
end

struct SimpleKrausChannel{T1<:Union{Nothing,var"##AbstractArg"}} <: var"##AbstractSimpleKrausChannel"
    mtype::KrausChannelType.T
    parameters::Vector{T1}
end
PB.default_values(::Type{SimpleKrausChannel}) = (;mtype = KrausChannelType.ResetX, parameters = Vector{Arg}())
PB.field_numbers(::Type{SimpleKrausChannel}) = (;mtype = 1, parameters = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SimpleKrausChannel})
    mtype = KrausChannelType.ResetX
    parameters = PB.BufferedVector{Arg}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            mtype = PB.decode(d, KrausChannelType.T)
        elseif field_number == 2
            PB.decode!(d, parameters)
        else
            PB.skip(d, wire_type)
        end
    end
    return SimpleKrausChannel(mtype, parameters[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SimpleKrausChannel)
    initpos = position(e.io)
    x.mtype != KrausChannelType.ResetX && PB.encode(e, 1, x.mtype)
    !isempty(x.parameters) && PB.encode(e, 2, x.parameters)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SimpleKrausChannel)
    encoded_size = 0
    x.mtype != KrausChannelType.ResetX && (encoded_size += PB._encoded_size(x.mtype, 1))
    !isempty(x.parameters) && (encoded_size += PB._encoded_size(x.parameters, 2))
    return encoded_size
end

struct ComplexArg{T1<:Union{Nothing,var"##AbstractArg"},T2<:Union{Nothing,var"##AbstractArg"}} <: var"##AbstractComplexArg"
    real::T1
    imag::T2
end
PB.default_values(::Type{ComplexArg}) = (;real = nothing, imag = nothing)
PB.field_numbers(::Type{ComplexArg}) = (;real = 1, imag = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ComplexArg})
    real = Ref{Union{Nothing,Arg}}(nothing)
    imag = Ref{Union{Nothing,Arg}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, real)
        elseif field_number == 2
            PB.decode!(d, imag)
        else
            PB.skip(d, wire_type)
        end
    end
    return ComplexArg(real[], imag[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ComplexArg)
    initpos = position(e.io)
    !isnothing(x.real) && PB.encode(e, 1, x.real)
    !isnothing(x.imag) && PB.encode(e, 2, x.imag)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ComplexArg)
    encoded_size = 0
    !isnothing(x.real) && (encoded_size += PB._encoded_size(x.real, 1))
    !isnothing(x.imag) && (encoded_size += PB._encoded_size(x.imag, 2))
    return encoded_size
end

struct Power <: var"##AbstractPower"
    operation::Union{Nothing,Gate}
    power::Union{Nothing,OneOf{<:Union{Float64,Rational,Int64}}}
end
PB.oneof_field_types(::Type{Power}) = (;
    power = (;double_val=Float64, rational_val=Rational, int_val=Int64),
)
PB.default_values(::Type{Power}) = (;operation = nothing, double_val = zero(Float64), rational_val = nothing, int_val = zero(Int64))
PB.field_numbers(::Type{Power}) = (;operation = 1, double_val = 2, rational_val = 3, int_val = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Power})
    operation = Ref{Union{Nothing,Gate}}(nothing)
    power = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, operation)
        elseif field_number == 2
            power = OneOf(:double_val, PB.decode(d, Float64))
        elseif field_number == 3
            power = OneOf(:rational_val, PB.decode(d, Ref{Rational}))
        elseif field_number == 4
            power = OneOf(:int_val, PB.decode(d, Int64))
        else
            PB.skip(d, wire_type)
        end
    end
    return Power(operation[], power)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Power)
    initpos = position(e.io)
    !isnothing(x.operation) && PB.encode(e, 1, x.operation)
    if isnothing(x.power);
    elseif x.power.name === :double_val
        PB.encode(e, 2, x.power[]::Float64)
    elseif x.power.name === :rational_val
        PB.encode(e, 3, x.power[]::Rational)
    elseif x.power.name === :int_val
        PB.encode(e, 4, x.power[]::Int64)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Power)
    encoded_size = 0
    !isnothing(x.operation) && (encoded_size += PB._encoded_size(x.operation, 1))
    if isnothing(x.power);
    elseif x.power.name === :double_val
        encoded_size += PB._encoded_size(x.power[]::Float64, 2)
    elseif x.power.name === :rational_val
        encoded_size += PB._encoded_size(x.power[]::Rational, 3)
    elseif x.power.name === :int_val
        encoded_size += PB._encoded_size(x.power[]::Int64, 4)
    end
    return encoded_size
end

struct Instruction <: var"##AbstractInstruction"
    operation::Union{Nothing,Operation}
    qtargets::Vector{Int64}
    ctargets::Vector{Int64}
    ztargets::Vector{Int64}
end
PB.default_values(::Type{Instruction}) = (;operation = nothing, qtargets = Vector{Int64}(), ctargets = Vector{Int64}(), ztargets = Vector{Int64}())
PB.field_numbers(::Type{Instruction}) = (;operation = 1, qtargets = 2, ctargets = 3, ztargets = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Instruction})
    operation = Ref{Union{Nothing,Operation}}(nothing)
    qtargets = PB.BufferedVector{Int64}()
    ctargets = PB.BufferedVector{Int64}()
    ztargets = PB.BufferedVector{Int64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, operation)
        elseif field_number == 2
            PB.decode!(d, wire_type, qtargets)
        elseif field_number == 3
            PB.decode!(d, wire_type, ctargets)
        elseif field_number == 4
            PB.decode!(d, wire_type, ztargets)
        else
            PB.skip(d, wire_type)
        end
    end
    return Instruction(operation[], qtargets[], ctargets[], ztargets[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Instruction)
    initpos = position(e.io)
    !isnothing(x.operation) && PB.encode(e, 1, x.operation)
    !isempty(x.qtargets) && PB.encode(e, 2, x.qtargets)
    !isempty(x.ctargets) && PB.encode(e, 3, x.ctargets)
    !isempty(x.ztargets) && PB.encode(e, 4, x.ztargets)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Instruction)
    encoded_size = 0
    !isnothing(x.operation) && (encoded_size += PB._encoded_size(x.operation, 1))
    !isempty(x.qtargets) && (encoded_size += PB._encoded_size(x.qtargets, 2))
    !isempty(x.ctargets) && (encoded_size += PB._encoded_size(x.ctargets, 3))
    !isempty(x.ztargets) && (encoded_size += PB._encoded_size(x.ztargets, 4))
    return encoded_size
end

struct Generalized{T1<:Union{Nothing,var"##AbstractArg"}} <: var"##AbstractGeneralized"
    name::String
    args::Vector{T1}
    qregsizes::Vector{Int64}
end
PB.default_values(::Type{Generalized}) = (;name = "", args = Vector{Arg}(), qregsizes = Vector{Int64}())
PB.field_numbers(::Type{Generalized}) = (;name = 1, args = 2, qregsizes = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Generalized})
    name = ""
    args = PB.BufferedVector{Arg}()
    qregsizes = PB.BufferedVector{Int64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, args)
        elseif field_number == 3
            PB.decode!(d, wire_type, qregsizes)
        else
            PB.skip(d, wire_type)
        end
    end
    return Generalized(name, args[], qregsizes[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Generalized)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.args) && PB.encode(e, 2, x.args)
    !isempty(x.qregsizes) && PB.encode(e, 3, x.qregsizes)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Generalized)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.args) && (encoded_size += PB._encoded_size(x.args, 2))
    !isempty(x.qregsizes) && (encoded_size += PB._encoded_size(x.qregsizes, 3))
    return encoded_size
end

struct SimpleGate{T1<:Union{Nothing,var"##AbstractArg"}} <: var"##AbstractSimpleGate"
    mtype::GateType.T
    parameters::Vector{T1}
end
PB.default_values(::Type{SimpleGate}) = (;mtype = GateType.GateID, parameters = Vector{Arg}())
PB.field_numbers(::Type{SimpleGate}) = (;mtype = 1, parameters = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SimpleGate})
    mtype = GateType.GateID
    parameters = PB.BufferedVector{Arg}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            mtype = PB.decode(d, GateType.T)
        elseif field_number == 2
            PB.decode!(d, parameters)
        else
            PB.skip(d, wire_type)
        end
    end
    return SimpleGate(mtype, parameters[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SimpleGate)
    initpos = position(e.io)
    x.mtype != GateType.GateID && PB.encode(e, 1, x.mtype)
    !isempty(x.parameters) && PB.encode(e, 2, x.parameters)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SimpleGate)
    encoded_size = 0
    x.mtype != GateType.GateID && (encoded_size += PB._encoded_size(x.mtype, 1))
    !isempty(x.parameters) && (encoded_size += PB._encoded_size(x.parameters, 2))
    return encoded_size
end

struct Circuit <: var"##AbstractCircuit"
    instructions::Vector{<:Instruction}
end
PB.default_values(::Type{Circuit}) = (;instructions = Vector{Instruction}())
PB.field_numbers(::Type{Circuit}) = (;instructions = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Circuit})
    instructions = PB.BufferedVector{Instruction}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, instructions)
        else
            PB.skip(d, wire_type)
        end
    end
    return Circuit(instructions[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Circuit)
    initpos = position(e.io)
    !isempty(x.instructions) && PB.encode(e, 1, x.instructions)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Circuit)
    encoded_size = 0
    !isempty(x.instructions) && (encoded_size += PB._encoded_size(x.instructions, 1))
    return encoded_size
end

struct GateCall{T2<:Union{Nothing,var"##AbstractArg"},T1<:Union{Nothing,var"##AbstractGateDecl"}} <: var"##AbstractGateCall"
    decl::T1
    args::Vector{T2}
end
PB.default_values(::Type{GateCall}) = (;decl = nothing, args = Vector{Arg}())
PB.field_numbers(::Type{GateCall}) = (;decl = 1, args = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GateCall})
    decl = Ref{Union{Nothing,GateDecl}}(nothing)
    args = PB.BufferedVector{Arg}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, decl)
        elseif field_number == 2
            PB.decode!(d, args)
        else
            PB.skip(d, wire_type)
        end
    end
    return GateCall(decl[], args[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GateCall)
    initpos = position(e.io)
    !isnothing(x.decl) && PB.encode(e, 1, x.decl)
    !isempty(x.args) && PB.encode(e, 2, x.args)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GateCall)
    encoded_size = 0
    !isnothing(x.decl) && (encoded_size += PB._encoded_size(x.decl, 1))
    !isempty(x.args) && (encoded_size += PB._encoded_size(x.args, 2))
    return encoded_size
end

struct Arg <: var"##AbstractArg"
    arg::Union{Nothing,OneOf{<:Union{ArgValue,Symbol,var"##AbstractArgFunction",Irrational.T}}}
end
PB.oneof_field_types(::Type{Arg}) = (;
    arg = (;argvalue_value=ArgValue, symbol_value=Symbol, argfunction_value=ArgFunction, irrational_value=Irrational.T),
)
PB.default_values(::Type{Arg}) = (;argvalue_value = nothing, symbol_value = nothing, argfunction_value = nothing, irrational_value = Irrational.PI)
PB.field_numbers(::Type{Arg}) = (;argvalue_value = 1, symbol_value = 2, argfunction_value = 3, irrational_value = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Arg})
    arg = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            arg = OneOf(:argvalue_value, PB.decode(d, Ref{ArgValue}))
        elseif field_number == 2
            arg = OneOf(:symbol_value, PB.decode(d, Ref{Symbol}))
        elseif field_number == 3
            arg = OneOf(:argfunction_value, PB.decode(d, Ref{ArgFunction}))
        elseif field_number == 4
            arg = OneOf(:irrational_value, PB.decode(d, Irrational.T))
        else
            PB.skip(d, wire_type)
        end
    end
    return Arg(arg)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Arg)
    initpos = position(e.io)
    if isnothing(x.arg);
    elseif x.arg.name === :argvalue_value
        PB.encode(e, 1, x.arg[]::ArgValue)
    elseif x.arg.name === :symbol_value
        PB.encode(e, 2, x.arg[]::Symbol)
    elseif x.arg.name === :argfunction_value
        PB.encode(e, 3, x.arg[]::ArgFunction)
    elseif x.arg.name === :irrational_value
        PB.encode(e, 4, x.arg[]::Irrational.T)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Arg)
    encoded_size = 0
    if isnothing(x.arg);
    elseif x.arg.name === :argvalue_value
        encoded_size += PB._encoded_size(x.arg[]::ArgValue, 1)
    elseif x.arg.name === :symbol_value
        encoded_size += PB._encoded_size(x.arg[]::Symbol, 2)
    elseif x.arg.name === :argfunction_value
        encoded_size += PB._encoded_size(x.arg[]::ArgFunction, 3)
    elseif x.arg.name === :irrational_value
        encoded_size += PB._encoded_size(x.arg[]::Irrational.T, 4)
    end
    return encoded_size
end

struct GateDecl <: var"##AbstractGateDecl"
    name::String
    args::Vector{Symbol}
    instructions::Vector{<:Instruction}
end
PB.default_values(::Type{GateDecl}) = (;name = "", args = Vector{Symbol}(), instructions = Vector{Instruction}())
PB.field_numbers(::Type{GateDecl}) = (;name = 1, args = 2, instructions = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GateDecl})
    name = ""
    args = PB.BufferedVector{Symbol}()
    instructions = PB.BufferedVector{Instruction}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, args)
        elseif field_number == 3
            PB.decode!(d, instructions)
        else
            PB.skip(d, wire_type)
        end
    end
    return GateDecl(name, args[], instructions[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GateDecl)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.args) && PB.encode(e, 2, x.args)
    !isempty(x.instructions) && PB.encode(e, 3, x.instructions)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GateDecl)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.args) && (encoded_size += PB._encoded_size(x.args, 2))
    !isempty(x.instructions) && (encoded_size += PB._encoded_size(x.instructions, 3))
    return encoded_size
end
end # module