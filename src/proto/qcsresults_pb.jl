# Autogenerated using ProtoBuf.jl v1.0.14 on 2023-11-06T03:09:49.188
# original file: /home/gdmsl/QPerfect/Code/MimiqCircuitsBase.jl/src/proto/qcsresults.proto (proto3 syntax)

module qcsresults_pb

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export ComplexDouble, BitVector, ComplexVector, AmplitudeEntry, QCSResults

struct ComplexDouble
    real::Float64
    imag::Float64
end
PB.default_values(::Type{ComplexDouble}) = (;real = zero(Float64), imag = zero(Float64))
PB.field_numbers(::Type{ComplexDouble}) = (;real = 1, imag = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ComplexDouble})
    real = zero(Float64)
    imag = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            real = PB.decode(d, Float64)
        elseif field_number == 2
            imag = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return ComplexDouble(real, imag)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ComplexDouble)
    initpos = position(e.io)
    x.real != zero(Float64) && PB.encode(e, 1, x.real)
    x.imag != zero(Float64) && PB.encode(e, 2, x.imag)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ComplexDouble)
    encoded_size = 0
    x.real != zero(Float64) && (encoded_size += PB._encoded_size(x.real, 1))
    x.imag != zero(Float64) && (encoded_size += PB._encoded_size(x.imag, 2))
    return encoded_size
end

struct BitVector
    len::Int64
    data::Vector{UInt8}
end
PB.default_values(::Type{BitVector}) = (;len = zero(Int64), data = UInt8[])
PB.field_numbers(::Type{BitVector}) = (;len = 1, data = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:BitVector})
    len = zero(Int64)
    data = UInt8[]
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            len = PB.decode(d, Int64)
        elseif field_number == 2
            data = PB.decode(d, Vector{UInt8})
        else
            PB.skip(d, wire_type)
        end
    end
    return BitVector(len, data)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::BitVector)
    initpos = position(e.io)
    x.len != zero(Int64) && PB.encode(e, 1, x.len)
    !isempty(x.data) && PB.encode(e, 2, x.data)
    return position(e.io) - initpos
end
function PB._encoded_size(x::BitVector)
    encoded_size = 0
    x.len != zero(Int64) && (encoded_size += PB._encoded_size(x.len, 1))
    !isempty(x.data) && (encoded_size += PB._encoded_size(x.data, 2))
    return encoded_size
end

struct ComplexVector
    data::Vector{ComplexDouble}
end
PB.default_values(::Type{ComplexVector}) = (;data = Vector{ComplexDouble}())
PB.field_numbers(::Type{ComplexVector}) = (;data = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ComplexVector})
    data = PB.BufferedVector{ComplexDouble}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, data)
        else
            PB.skip(d, wire_type)
        end
    end
    return ComplexVector(data[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ComplexVector)
    initpos = position(e.io)
    !isempty(x.data) && PB.encode(e, 1, x.data)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ComplexVector)
    encoded_size = 0
    !isempty(x.data) && (encoded_size += PB._encoded_size(x.data, 1))
    return encoded_size
end

struct AmplitudeEntry
    key::Union{Nothing,BitVector}
    val::Union{Nothing,ComplexDouble}
end
PB.default_values(::Type{AmplitudeEntry}) = (;key = nothing, val = nothing)
PB.field_numbers(::Type{AmplitudeEntry}) = (;key = 1, val = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:AmplitudeEntry})
    key = Ref{Union{Nothing,BitVector}}(nothing)
    val = Ref{Union{Nothing,ComplexDouble}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, key)
        elseif field_number == 2
            PB.decode!(d, val)
        else
            PB.skip(d, wire_type)
        end
    end
    return AmplitudeEntry(key[], val[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::AmplitudeEntry)
    initpos = position(e.io)
    !isnothing(x.key) && PB.encode(e, 1, x.key)
    !isnothing(x.val) && PB.encode(e, 2, x.val)
    return position(e.io) - initpos
end
function PB._encoded_size(x::AmplitudeEntry)
    encoded_size = 0
    !isnothing(x.key) && (encoded_size += PB._encoded_size(x.key, 1))
    !isnothing(x.val) && (encoded_size += PB._encoded_size(x.val, 2))
    return encoded_size
end

struct QCSResults
    simulator::String
    version::String
    fidelities::Vector{Float64}
    avggateerrors::Vector{Float64}
    cstates::Vector{BitVector}
    zstates::Vector{ComplexVector}
    amplitudes::Vector{AmplitudeEntry}
    timings::Dict{String,Float64}
end
PB.default_values(::Type{QCSResults}) = (;simulator = "", version = "", fidelities = Vector{Float64}(), avggateerrors = Vector{Float64}(), cstates = Vector{BitVector}(), zstates = Vector{ComplexVector}(), amplitudes = Vector{AmplitudeEntry}(), timings = Dict{String,Float64}())
PB.field_numbers(::Type{QCSResults}) = (;simulator = 1, version = 2, fidelities = 3, avggateerrors = 4, cstates = 5, zstates = 6, amplitudes = 7, timings = 8)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:QCSResults})
    simulator = ""
    version = ""
    fidelities = PB.BufferedVector{Float64}()
    avggateerrors = PB.BufferedVector{Float64}()
    cstates = PB.BufferedVector{BitVector}()
    zstates = PB.BufferedVector{ComplexVector}()
    amplitudes = PB.BufferedVector{AmplitudeEntry}()
    timings = Dict{String,Float64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            simulator = PB.decode(d, String)
        elseif field_number == 2
            version = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, wire_type, fidelities)
        elseif field_number == 4
            PB.decode!(d, wire_type, avggateerrors)
        elseif field_number == 5
            PB.decode!(d, cstates)
        elseif field_number == 6
            PB.decode!(d, zstates)
        elseif field_number == 7
            PB.decode!(d, amplitudes)
        elseif field_number == 8
            PB.decode!(d, timings)
        else
            PB.skip(d, wire_type)
        end
    end
    return QCSResults(simulator, version, fidelities[], avggateerrors[], cstates[], zstates[], amplitudes[], timings)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::QCSResults)
    initpos = position(e.io)
    !isempty(x.simulator) && PB.encode(e, 1, x.simulator)
    !isempty(x.version) && PB.encode(e, 2, x.version)
    !isempty(x.fidelities) && PB.encode(e, 3, x.fidelities)
    !isempty(x.avggateerrors) && PB.encode(e, 4, x.avggateerrors)
    !isempty(x.cstates) && PB.encode(e, 5, x.cstates)
    !isempty(x.zstates) && PB.encode(e, 6, x.zstates)
    !isempty(x.amplitudes) && PB.encode(e, 7, x.amplitudes)
    !isempty(x.timings) && PB.encode(e, 8, x.timings)
    return position(e.io) - initpos
end
function PB._encoded_size(x::QCSResults)
    encoded_size = 0
    !isempty(x.simulator) && (encoded_size += PB._encoded_size(x.simulator, 1))
    !isempty(x.version) && (encoded_size += PB._encoded_size(x.version, 2))
    !isempty(x.fidelities) && (encoded_size += PB._encoded_size(x.fidelities, 3))
    !isempty(x.avggateerrors) && (encoded_size += PB._encoded_size(x.avggateerrors, 4))
    !isempty(x.cstates) && (encoded_size += PB._encoded_size(x.cstates, 5))
    !isempty(x.zstates) && (encoded_size += PB._encoded_size(x.zstates, 6))
    !isempty(x.amplitudes) && (encoded_size += PB._encoded_size(x.amplitudes, 7))
    !isempty(x.timings) && (encoded_size += PB._encoded_size(x.timings, 8))
    return encoded_size
end
end # module
