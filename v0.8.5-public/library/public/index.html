<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public · MimiqCircuitsBase.jl</title><meta name="title" content="Public · MimiqCircuitsBase.jl"/><meta property="og:title" content="Public · MimiqCircuitsBase.jl"/><meta property="twitter:title" content="Public · MimiqCircuitsBase.jl"/><meta name="description" content="Documentation for MimiqCircuitsBase.jl."/><meta property="og:description" content="Documentation for MimiqCircuitsBase.jl."/><meta property="twitter:description" content="Documentation for MimiqCircuitsBase.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="MimiqCircuitsBase.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MimiqCircuitsBase.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation/">Installation Instructions</a></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../outline/">Contents</a></li><li><a class="tocitem" href="../operations/">List of Operations</a></li><li class="is-active"><a class="tocitem" href>Public</a><ul class="internal"><li><a class="tocitem" href="#MimiqCircuitsBase"><span>MimiqCircuitsBase</span></a></li><li><a class="tocitem" href="#General-functions"><span>General functions</span></a></li><li><a class="tocitem" href="#Quantum-Circuits-and-Instructions"><span>Quantum Circuits and Instructions</span></a></li><li><a class="tocitem" href="#Operations"><span>Operations</span></a></li><li><a class="tocitem" href="#Bit-Strings"><span>Bit Strings</span></a></li><li><a class="tocitem" href="#Results-of-simulations"><span>Results of simulations</span></a></li><li><a class="tocitem" href="#Symbolics"><span>Symbolics</span></a></li></ul></li><li><a class="tocitem" href="../internals/">Internals</a></li><li><a class="tocitem" href="../function_index/">Function index</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Public</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/main/docs/src/library/public.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-Documentation"><a class="docs-heading-anchor" href="#Public-Documentation">Public Documentation</a><a id="Public-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Public-Documentation" title="Permalink"></a></h1><p>Documentation for <code>MimiqCircuitsBase.jl</code>&#39;s public interface.</p><p>See the Internals section of the manual for internal package docs.</p><h2 id="MimiqCircuitsBase"><a class="docs-heading-anchor" href="#MimiqCircuitsBase">MimiqCircuitsBase</a><a id="MimiqCircuitsBase-1"></a><a class="docs-heading-anchor-permalink" href="#MimiqCircuitsBase" title="Permalink"></a></h2><h2 id="General-functions"><a class="docs-heading-anchor" href="#General-functions">General functions</a><a id="General-functions-1"></a><a class="docs-heading-anchor-permalink" href="#General-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.isopalias" href="#MimiqCircuitsBase.isopalias"><code>MimiqCircuitsBase.isopalias</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isopalias(typ)</code></pre><p>Checks if a given operation type is an alias or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/abstract.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.isunitary" href="#MimiqCircuitsBase.isunitary"><code>MimiqCircuitsBase.isunitary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isunitary(instruction)
isunitary(operation)</code></pre><p>Checks if a given operation is unititary or not.</p><p><strong>See also</strong></p><p><a href="#MimiqCircuitsBase.iswrapper"><code>iswrapper</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/abstract.jl#L17-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.getoperation" href="#MimiqCircuitsBase.getoperation"><code>MimiqCircuitsBase.getoperation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getoperation(operation)
getoperation(instruction)</code></pre><p>Returns the quantum operation associated to the given instruction.</p><p>See also <a href="#MimiqCircuitsBase.iswrapper"><code>iswrapper</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; getoperation(Instruction(GateX(), 1))
X

julia&gt; getoperation(GateSX())
X

julia&gt; getoperation(GateCX())
X</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/docstrings.jl#L157-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.inverse" href="#MimiqCircuitsBase.inverse"><code>MimiqCircuitsBase.inverse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inverse(circuit)
inverse(instruction)
inverse(operation)</code></pre><p>Inverse of the given circuit, instruction or operation.</p><p>When the inverse is not a known operation, it will return an <a href="#MimiqCircuitsBase.Inverse"><code>Inverse</code></a> object that wraps the original operation.</p><details class="admonition is-details"><summary class="admonition-header">Details</summary><div class="admonition-body"><p>It throws an error if the object is not invertible. Such for example, in the case of non unitary operations, or circuits containing <a href="#MimiqCircuitsBase.Measure"><code>Measure</code></a> or <a href="#MimiqCircuitsBase.Reset"><code>Reset</code></a>.</p></div></details><p>See also <a href="#MimiqCircuitsBase.matrix"><code>matrix</code></a>, <a href="#MimiqCircuitsBase.isunitary"><code>isunitary</code></a>, <a href="#MimiqCircuitsBase.power"><code>power</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; inverse(GateRX(λ))
RX(-λ)

julia&gt; inverse(GateCSX())
C(SX†)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/docstrings.jl#L74-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.numbits" href="#MimiqCircuitsBase.numbits"><code>MimiqCircuitsBase.numbits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numbits(instruction)
numbits(circuit)</code></pre><p>Number of classical bits on which the given operation or instruction is defined.</p><p>See also <a href="#MimiqCircuitsBase.numqubits"><code>numqubits</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; numbits(GateCX())
0

julia&gt; numbits(Measure())
1

julia&gt; c = Circuit(); push!(c, Measure(), 1, 1); push!(c, Measure(),1,3)
1-qubit circuit with 2 instructions:
├── Measure @ q[1], c[1]
└── Measure @ q[1], c[3]

julia&gt; numbits(c)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/docstrings.jl#L46-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.numqubits" href="#MimiqCircuitsBase.numqubits"><code>MimiqCircuitsBase.numqubits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numqubits(operation)
numqubits(instruction)
numqubits(circuit)</code></pre><p>Number of qubits on which the given operation or instruction is defined.</p><p>See also <a href="#MimiqCircuitsBase.numbits"><code>numbits</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; numqubits(GateCX())
2

julia&gt; numqubits(Measure())
1

julia&gt; c = Circuit(); push!(c, GateX(), 1); push!(c, GateCX(),3,6)
6-qubit circuit with 2 instructions:
├── X @ q[1]
└── CX @ q[3], q[6]

julia&gt; numqubits(c)
6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/docstrings.jl#L17-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.opname" href="#MimiqCircuitsBase.opname"><code>MimiqCircuitsBase.opname</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">opname(instruction)
opname(operation)</code></pre><p>Name of the underlying quantum operation in a human readable format.</p><p>See also <a href="#MimiqCircuitsBase.numqubits"><code>numqubits</code></a>, <a href="#MimiqCircuitsBase.numbits"><code>numbits</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; opname(GateX())
&quot;X&quot;

julia&gt; opname(GateRX(π/2))
&quot;RX&quot;

julia&gt; opname(Instruction(GateCX(),1,2))
&quot;CX&quot;

julia&gt; opname(QFT(4))
&quot;QFT&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/docstrings.jl#L131-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.power" href="#MimiqCircuitsBase.power"><code>MimiqCircuitsBase.power</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">power(operation, exponent)</code></pre><p>Elevate an operation to a given exponent.</p><p>It performs simplifications when possible otherwise wraps the operation in a <a href="#MimiqCircuitsBase.Power"><code>Power</code></a> object.</p><p>See also <a href="#MimiqCircuitsBase.Power"><code>Power</code></a>, <a href="#MimiqCircuitsBase.inverse"><code>inverse</code></a>, <a href="#MimiqCircuitsBase.Inverse"><code>Inverse</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; power(GateX(), 1//2)
SX

julia&gt; power(GateX(), 0.5)
X^0.5

julia&gt; GateX()^2
ID

julia&gt; GateCSX()^2
CX</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/docstrings.jl#L103-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.evaluate" href="#MimiqCircuitsBase.evaluate"><code>MimiqCircuitsBase.evaluate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evaluate(object, dictionary)</code></pre><p>Evaluate all the parametric expression in <code>object</code> using the values specified in the given in the variable, value dictionary, returning a new object constructed on the evaluated parameters.</p><p><strong>Examples</strong></p><p>Evaluate a single parametric gate</p><pre><code class="language-julia-repl hljs">julia&gt; @variables θ
1-element Vector{Symbolics.Num}:
 θ

julia&gt; g  = GateRX(θ)
RX(θ)

julia&gt; evaluate(g, Dict(θ =&gt; 3π))
RX(3π)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/evaluate.jl#L17-L38">source</a></section></article><h2 id="Quantum-Circuits-and-Instructions"><a class="docs-heading-anchor" href="#Quantum-Circuits-and-Instructions">Quantum Circuits and Instructions</a><a id="Quantum-Circuits-and-Instructions-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Circuits-and-Instructions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.AbstractInstruction" href="#MimiqCircuitsBase.AbstractInstruction"><code>MimiqCircuitsBase.AbstractInstruction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractInstruction</code></pre><p>Abstract super type for all the instrcutions.</p><p>An instruction applies one or more operations to a set of qubits and classical bits.</p><p><strong>Methods</strong></p><p><a href="#MimiqCircuitsBase.getqubit"><code>getqubit</code></a>, <a href="#MimiqCircuitsBase.getqubits"><code>getqubits</code></a>, <a href="#MimiqCircuitsBase.getbits"><code>getbits</code></a>, <a href="#MimiqCircuitsBase.getbit"><code>getbit</code></a> <a href="#MimiqCircuitsBase.inverse"><code>inverse</code></a>, <a href="#MimiqCircuitsBase.opname"><code>opname</code></a>, <a href="#MimiqCircuitsBase.numqubits"><code>numqubits</code></a>, <a href="#MimiqCircuitsBase.numbits"><code>numbits</code></a></p><p><strong>See also</strong></p><p><a href="#MimiqCircuitsBase.Instruction"><code>Instruction</code></a>, <a href="#MimiqCircuitsBase.Operation"><code>Operation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/instruction.jl#L17-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.Instruction" href="#MimiqCircuitsBase.Instruction"><code>MimiqCircuitsBase.Instruction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Instruction(op, qtargets, ctargets) &lt;: AbstractInstruction</code></pre><p>Representation of an operation applied to specific qubit and bit targets.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Instruction(GateX(), (1,), ())
X @ q[1]

julia&gt; Instruction(GateCX(), (1,2), ())
CX @ q[1], q[2]

julia&gt; Instruction(Measure(), (3,), (3,))
Measure @ q[3], c[3]
</code></pre><p><strong>See also</strong></p><p><a href="#MimiqCircuitsBase.AbstractInstruction"><code>AbstractInstruction</code></a>, <a href="#MimiqCircuitsBase.Operation"><code>Operation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/instruction.jl#L140-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.Instruction-Union{Tuple{L}, Tuple{M}, Tuple{N}, Tuple{Operation{N, M}, Vararg{Integer, L}}} where {N, M, L}" href="#MimiqCircuitsBase.Instruction-Union{Tuple{L}, Tuple{M}, Tuple{N}, Tuple{Operation{N, M}, Vararg{Integer, L}}} where {N, M, L}"><code>MimiqCircuitsBase.Instruction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Instruction(op, targets...)</code></pre><p>Constructors an instruction from an operation and a list of targets.</p><p>By convention, if <code>op</code> is an <code>N</code>-qubit and <code>M</code>-bit operations, then the first <code>N</code> targets are used as qubits and the last <code>M</code> as bits.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Instruction(GateX(), 1)
X @ q[1]

julia&gt; Instruction(GateCX(), 1,2)
CX @ q[1], q[2]

julia&gt; Instruction(Measure(), 3, 3)
Measure @ q[3], c[3]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/instruction.jl#L178-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.getbit" href="#MimiqCircuitsBase.getbit"><code>MimiqCircuitsBase.getbit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getbit(instruction, i)</code></pre><p><code>i</code>-th target classical bit of an instruction.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; inst = Instruction(Measure(), 1, 3)
Measure @ q[1], c[3]

julia&gt; getbit(inst, 1)
3
</code></pre><p><strong>See also</strong></p><p><a href="#MimiqCircuitsBase.getbits"><code>getbits</code></a>, <a href="#MimiqCircuitsBase.getqubit"><code>getqubit</code></a>, <a href="#MimiqCircuitsBase.getqubits"><code>getqubits</code></a>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/instruction.jl#L78-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.getbits" href="#MimiqCircuitsBase.getbits"><code>MimiqCircuitsBase.getbits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getbits(instruction)</code></pre><p>Tuple of the classical bits which the instruction is applied to.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; inst = Instruction(Measure(), 1, 3)
Measure @ q[1], c[3]

julia&gt; getbits(inst)
(3,)
</code></pre><p><strong>See also</strong></p><p><a href="#MimiqCircuitsBase.getbit"><code>getbit</code></a>, <a href="#MimiqCircuitsBase.getqubits"><code>getqubits</code></a>, <a href="#MimiqCircuitsBase.getqubit"><code>getqubit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/instruction.jl#L100-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.getqubit" href="#MimiqCircuitsBase.getqubit"><code>MimiqCircuitsBase.getqubit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getqubit(instruction, i)</code></pre><p><code>i</code>-th target qubit of an instruction.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; inst = Instruction(GateCX(), 1, 3)
CX @ q[1], q[3]

julia&gt; getqubit(inst, 2)
3
</code></pre><p><strong>See also</strong></p><p><a href="#MimiqCircuitsBase.getqubits"><code>getqubits</code></a>, <a href="#MimiqCircuitsBase.getbit"><code>getbit</code></a>, <a href="#MimiqCircuitsBase.getbits"><code>getbits</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/instruction.jl#L36-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.getqubits" href="#MimiqCircuitsBase.getqubits"><code>MimiqCircuitsBase.getqubits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getqubits(instruction)</code></pre><p>Tuple of quantum bits which the instruction is applied to.</p><pre><code class="language-julia-repl hljs">julia&gt; inst = Instruction(GateCX(), 1, 3)
CX @ q[1], q[3]

julia&gt; getqubits(inst)
(1, 3)
</code></pre><p><strong>See also</strong></p><p><a href="#MimiqCircuitsBase.getqubit"><code>getqubit</code></a>, <a href="#MimiqCircuitsBase.getbits"><code>getbits</code></a>, <a href="#MimiqCircuitsBase.getbit"><code>getbit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/instruction.jl#L58-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.Circuit" href="#MimiqCircuitsBase.Circuit"><code>MimiqCircuitsBase.Circuit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Circuit([instructions])</code></pre><p>Representation of a quantum circuit as a vector of instructions applied to the qubits.</p><p>The circuit can be initialized with an optional vector of instructions.</p><p>See <a href="../operations/#MimiqCircuitsBase.OPERATIONS"><code>OPERATIONS</code></a>, <a href="../operations/#MimiqCircuitsBase.GATES"><code>GATES</code></a>, or <a href="../operations/#MimiqCircuitsBase.GENERALIZED"><code>GENERALIZED</code></a> for the list of operations to add to circuits.</p><p><strong>Examples</strong></p><p>Operation can be added one by one to a circuit with the <code>push!(circuit, operation, targets...)</code> function</p><pre><code class="language-julia-repl hljs">julia&gt; c = Circuit()
empty circuit


julia&gt; push!(c, GateH(), 1)
1-qubit circuit with 1 instructions:
└── H @ q[1]

julia&gt; push!(c, GateCX(), 1, 2)
2-qubit circuit with 2 instructions:
├── H @ q[1]
└── CX @ q[1], q[2]

julia&gt; push!(c, GateRX(π / 4), 1)
2-qubit circuit with 3 instructions:
├── H @ q[1]
├── CX @ q[1], q[2]
└── RX(π/4) @ q[1]

julia&gt; push!(c, Barrier(2), 1, 3)
3-qubit circuit with 4 instructions:
├── H @ q[1]
├── CX @ q[1], q[2]
├── RX(π/4) @ q[1]
└── Barrier @ q[1,3]

julia&gt; push!(c, Measure(), 1, 1)
3-qubit circuit with 5 instructions:
├── H @ q[1]
├── CX @ q[1], q[2]
├── RX(π/4) @ q[1]
├── Barrier @ q[1,3]
└── Measure @ q[1], c[1]
</code></pre><p>Targets are not restricted to be single values, but also vectors. In this case a single <code>push!</code> will add multiple operations.</p><pre><code class="language-julia-repl hljs">julia&gt; push!(Circuit(), GateCCX(), 1, 2:4, 4:10)
6-qubit circuit with 3 instructions:
├── C₂X @ q[1:2], q[4]
├── C₂X @ q[1,3], q[5]
└── C₂X @ q[1,4], q[6]</code></pre><p>is equivalent to</p><pre><code class="nohighlight hljs">for (i, j) in zip(2:4, 4:10)
    push!(c, GateCX(), 1, i)
end</code></pre><p>Notice how the range <code>4:10</code> is not fully used, since <code>2:4</code> is shorter.</p><p><strong>Display</strong></p><p>To display a a LaTeX representation of the circuit, we can just use Quantikz.jl</p><pre><code class="language-julia hljs">using Quantikz
c = Circuit()
...
displaycircuit(c)</code></pre><p>or</p><pre><code class="language-julia hljs">savecircuit(c, &quot;circuit.pdf&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/circuit.jl#L17-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.depth-Tuple{Circuit}" href="#MimiqCircuitsBase.depth-Tuple{Circuit}"><code>MimiqCircuitsBase.depth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">depth(circuit)</code></pre><p>Compute the depth of a quantum circuit.</p><p>The depth of a quantum circuit is a metric computing the maximum time (in units of quantum gates application) between the input and output of the circuit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/circuit_extras.jl#L17-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.draw" href="#MimiqCircuitsBase.draw"><code>MimiqCircuitsBase.draw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">draw(circuit)</code></pre><p>Draw an ascii representation of a circuit.</p><p><em>NOTE</em> it automatically detects the screen width and will split the circuit if it is too wide.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/circuit/draw.jl#L577-L583">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.emplace!" href="#MimiqCircuitsBase.emplace!"><code>MimiqCircuitsBase.emplace!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">emplace!(circuit, operation, registers...)</code></pre><p>Emplace an operation at the end of a circuit and applies it to the given registers.</p><pre><code class="language-julia-repl hljs">julia&gt; emplace!(Circuit(), control(3, GateSWAP()), [1,2,3], [4,5])
5-qubit circuit with 1 instructions:
└── C₃SWAP @ q[1:3], q[4:5]

julia&gt; QFT()
lazy QFT(?)

julia&gt; emplace!(Circuit(), QFT(), [1,2,3])
3-qubit circuit with 1 instructions:
└── QFT @ q[1:3]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/circuit/emplace.jl#L17-L37">source</a></section></article><h2 id="Operations"><a class="docs-heading-anchor" href="#Operations">Operations</a><a id="Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Operations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.Operation" href="#MimiqCircuitsBase.Operation"><code>MimiqCircuitsBase.Operation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Operation{N,M}</code></pre><p>Abstract supertype for all the quantum operations acting on <code>N</code> qubits and <code>M</code> classical bits.</p><p><strong>Methods</strong></p><p><a href="#MimiqCircuitsBase.iswrapper"><code>iswrapper</code></a>, <a href="#MimiqCircuitsBase.isunitary"><code>isunitary</code></a>, <a href="#MimiqCircuitsBase.numbits"><code>numbits</code></a>, <a href="#MimiqCircuitsBase.numqubits"><code>numqubits</code></a>, <a href="#MimiqCircuitsBase.opname"><code>opname</code></a></p><p><strong>See also</strong></p><p><a href="#MimiqCircuitsBase.AbstractGate"><code>AbstractGate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operation.jl#L17-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.cregsizes-Tuple{T} where T" href="#MimiqCircuitsBase.cregsizes-Tuple{T} where T"><code>MimiqCircuitsBase.cregsizes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cregsizes(operation)
cregsizes(operationtype)</code></pre><p>Length of the classicalregisters the given operation acts on.</p><p><strong>See also</strong></p><p><a href="#MimiqCircuitsBase.qregsizes-Tuple{T} where T"><code>qregsizes</code></a>, <a href="#MimiqCircuitsBase.numqubits"><code>numqubits</code></a>, <a href="#MimiqCircuitsBase.numbits"><code>numbits</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operation.jl#L136-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.getparam" href="#MimiqCircuitsBase.getparam"><code>MimiqCircuitsBase.getparam</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getparam(operation, name)</code></pre><p>Value of the corresponding parameter in the given parametric operation.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">getparam(GateRX(π/8), :θ)</code></pre><p><strong>See also</strong></p><p><a href="#MimiqCircuitsBase.parnames"><code>parnames</code></a>, <a href="#MimiqCircuitsBase.numparams"><code>numparams</code></a>, <a href="#MimiqCircuitsBase.getparams"><code>getparams</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operation.jl#L213-L227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.getparams" href="#MimiqCircuitsBase.getparams"><code>MimiqCircuitsBase.getparams</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getparams(operation)</code></pre><p>Value of the parameters in the given parametric operation.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">getparam(GateU(π/8, 3.1, sqrt(2)))</code></pre><p><strong>See also</strong></p><p><a href="#MimiqCircuitsBase.parnames"><code>parnames</code></a>, <a href="#MimiqCircuitsBase.numparams"><code>numparams</code></a>, <a href="#MimiqCircuitsBase.getparam"><code>getparam</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operation.jl#L232-L246">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.hilbertspacedim" href="#MimiqCircuitsBase.hilbertspacedim"><code>MimiqCircuitsBase.hilbertspacedim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hilbertspacedim(operation)
hilbertspacedim(operationtype)
hilbertspacedim(N::Integer)</code></pre><p>Hilbert space dimension for the given operation. For an operation actiing on <code>N</code> qubits, it is <code>2^N</code>.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">hilbertspacedim(Operation{2, 1})
hilbertspacedim(GateH)
hilbertspacedim(GateH())
hilbertspacedim(GateRX)
hilbertspacedim(GateCX)
hilbertspacedim(4)</code></pre><p><strong>See also</strong></p><p><a href="#MimiqCircuitsBase.numqubits"><code>numqubits</code></a>, <a href="#MimiqCircuitsBase.numbits"><code>numbits</code></a>, <a href="#MimiqCircuitsBase.Operation"><code>Operation</code></a>, <a href="#MimiqCircuitsBase.AbstractGate"><code>AbstractGate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operation.jl#L73-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.iswrapper" href="#MimiqCircuitsBase.iswrapper"><code>MimiqCircuitsBase.iswrapper</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iswrapper(operation)
iswrapper(operationtype)</code></pre><p>Checks if a given operation is a wrapper or not.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">iswrapper(Control)
iswrapper(GateX)
iswrapper(GateSX) # SX is defined as Power(1//2, GateX())
iswrapper(GateCX) # CX is defined as Control(1, GateX())</code></pre><p><strong>See also</strong></p><p><a href="#MimiqCircuitsBase.isunitary"><code>isunitary</code></a>, <a href="#MimiqCircuitsBase.getoperation"><code>getoperation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operation.jl#L48-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.numparams" href="#MimiqCircuitsBase.numparams"><code>MimiqCircuitsBase.numparams</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numparams(operation)
numparams(operationtype)</code></pre><p>Number of parameters for the given parametric operation. Zero for non parametric operations.</p><p>By default it returns the number of fields of the operations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; numparams(GateH)
0

julia&gt; numparams(GateU)
4

julia&gt; numparams(GateRX)
1

julia&gt; numparams(Measure)
0
</code></pre><p><strong>See also</strong></p><p><a href="#MimiqCircuitsBase.parnames"><code>parnames</code></a>, <a href="#MimiqCircuitsBase.getparam"><code>getparam</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operation.jl#L177-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.parnames" href="#MimiqCircuitsBase.parnames"><code>MimiqCircuitsBase.parnames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parnames(operation)
parnames(operationtype)</code></pre><p>Name of the parameters allowed for the given operation.</p><p>By default it returns the fieldnames of the operation type.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">parnames(GateH)
parnames(GateRX)
parnames(GateCRX)
parnames(Measure)</code></pre><p><strong>See also</strong></p><p><a href="#MimiqCircuitsBase.numparams"><code>numparams</code></a>, <a href="#MimiqCircuitsBase.getparam"><code>getparam</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operation.jl#L150-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.qregsizes-Tuple{T} where T" href="#MimiqCircuitsBase.qregsizes-Tuple{T} where T"><code>MimiqCircuitsBase.qregsizes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">qregsizes(operation)
qregsizes(operationtype)</code></pre><p>Length of the quantum registers the given operation acts on.</p><details class="admonition is-details"><summary class="admonition-header">Details</summary><div class="admonition-body"><p>Some operations, such as adders or multipliers, acts on different groups of qubits (quantum registers).</p></div></details><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qregsizes(GateRX(0.1))
(1,)

julia&gt; qregsizes(GateCRX(0.1))
(1, 1)

julia&gt; qregsizes(QFT(4))
(4,)</code></pre><p><strong>See also</strong></p><p><a href="#MimiqCircuitsBase.cregsizes-Tuple{T} where T"><code>cregsizes</code></a>, <a href="#MimiqCircuitsBase.numqubits"><code>numqubits</code></a>, <a href="#MimiqCircuitsBase.numbits"><code>numbits</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operation.jl#L105-L131">source</a></section></article><h3 id="Decompositions"><a class="docs-heading-anchor" href="#Decompositions">Decompositions</a><a id="Decompositions-1"></a><a class="docs-heading-anchor-permalink" href="#Decompositions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.decompose" href="#MimiqCircuitsBase.decompose"><code>MimiqCircuitsBase.decompose</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">decompose(operation)
decompose(circuit)</code></pre><p>Decompose the given operation or circuit into a circuit of more elementary gates. If applied recursively, it will decompose the given object into a circuit of <a href="#MimiqCircuitsBase.GateCX"><code>GateCX</code></a> and <a href="#MimiqCircuitsBase.GateU"><code>GateU</code></a> gates.</p><p>See also <a href="#MimiqCircuitsBase.decompose!"><code>decompose!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/decompose.jl#L17-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.decompose!" href="#MimiqCircuitsBase.decompose!"><code>MimiqCircuitsBase.decompose!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">decompose!(circuit, operation[, qtargets, ctargets])</code></pre><p>In place version of <a href="#MimiqCircuitsBase.decompose"><code>decompose</code></a>.</p><p>It decomposes the given object, appending all the resulting operations to the given circuit. The optional <code>qtargets</code> and <code>ctargets</code> arguments can be used to map the qubits and classical bits of the decomposed operation to the ones of the target circuit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/decompose.jl#L29-L38">source</a></section></article><h3 id="Gates"><a class="docs-heading-anchor" href="#Gates">Gates</a><a id="Gates-1"></a><a class="docs-heading-anchor-permalink" href="#Gates" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.AbstractGate" href="#MimiqCircuitsBase.AbstractGate"><code>MimiqCircuitsBase.AbstractGate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractGate{N} &lt;: Operation{N,0}</code></pre><p>Supertype for all the <code>N</code>-qubit unitary gates.</p><p>See also <a href="#MimiqCircuitsBase.hilbertspacedim"><code>hilbertspacedim</code></a>, <a href="#MimiqCircuitsBase.inverse"><code>inverse</code></a>, <a href="#MimiqCircuitsBase.isunitary"><code>isunitary</code></a>, <a href="#MimiqCircuitsBase.matrix"><code>matrix</code></a>, <a href="#MimiqCircuitsBase.numqubits"><code>numqubits</code></a>, <a href="#MimiqCircuitsBase.opname"><code>opname</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gate.jl#L17-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.matrix" href="#MimiqCircuitsBase.matrix"><code>MimiqCircuitsBase.matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">matrix(gate)</code></pre><p>Matrix associated to the given gate.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>if the gate is parametric, the matrix elements are is wrapped in a <code>Symbolics.Num</code> object. To manipulate expressions use the <code>Symbolics</code> package.</p></div></div><p><strong>Examples</strong></p><p>Matrix of a simple gate</p><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateH())
2×2 Matrix{Float64}:
 0.707107   0.707107
 0.707107  -0.707107</code></pre><pre><code class="language-julia-repl hljs">julia&gt; matrix(GateRX(π/2))
2×2 Matrix{ComplexF64}:
 0.707107+0.0im            0.0-0.707107im
      0.0-0.707107im  0.707107+0.0im

julia&gt; matrix(GateCX())
4×4 Matrix{Float64}:
 1.0  0.0  0.0  0.0
 0.0  1.0  0.0  0.0
 0.0  0.0  0.0  1.0
 0.0  0.0  1.0  0.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gate.jl#L39-L73">source</a></section></article><h4 id="Wrappers"><a class="docs-heading-anchor" href="#Wrappers">Wrappers</a><a id="Wrappers-1"></a><a class="docs-heading-anchor-permalink" href="#Wrappers" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.Control" href="#MimiqCircuitsBase.Control"><code>MimiqCircuitsBase.Control</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Control(numcontrols, gate) &lt;: AbstractGate</code></pre><p>Control modifier, similar to OpenQASM 3.0 <code>ctrl @ gate</code>. It wraps a given gate and adds a number of controls to it.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>By default the first <code>numcontrols</code> qubits are used as controls, and the remaining ones as targets for the wrapped gate.</p></div></div><p>See also <a href="#MimiqCircuitsBase.Power"><code>Power</code></a>, <a href="#MimiqCircuitsBase.Inverse"><code>Inverse</code></a>, <a href="#MimiqCircuitsBase.getoperation"><code>getoperation</code></a>, <a href="#MimiqCircuitsBase.iswrapper"><code>iswrapper</code></a>, <a href="#MimiqCircuitsBase.numcontrols"><code>numcontrols</code></a>, <a href="#MimiqCircuitsBase.numtargets"><code>numtargets</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Control(1, GateX())
CX

julia&gt; Control(3, GateH())
C₃H

julia&gt; Control(24, GateSWAP())
C₂₄SWAP</code></pre><p><strong>Decomposition</strong></p><p>The default decomposition of a <code>Control</code> gate is build by applying recursively Lemma 7.3 of [<a href="../../references/#Barenco1995">1</a>]. This requires to decompose multicontrolled-<span>$X$</span> gates, which is done recursively, according to Lemma 7.2 and 7.3 of [<a href="../../references/#Barenco1995">1</a>].</p><p>Here we give a simple example of a decomposition of a <span>$C_5T$</span> gate.</p><pre><code class="language-julia-repl hljs">julia&gt; decompose(Control(3,GateT()))
4-qubit circuit with 9 instructions:
├── C(Z^(1//8)) @ q[3], q[4]
├── C₂X @ q[1:2], q[3]
├── C((Z^(1//8))†) @ q[3], q[4]
├── C₂X @ q[1:2], q[3]
├── C(Z^(1//16)) @ q[2], q[4]
├── CX @ q[1], q[2]
├── C((Z^(1//16))†) @ q[2], q[4]
├── CX @ q[1], q[2]
└── C(Z^(1//16)) @ q[1], q[4]</code></pre><div class="admonition is-category-detail"><header class="admonition-header">Detail</header><div class="admonition-body"><p>Some decompositions have been overrided with optimized versions, to reduce the number of gates used.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/control.jl#L17-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.Control-Union{Tuple{Operation{N, 0}}, Tuple{N}} where N" href="#MimiqCircuitsBase.Control-Union{Tuple{Operation{N, 0}}, Tuple{N}} where N"><code>MimiqCircuitsBase.Control</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Control(gate)</code></pre><p>Build a controlled gate with 1 control.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/control.jl#L101-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.control" href="#MimiqCircuitsBase.control"><code>MimiqCircuitsBase.control</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">control([numcontrols], gate)</code></pre><p>Build a multicontrolled gate.</p><p>The number of controls can be omitted to be lazily evaluated later.</p><p><strong>Examples</strong></p><p>Standard examples, with all the arguments spefcified.</p><pre><code class="language-julia-repl hljs">julia&gt; control(1, GateX())
CX

julia&gt; control(2, GateX())
C₂X

julia&gt; control(3, GateCH())
C₄H
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/control.jl#L108-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.numcontrols" href="#MimiqCircuitsBase.numcontrols"><code>MimiqCircuitsBase.numcontrols</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numcontrols(control)</code></pre><p>Number of controls of a given multicontrolled gate.</p><p><strong>See also</strong></p><p><a href="#MimiqCircuitsBase.Control"><code>Control</code></a>, <a href="#MimiqCircuitsBase.numtargets"><code>numtargets</code></a>, <a href="#MimiqCircuitsBase.numqubits"><code>numqubits</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/control.jl#L182-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.numtargets" href="#MimiqCircuitsBase.numtargets"><code>MimiqCircuitsBase.numtargets</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numtargets(control)</code></pre><p>Get the number of targets of a given multicontrolled gate.</p><p><strong>Examples</strong></p><p>numcontro</p><p><strong>See also</strong></p><p><a href="#MimiqCircuitsBase.Control"><code>Control</code></a>, <a href="#MimiqCircuitsBase.numtargets"><code>numtargets</code></a>, <a href="#MimiqCircuitsBase.numqubits"><code>numqubits</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/control.jl#L197-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.Inverse" href="#MimiqCircuitsBase.Inverse"><code>MimiqCircuitsBase.Inverse</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Inverse(operation)</code></pre><p>Inverse of the wrapped quantum operation.</p><p>The inversion is not performed right away, but only when the circuit is cached or executed.</p><p>Some simplifications are already carried out at construction, for example, <code>Inverse(Inverse(op))</code> is simplified as <code>Inverse(op)</code>.</p><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p>Users should not use directly <code>Inverse</code> but the <code>inverse</code> method, which performs already all the simplifications.</p></div></div><p>See also <a href="#MimiqCircuitsBase.inverse"><code>inverse</code></a>, <a href="#MimiqCircuitsBase.iswrapper"><code>iswrapper</code></a>, <a href="#MimiqCircuitsBase.Control"><code>Control</code></a>, <a href="#MimiqCircuitsBase.Power"><code>Power</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Inverse(GateX())
X†

julia&gt; Inverse(GateH())
H†

julia&gt; Inverse(GateSX())
SX†

julia&gt; Inverse(GateCSX())
(CSX)†

julia&gt; Inverse(QFT(4))
QFT†
</code></pre><p><strong>Decomposition</strong></p><p>Decomposition of the inverse is carring out by inverting the decomposition of the wrapped operation.</p><pre><code class="language-julia-repl hljs">julia&gt; decompose(Inverse(GateCSX()))
2-qubit circuit with 3 instructions:
├── H @ q[2]
├── CU1(-1π/2) @ q[1], q[2]
└── H @ q[2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/inverse.jl#L17-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.Power" href="#MimiqCircuitsBase.Power"><code>MimiqCircuitsBase.Power</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Power(pow, operation)</code></pre><p>Wraps an operation and raises it to the given power.</p><p>Some simplifications are already carried out at construction, for example <code>Power(pow2, Power(pow1, op))</code> is simplified as <code>Power(pow1 * pow2, op)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For allowing simplifications, always prefer rational powers, such as <code>1//2</code> over floating point ones, such as <code>0.5</code>.</p></div></div><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p>Users should not use directly <code>Power</code> but the <code>power</code> method, which performs already all the simplifications. Gates should implement the <code>_power</code> method instead.</p></div></div><p>See also <a href="#MimiqCircuitsBase.power"><code>power</code></a>, <a href="#MimiqCircuitsBase.Inverse"><code>Inverse</code></a> , <a href="#MimiqCircuitsBase.inverse"><code>inverse</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Power(GateZ(), 1//2)
S

julia&gt; Power(GateZ(), 2)
Z^2

julia&gt; Power(GateCH(), 1//2)
(CH)^(1//2)

julia&gt; Power(GateCX(), 1//2)
(CX)^(1//2)</code></pre><p><strong>Decomposition</strong></p><p>In the general case, if a decomposition is not known for a given operation and power, the <code>Power</code> operation is not decomposed.</p><p>If the exponent is an integer, then the gate is decomposed by repeating it.</p><pre><code class="language-julia-repl hljs">julia&gt; decompose(Power(GateH(), 2))
1-qubit circuit with 2 instructions:
├── H @ q[1]
└── H @ q[1]

julia&gt; decompose(Power(GateH(), 1//2))
1-qubit circuit with 1 instructions:
└── U(π/2, 0, π)^(1//2) @ q[1]

julia&gt; decompose(Power(GateX(), 1//2)) # same as decomposing GateSX
1-qubit circuit with 4 instructions:
├── S† @ q[1]
├── H @ q[1]
├── S† @ q[1]
└── U(0, 0, 0, π/4) @ q[1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/power.jl#L17-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.Parallel" href="#MimiqCircuitsBase.Parallel"><code>MimiqCircuitsBase.Parallel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Parallel(repeats, operation)</code></pre><p>Wrapper that applies the same operation on multiple qubits.</p><p>If the operation is a <code>N</code>-qubit operation, then the resulting operation is applied over <code>N * repeats</code> qubits.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Parallel(5, GateX())
Parallel(5, X)

julia&gt; Parallel(3, GateRX(λ))
Parallel(3, RX(λ))

julia&gt; Parallel(2, Parallel(3, GateX()))
Parallel(2, Parallel(3, X))
</code></pre><p><strong>Decomposition</strong></p><p>A parallel is decomposed into a sequence of operation, one for each group of qubits.</p><pre><code class="language-julia-repl hljs">julia&gt; decompose(Parallel(2, GateX()))
2-qubit circuit with 2 instructions:
├── X @ q[1]
└── X @ q[2]

julia&gt; decompose(Parallel(3, GateSWAP()))
6-qubit circuit with 3 instructions:
├── SWAP @ q[1:2]
├── SWAP @ q[3:4]
└── SWAP @ q[5:6]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/parallel.jl#L17-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.numrepeats" href="#MimiqCircuitsBase.numrepeats"><code>MimiqCircuitsBase.numrepeats</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numrepeats(paralleloperation)</code></pre><p>Get the number of repetitions of a parallel operation.</p><p>See also <a href="#MimiqCircuitsBase.Parallel"><code>Parallel</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; numrepeats(Parallel(5, GateX()))
5

julia&gt; numrepeats(Parallel(3, GateSWAP()))
3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/parallel.jl#L98-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.parallel" href="#MimiqCircuitsBase.parallel"><code>MimiqCircuitsBase.parallel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parallel(repeats, operation)</code></pre><p>Build a parallel operation.</p><p>The resulting operation is applied over <code>N * repeats</code> qubits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/parallel.jl#L144-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.IfStatement" href="#MimiqCircuitsBase.IfStatement"><code>MimiqCircuitsBase.IfStatement</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IfStatement(numbits, op, num)</code></pre><p>Applies the wrapper operation, only if the classical register is equal to <code>num</code>.</p><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p>Currentely not supported by the state vector and MPS simulators.</p></div></div><p><strong>Examples</strong></p><p><code>push!(IfStatement(GateX(), 10), 1,1,2,3,4,5)</code> is the equivalent of OpenQASM 2.0</p><pre><code class="nohighlight hljs">creg c[5];
if (c==10) x q[0];</code></pre><pre><code class="language-julia-repl hljs">julia&gt; IfStatement(10, GateX(), 999)
IF(c == 999) X</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/ifstatement.jl#L17-L38">source</a></section></article><h4 id="Global-phase"><a class="docs-heading-anchor" href="#Global-phase">Global phase</a><a id="Global-phase-1"></a><a class="docs-heading-anchor-permalink" href="#Global-phase" title="Permalink"></a></h4><h4 id="Standard-Gates"><a class="docs-heading-anchor" href="#Standard-Gates">Standard Gates</a><a id="Standard-Gates-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-Gates" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateU" href="#MimiqCircuitsBase.GateU"><code>MimiqCircuitsBase.GateU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateU(θ, ϕ, λ[, γ = 0])</code></pre><p>Single qubit generic unitary gate <span>$U(\theta, \phi, \lambda, \gamma = 0)$</span>, where <span>$\theta$</span>, <span>$\phi$</span>, and <span>$\lambda$</span> are the Euler angles specified in radians, and <span>$\gamma$</span> is a global phase.</p><p>See also <a href="#MimiqCircuitsBase.GateU3"><code>GateU3</code></a>, <a href="#MimiqCircuitsBase.GateP"><code>GateP</code></a>, <a href="#MimiqCircuitsBase.GateU2"><code>GateU2</code></a>, <a href="#MimiqCircuitsBase.GateU1"><code>GateU1</code></a></p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{U}(\theta, \phi, \lambda, \gamma = 0) =
\mathrm{e}^{i\gamma}
\begin{pmatrix}
    \cos\left(\frac{\theta}{2}\right) &amp; -\mathrm{e}^{i\lambda}\sin\left(\frac{\theta}{2}\right) \\
    \mathrm{e}^{i\phi}\sin\left(\frac{\theta}{2}\right) &amp; \mathrm{e}^{i(\phi+\lambda)}\cos\left(\frac{\theta}{2}\right)
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables θ ϕ λ
3-element Vector{Symbolics.Num}:
 θ
 ϕ
 λ

julia&gt; GateU(θ, ϕ, λ)
U(θ, ϕ, λ)

julia&gt; matrix(GateU(2.023, 0.5, 0.1))
2×2 Matrix{ComplexF64}:
  0.53059+0.0im       -0.843394-0.0846217im
 0.743864+0.406375im   0.437915+0.299594im

julia&gt; c = push!(Circuit(), GateU(θ, ϕ, λ), 1)
1-qubit circuit with 1 instructions:
└── U(θ, ϕ, λ) @ q[1]

julia&gt; push!(c, GateU(π/8, π/2, π/4), 2)
2-qubit circuit with 2 instructions:
├── U(θ, ϕ, λ) @ q[1]
└── U(π/8, π/2, π/4) @ q[2]

julia&gt; power(GateU(θ, ϕ, λ), 2), inverse(GateU(θ, ϕ, λ))
(U(θ, ϕ, λ)^2, U(-θ, -λ, -ϕ))
</code></pre><p><strong>Decomposition</strong></p><p>Since <span>$U$</span> gate, is the most general single qubit unitary matrix, all other matrices are defined from it.</p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateU(θ, λ, ϕ))
1-qubit circuit with 1 instructions:
└── U(θ, λ, ϕ) @ q[1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/u.jl#L17-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateP" href="#MimiqCircuitsBase.GateP"><code>MimiqCircuitsBase.GateP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateP(λ)</code></pre><p>Single qubit Phase gate.</p><p><code>λ</code> is the phase angle in radians.</p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{P}(\lambda) =
\operatorname{U}(0, 0, \lambda) =
\begin{pmatrix}
    1 &amp; 0 \\
    0 &amp; \mathrm{e}^{i\lambda}
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables λ
1-element Vector{Symbolics.Num}:
 λ

julia&gt; GateP(λ)
P(λ)

julia&gt; matrix(GateP(1.989))
2×2 Matrix{ComplexF64}:
 1.0+0.0im       0.0+0.0im
 0.0+0.0im  -0.40612+0.91382im

julia&gt; c = push!(Circuit(), GateP(λ), 1)
1-qubit circuit with 1 instructions:
└── P(λ) @ q[1]

julia&gt; push!(c, GateP(π/2), 2)
2-qubit circuit with 2 instructions:
├── P(λ) @ q[1]
└── P(π/2) @ q[2]
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateP(λ))
1-qubit circuit with 1 instructions:
└── U(0, 0, λ) @ q[1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/phase.jl#L17-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateU1" href="#MimiqCircuitsBase.GateU1"><code>MimiqCircuitsBase.GateU1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateU1(λ)</code></pre><p>Single qubit rotation <code>\operatorname{U1}(\lambda)</code> about the Z axis.</p><p>Equivalent to <a href="#MimiqCircuitsBase.GateP"><code>GateP</code></a>.</p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{U1}(\lambda) =
\begin{pmatrix}
    1 &amp; 0 \\
    0 &amp; e^{i\lambda}
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables λ
1-element Vector{Symbolics.Num}:
 λ

julia&gt; GateU1(λ)
U1(λ)

julia&gt; matrix(GateU1(0.519))
2×2 Matrix{ComplexF64}:
 1.0+0.0im       0.0+0.0im
 0.0+0.0im  0.868316+0.496012im

julia&gt; c = push!(Circuit(), GateU1(λ), 1)
1-qubit circuit with 1 instructions:
└── U1(λ) @ q[1]

julia&gt; push!(c, GateU1(π/2), 2)
2-qubit circuit with 2 instructions:
├── U1(λ) @ q[1]
└── U1(π/2) @ q[2]

julia&gt; power(GateU1(λ), 2), inverse(GateU1(λ))
(U1(λ)^2, U1(-λ))
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateU1(λ))
1-qubit circuit with 1 instructions:
└── U(0, 0, λ) @ q[1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/deprecated.jl#L17-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateU2" href="#MimiqCircuitsBase.GateU2"><code>MimiqCircuitsBase.GateU2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateU2(ϕ, λ)</code></pre><p>Single qubit rotation <code>\operatorname{U2}(\phi, \lambda)</code> about the X+Z axis.</p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{U2}(\phi,\lambda) = \frac{1}{\sqrt{2}}e^{-(\phi+\lambda)/2}\begin{pmatrix}
1 &amp; -e^{i\lambda} \\
e^{i\phi} &amp; e^{i(\phi+\lambda)}
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables ϕ λ
2-element Vector{Symbolics.Num}:
 ϕ
 λ

julia&gt; GateU2(ϕ, λ)
U2(ϕ, λ)

julia&gt; matrix(GateU2(2.023, 0.5))
2×2 Matrix{ComplexF64}:
  0.707107+0.0im       -0.620545-0.339005im
 -0.308969+0.636033im  -0.576077+0.410044im

julia&gt; c = push!(Circuit(), GateU2(ϕ, λ), 1)
1-qubit circuit with 1 instructions:
└── U2(ϕ, λ) @ q[1]

julia&gt; push!(c, GateU2(π/2, π/4), 2)
2-qubit circuit with 2 instructions:
├── U2(ϕ, λ) @ q[1]
└── U2(π/2, π/4) @ q[2]

julia&gt; power(GateU2(ϕ, λ), 2), inverse(GateU2(ϕ, λ))
(U2(ϕ, λ)^2, U2(-3.141592653589793 - λ, π - ϕ))
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateU2(ϕ, λ))
1-qubit circuit with 1 instructions:
└── U3(π/2, ϕ, λ) @ q[1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/deprecated.jl#L88-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateU3" href="#MimiqCircuitsBase.GateU3"><code>MimiqCircuitsBase.GateU3</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateU3(θ, ϕ, λ)</code></pre><p>Single qubit generic unitary gate <code>U3(\theta, \phi, \lambda)</code>.</p><p>This gate is equivalent to the generic unitary gate <a href="#MimiqCircuitsBase.GateU"><code>GateU</code></a>, differing from it only by a global phase of <span>$\frac{\phi + \lambda + \theta}{2}$</span>.</p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{U3}(\theta,\phi,\lambda) =
\begin{pmatrix}
    \cos\left(\frac{\theta}{2}\right) &amp; -e^{i\lambda}\sin\left(\frac{\theta}{2}\right) \\
    \mathrm{e}^{i\phi}\sin\left(\frac{\theta}{2}\right) &amp; \mathrm{e}^{i(\phi+\lambda)}\cos\left(\frac{\theta}{2}\right)
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables θ ϕ λ
3-element Vector{Symbolics.Num}:
 θ
 ϕ
 λ

julia&gt; GateU3(θ, ϕ, λ)
U3(θ, ϕ, λ)

julia&gt; matrix(GateU3(2.023, 0.5, 0.1))
2×2 Matrix{ComplexF64}:
  0.53059+0.0im       -0.843394-0.0846217im
 0.743864+0.406375im   0.437915+0.299594im

julia&gt; c = push!(Circuit(), GateU3(θ, ϕ, λ), 1)
1-qubit circuit with 1 instructions:
└── U3(θ, ϕ, λ) @ q[1]

julia&gt; push!(c, GateU3(π/8, π/2, π/4), 2)
2-qubit circuit with 2 instructions:
├── U3(θ, ϕ, λ) @ q[1]
└── U3(π/8, π/2, π/4) @ q[2]

julia&gt; power(GateU3(θ, ϕ, λ), 2), inverse(GateU3(θ, ϕ, λ))
(U3(θ, ϕ, λ)^2, U3(-θ, -λ, -ϕ))
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateU3(θ, ϕ, λ))
1-qubit circuit with 1 instructions:
└── U(θ, ϕ, λ) @ q[1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/deprecated.jl#L158-L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateX" href="#MimiqCircuitsBase.GateX"><code>MimiqCircuitsBase.GateX</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateX()</code></pre><p>Single qubit Pauli-X gate.</p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{X} =
\begin{pmatrix}
    0 &amp; 1 \\
    1 &amp; 0
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; GateX()
X

julia&gt; matrix(GateX())
2×2 Matrix{Int64}:
 0  1
 1  0

julia&gt; c = push!(Circuit(), GateX(), 1)
1-qubit circuit with 1 instructions:
└── X @ q[1]

julia&gt; push!(c, GateX, 2)
2-qubit circuit with 2 instructions:
├── X @ q[1]
└── X @ q[2]
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateX())
1-qubit circuit with 1 instructions:
└── U(π, 0, π) @ q[1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/pauli.jl#L17-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateY" href="#MimiqCircuitsBase.GateY"><code>MimiqCircuitsBase.GateY</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateY()</code></pre><p>Single qubit Pauli-Y gate.</p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{Y} =
\begin{pmatrix}
    0 &amp; -i \\
    i &amp; 0
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; GateY()
Y

julia&gt; matrix(GateY())
2×2 Matrix{ComplexF64}:
 0.0+0.0im  0.0-1.0im
 0.0+1.0im  0.0+0.0im

julia&gt; c = push!(Circuit(), GateY(), 1)
1-qubit circuit with 1 instructions:
└── Y @ q[1]

julia&gt; push!(c, GateY, 2)
2-qubit circuit with 2 instructions:
├── Y @ q[1]
└── Y @ q[2]
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateY())
1-qubit circuit with 1 instructions:
└── U(π, π/2, π/2) @ q[1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/pauli.jl#L79-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateZ" href="#MimiqCircuitsBase.GateZ"><code>MimiqCircuitsBase.GateZ</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateZ()</code></pre><p>Single qubit Pauli-Z gate.</p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{Z} =
\begin{pmatrix}
    1 &amp; 0 \\
    0 &amp; -1
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; GateZ()
Z

julia&gt; matrix(GateZ())
2×2 Matrix{Float64}:
 1.0   0.0
 0.0  -1.0

julia&gt; c = push!(Circuit(), GateZ(), 1)
1-qubit circuit with 1 instructions:
└── Z @ q[1]

julia&gt; push!(c, GateZ, 2)
2-qubit circuit with 2 instructions:
├── Z @ q[1]
└── Z @ q[2]
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateZ())
1-qubit circuit with 1 instructions:
└── P(π) @ q[1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/pauli.jl#L141-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateH" href="#MimiqCircuitsBase.GateH"><code>MimiqCircuitsBase.GateH</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateH()</code></pre><p>Single qubit Hadamard gate.</p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname H =
\frac{1}{\sqrt{2}}
\begin{pmatrix}
    1 &amp; 1 \\
    1 &amp; -1
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; GateH()
H

julia&gt; matrix(GateH())
2×2 Matrix{Float64}:
 0.707107   0.707107
 0.707107  -0.707107

julia&gt; c = push!(Circuit(), GateH(), 1)
1-qubit circuit with 1 instructions:
└── H @ q[1]

julia&gt; push!(c, GateH, 1)
1-qubit circuit with 2 instructions:
├── H @ q[1]
└── H @ q[1]

julia&gt; power(GateH(), 2), inverse(GateH())
(H^2, H)
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateH())
1-qubit circuit with 1 instructions:
└── U(π/2, 0, π) @ q[1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/hadamard.jl#L17-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateID" href="#MimiqCircuitsBase.GateID"><code>MimiqCircuitsBase.GateID</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateID()</code></pre><p>Single qubit identity gate</p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{I} =
\begin{pmatrix}
    1 &amp; 0 \\
    0 &amp; 1
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; GateID()
ID

julia&gt; matrix(GateID())
2×2 Matrix{Float64}:
 1.0  -0.0
 0.0   1.0

julia&gt; c = push!(Circuit(), GateID(), 1)
1-qubit circuit with 1 instructions:
└── ID @ q[1]

julia&gt; power(GateID(), 2), inverse(GateID())
(ID, ID)
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateID())
1-qubit circuit with 1 instructions:
└── U(0, 0, 0) @ q[1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/id.jl#L17-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateS" href="#MimiqCircuitsBase.GateS"><code>MimiqCircuitsBase.GateS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateS()</code></pre><p>Single qubit <span>$S$</span> gate (or phase gate). It is defined as the square root of the <span>$Z$</span> gate.</p><p>See also <a href="#MimiqCircuitsBase.GateSDG"><code>GateSDG</code></a>, <a href="#MimiqCircuitsBase.GateZ"><code>GateZ</code></a>, <a href="#MimiqCircuitsBase.Power"><code>Power</code></a></p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{S} =
\sqrt{\operatorname{Z}} =
\begin{pmatrix}
    1 &amp; 0 \\
    0 &amp; i
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; GateS()
S

julia&gt; matrix(GateS())
2×2 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+1.0im

julia&gt; c = push!(Circuit(), GateS(), 1)
1-qubit circuit with 1 instructions:
└── S @ q[1]

julia&gt; push!(c, GateS, 2)
2-qubit circuit with 2 instructions:
├── S @ q[1]
└── S @ q[2]

julia&gt; power(GateS(), 2), inverse(GateS())
(Z, S†)
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateS())
1-qubit circuit with 1 instructions:
└── U(0, 0, π/2) @ q[1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/s.jl#L18-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateSDG" href="#MimiqCircuitsBase.GateSDG"><code>MimiqCircuitsBase.GateSDG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateSDG()</code></pre><p>Single qubit S-dagger gate (conjugate transpose of the S gate).</p><p>See also <a href="#MimiqCircuitsBase.GateS"><code>GateS</code></a>, <a href="#MimiqCircuitsBase.GateZ"><code>GateZ</code></a>, <a href="#MimiqCircuitsBase.Power"><code>Power</code></a>, <a href="#MimiqCircuitsBase.Inverse"><code>Inverse</code></a></p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname S^\dagger =
\begin{pmatrix}
    1 &amp; 0 \\
    0 &amp; -i
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; GateSDG()
S†

julia&gt; matrix(GateSDG())
2×2 adjoint(::Matrix{ComplexF64}) with eltype ComplexF64:
 1.0-0.0im  0.0-0.0im
 0.0-0.0im  0.0-1.0im

julia&gt; c = push!(Circuit(), GateSDG(), 1)
1-qubit circuit with 1 instructions:
└── S† @ q[1]

julia&gt; push!(c, GateSDG, 2)
2-qubit circuit with 2 instructions:
├── S† @ q[1]
└── S† @ q[2]

julia&gt; power(GateSDG(), 2), inverse(GateSDG())
((S†)^2, S)
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateSDG())
1-qubit circuit with 1 instructions:
└── U(0, 0, -1π/2) @ q[1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/s.jl#L81-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateT" href="#MimiqCircuitsBase.GateT"><code>MimiqCircuitsBase.GateT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateT()</code></pre><p>Single qubit T gate. It is defined as the square root of the <span>$S$</span> gate, <span>$Z^{\frac{1}{4}}$</span>.</p><p>See also <a href="#MimiqCircuitsBase.GateTDG"><code>GateTDG</code></a>, <a href="#MimiqCircuitsBase.GateS"><code>GateS</code></a>, <a href="#MimiqCircuitsBase.GateZ"><code>GateZ</code></a>, <a href="#MimiqCircuitsBase.Power"><code>Power</code></a></p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{Z} =
\operatorname{Z}^{\frac{1}{4}} =
\begin{pmatrix}
    1 &amp; 0 \\
    0 &amp; \exp(\frac{i\pi}{4})
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; GateT()
T

julia&gt; matrix(GateT())
2×2 Matrix{ComplexF64}:
 1.0+0.0im       0.0+0.0im
 0.0+0.0im  0.707107+0.707107im

julia&gt; c = push!(Circuit(), GateT(), 1)
1-qubit circuit with 1 instructions:
└── T @ q[1]

julia&gt; push!(c, GateT, 2)
2-qubit circuit with 2 instructions:
├── T @ q[1]
└── T @ q[2]

julia&gt; power(GateT(), 2), power(GateT(), 4), inverse(GateT())
(S, Z, T†)
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateT())
1-qubit circuit with 1 instructions:
└── U(0, 0, π/4) @ q[1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/t.jl#L18-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateTDG" href="#MimiqCircuitsBase.GateTDG"><code>MimiqCircuitsBase.GateTDG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateTDG()</code></pre><p>Single qubit T-dagger gate (conjugate transpose of the T gate).</p><p>See also <a href="#MimiqCircuitsBase.GateT"><code>GateT</code></a></p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname T^\dagger =
\begin{pmatrix}
    1 &amp; 0 \\
    0 &amp; \exp(\frac{-i\pi}{4})
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; GateTDG()
T†

julia&gt; matrix(GateTDG())
2×2 adjoint(::Matrix{ComplexF64}) with eltype ComplexF64:
 1.0-0.0im       0.0-0.0im
 0.0-0.0im  0.707107-0.707107im

julia&gt; c = push!(Circuit(), GateTDG(), 1)
1-qubit circuit with 1 instructions:
└── T† @ q[1]

julia&gt; push!(c, GateTDG, 2)
2-qubit circuit with 2 instructions:
├── T† @ q[1]
└── T† @ q[2]

julia&gt; power(GateTDG(), 2), power(GateTDG(), 4), inverse(GateTDG())
((T†)^2, (T†)^4, T)
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateTDG())
1-qubit circuit with 1 instructions:
└── U(0, 0, -1π/4) @ q[1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/t.jl#L81-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateSX" href="#MimiqCircuitsBase.GateSX"><code>MimiqCircuitsBase.GateSX</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateSX()</code></pre><p>Single qubit <span>$\sqrt{X}$</span> gate.</p><p>See also <a href="#MimiqCircuitsBase.GateSXDG"><code>GateSXDG</code></a>, <a href="#MimiqCircuitsBase.GateX"><code>GateX</code></a>, <a href="#MimiqCircuitsBase.Power"><code>Power</code></a></p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{SX} =
\sqrt{\operatorname{X}} =
\frac{1}{2}
\begin{pmatrix}
    1+i &amp; 1-i \\
    1-i &amp; 1+i
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; GateSX()
SX

julia&gt; matrix(GateSX())
2×2 Matrix{ComplexF64}:
 0.5+0.5im  0.5-0.5im
 0.5-0.5im  0.5+0.5im

julia&gt; c = push!(Circuit(), GateSX(), 1)
1-qubit circuit with 1 instructions:
└── SX @ q[1]

julia&gt; push!(c, GateSX, 2)
2-qubit circuit with 2 instructions:
├── SX @ q[1]
└── SX @ q[2]

julia&gt; power(GateSX(), 2), inverse(GateSX())
(X, SX†)
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateSX())
1-qubit circuit with 4 instructions:
├── S† @ q[1]
├── H @ q[1]
├── S† @ q[1]
└── U(0, 0, 0, π/4) @ q[1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/sx.jl#L17-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateSXDG" href="#MimiqCircuitsBase.GateSXDG"><code>MimiqCircuitsBase.GateSXDG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateSXDG()</code></pre><p>Single qubit <span>$\sqrt{X}^\dagger$</span> gate (conjugate transpose of the <span>$\sqrt{X}$</span> gate)</p><p>See also <a href="#MimiqCircuitsBase.GateSX"><code>GateSX</code></a>, <a href="#MimiqCircuitsBase.GateX"><code>GateX</code></a>, <a href="#MimiqCircuitsBase.Power"><code>Power</code></a>, <a href="#MimiqCircuitsBase.Inverse"><code>Inverse</code></a></p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{SXDG} =
\sqrt{\operatorname{X}}^\dagger =
\frac{1}{2}
\begin{pmatrix}
    1-i &amp; 1+i \\
    1+i &amp; 1-i
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; GateSXDG()
SX†

julia&gt; matrix(GateSXDG())
2×2 adjoint(::Matrix{ComplexF64}) with eltype ComplexF64:
 0.5-0.5im  0.5+0.5im
 0.5+0.5im  0.5-0.5im

julia&gt; c = push!(Circuit(), GateSXDG(), 1)
1-qubit circuit with 1 instructions:
└── SX† @ q[1]

julia&gt; push!(c, GateSXDG, 2)
2-qubit circuit with 2 instructions:
├── SX† @ q[1]
└── SX† @ q[2]

julia&gt; power(GateSXDG(), 2), inverse(GateSXDG())
((SX†)^2, SX)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/sx.jl#L85-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateR" href="#MimiqCircuitsBase.GateR"><code>MimiqCircuitsBase.GateR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateR(θ, ϕ)</code></pre><p>Single qubit parametric rotation <span>$\operatorname{R}(\theta, \lambda)$</span> gate.</p><p>It performs a rotation of <span>$\theta$</span> radians for the target qubit around an XY-plane axis of the Bloch sphere determined by <span>$\cos(\phi)\mathbf{x} + \sin(\phi)\mathbf{y}$</span>.</p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{R}(\theta,\phi) =
\begin{pmatrix}
    \cos\frac{\theta}{2} &amp; -ie^{-i\phi}\sin\frac{\theta}{2} \\
    -ie^{i\phi}\sin\frac{\theta}{2} &amp; \cos\frac{\theta}{2}
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables θ ϕ
2-element Vector{Symbolics.Num}:
 θ
 ϕ

julia&gt; GateR(θ, ϕ)
R(θ, ϕ)

julia&gt; matrix(GateR(2.023, 1.989))
2×2 Matrix{ComplexF64}:
 0.53059+0.0im       -0.77458+0.344239im
 0.77458+0.344239im   0.53059+0.0im

julia&gt; c = push!(Circuit(), GateR(θ, ϕ), 1)
1-qubit circuit with 1 instructions:
└── R(θ, ϕ) @ q[1]

julia&gt; push!(c, GateR(π/2, π/4), 2)
2-qubit circuit with 2 instructions:
├── R(θ, ϕ) @ q[1]
└── R(π/2, π/4) @ q[2]
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateR(θ, ϕ))
1-qubit circuit with 1 instructions:
└── U3(θ, -1.5707963267948966 + ϕ, 1.5707963267948966 - ϕ) @ q[1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/rotations.jl#L260-L314">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateRX" href="#MimiqCircuitsBase.GateRX"><code>MimiqCircuitsBase.GateRX</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateRX(θ)</code></pre><p>Single qubit parametric rotation <span>$\operatorname{R}_X(\theta)$</span> gate.</p><p>It performs a rotation of <span>$\theta$</span> radians around the X-axis of the Bloch sphere of the target qubit.</p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{R}_X(\theta) =
\begin{pmatrix}
    \cos\frac{\theta}{2} &amp; -i\sin\frac{\theta}{2} \\
    -i\sin\frac{\theta}{2} &amp; \cos\frac{\theta}{2}
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables θ
1-element Vector{Symbolics.Num}:
 θ

julia&gt; GateRX(θ)
RX(θ)

julia&gt; matrix(GateRX(1.989))
2×2 Matrix{ComplexF64}:
 0.544922+0.0im            0.0-0.838487im
      0.0-0.838487im  0.544922+0.0im

julia&gt; c = push!(Circuit(), GateRX(θ), 1)
1-qubit circuit with 1 instructions:
└── RX(θ) @ q[1]

julia&gt; push!(c, GateRX(π/2), 2)
2-qubit circuit with 2 instructions:
├── RX(θ) @ q[1]
└── RX(π/2) @ q[2]
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateRX(θ))
1-qubit circuit with 1 instructions:
└── U(θ, -1π/2, π/2) @ q[1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/rotations.jl#L17-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateRY" href="#MimiqCircuitsBase.GateRY"><code>MimiqCircuitsBase.GateRY</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateRY(θ)</code></pre><p>Single qubit parametric rotation <span>$\operatorname{R}_Y(\theta)$</span> gate.</p><p>It performss a rotation of <span>$\theta$</span> radians around the Y-axis of the Bloch sphere of the target qubit.</p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{R}_Y(\theta) =
\begin{pmatrix}
    \cos\frac{\theta}{2} &amp; -\sin\frac{\theta}{2} \\
    \sin\frac{\theta}{2} &amp; \cos\frac{\theta}{2}
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables θ
1-element Vector{Symbolics.Num}:
 θ

julia&gt; GateRY(θ)
RY(θ)

julia&gt; matrix(GateRY(1.989))
2×2 Matrix{Float64}:
 0.544922  -0.838487
 0.838487   0.544922

julia&gt; c = push!(Circuit(), GateRY(θ), 1)
1-qubit circuit with 1 instructions:
└── RY(θ) @ q[1]

julia&gt; push!(c, GateRY(π/2), 2)
2-qubit circuit with 2 instructions:
├── RY(θ) @ q[1]
└── RY(π/2) @ q[2]
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateRY(θ))
1-qubit circuit with 1 instructions:
└── U(θ, 0, 0) @ q[1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/rotations.jl#L98-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateRZ" href="#MimiqCircuitsBase.GateRZ"><code>MimiqCircuitsBase.GateRZ</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateRZ(λ)</code></pre><p>Single qubit parametric rotation <span>$\operatorname{R}_Z(\lambda)$</span> gate.</p><p>It performs a rotation of <span>$\lambda$</span> radians around the Z-axis of the Bloch sphere for the target qubit.</p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{RZ}(\lambda) =
\begin{pmatrix}
    e^{-i\frac{\lambda}{2}} &amp; 0 \\
    0 &amp; e^{i\frac{\lambda}{2}}
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables θ
1-element Vector{Symbolics.Num}:
 θ

julia&gt; GateRZ(θ)
RZ(θ)

julia&gt; matrix(GateRZ(1.989))
2×2 Matrix{ComplexF64}:
 0.544922-0.838487im       0.0+0.0im
      0.0+0.0im       0.544922+0.838487im

julia&gt; c = push!(Circuit(), GateRZ(θ), 1)
1-qubit circuit with 1 instructions:
└── RZ(θ) @ q[1]

julia&gt; push!(c, GateRZ(π/2), 2)
2-qubit circuit with 2 instructions:
├── RZ(θ) @ q[1]
└── RZ(π/2) @ q[2]
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateRZ(θ))
1-qubit circuit with 1 instructions:
└── U(0, 0, θ, (-1//2)*θ) @ q[1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/rotations.jl#L179-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateSWAP" href="#MimiqCircuitsBase.GateSWAP"><code>MimiqCircuitsBase.GateSWAP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateSWAP()</code></pre><p>Two qubit SWAP gate.</p><p>See also <a href="#MimiqCircuitsBase.GateISWAP"><code>GateISWAP</code></a>, <a href="#MimiqCircuitsBase.GateCSWAP"><code>GateCSWAP</code></a></p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{SWAP} = \frac{1}{\sqrt{2}}
\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; GateSWAP()
SWAP

julia&gt; matrix(GateSWAP())
4×4 Matrix{Float64}:
 1.0  0.0  0.0  0.0
 0.0  0.0  1.0  0.0
 0.0  1.0  0.0  0.0
 0.0  0.0  0.0  1.0

julia&gt; c = push!(Circuit(), GateSWAP(), 1, 2)
2-qubit circuit with 1 instructions:
└── SWAP @ q[1:2]

julia&gt; push!(c, GateSWAP, 3, 4)
4-qubit circuit with 2 instructions:
├── SWAP @ q[1:2]
└── SWAP @ q[3:4]

julia&gt; power(GateSWAP(), 2), inverse(GateSWAP())
(Parallel(2, ID), SWAP)
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateSWAP())
2-qubit circuit with 3 instructions:
├── CX @ q[1], q[2]
├── CX @ q[2], q[1]
└── CX @ q[1], q[2]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/swap.jl#L17-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateISWAP" href="#MimiqCircuitsBase.GateISWAP"><code>MimiqCircuitsBase.GateISWAP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateISWAP()</code></pre><p>Two qubit ISWAP gate.</p><p>See also <a href="#MimiqCircuitsBase.GateSWAP"><code>GateSWAP</code></a>.</p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{ISWAP} = \frac{1}{\sqrt{2}}
\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; i &amp; 0 \\
    0 &amp; i &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; GateISWAP()
ISWAP

julia&gt; matrix(GateISWAP())
4×4 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+1.0im  0.0+0.0im
 0.0+0.0im  0.0+1.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  1.0+0.0im

julia&gt; c = push!(Circuit(), GateISWAP(), 1, 2)
2-qubit circuit with 1 instructions:
└── ISWAP @ q[1:2]

julia&gt; push!(c, GateISWAP, 3, 4)
4-qubit circuit with 2 instructions:
├── ISWAP @ q[1:2]
└── ISWAP @ q[3:4]

julia&gt; power(GateISWAP(), 2), inverse(GateISWAP())
(ISWAP^2, ISWAP†)
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateISWAP())
2-qubit circuit with 6 instructions:
├── S @ q[1]
├── S @ q[2]
├── H @ q[1]
├── CX @ q[1], q[2]
├── CX @ q[2], q[1]
└── H @ q[2]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/iswap.jl#L17-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateCX" href="#MimiqCircuitsBase.GateCX"><code>MimiqCircuitsBase.GateCX</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateCX()</code></pre><p>Two qubit Controlled-<span>$X$</span> gate (or CNOT).</p><details class="admonition is-details"><summary class="admonition-header">Details</summary><div class="admonition-body"><p>Implemented as an alias to <code>Control(1, GateX())</code>.</p></div></details><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>By convention we refer to the first qubit as the control qubit and the second qubit as the target.</p></div></div><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{CX} =
\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 \\
    0 &amp; 0 &amp; 1 &amp; 0
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; GateCX(), numcontrols(GateCX()), numtargets(GateCX())
(CX, 1, 1)

julia&gt; matrix(GateCX())
4×4 Matrix{Float64}:
 1.0  0.0  0.0  0.0
 0.0  1.0  0.0  0.0
 0.0  0.0  0.0  1.0
 0.0  0.0  1.0  0.0

julia&gt; c = push!(Circuit(), GateCX(), 1, 2)
2-qubit circuit with 1 instructions:
└── CX @ q[1], q[2]

julia&gt; power(GateCX(), 2), inverse(GateCX())
(CID, CX)
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateCX())
2-qubit circuit with 1 instructions:
└── CX @ q[1], q[2]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/cpauli.jl#L17-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateCY" href="#MimiqCircuitsBase.GateCY"><code>MimiqCircuitsBase.GateCY</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateCY()</code></pre><p>Two qubit Controlled-<span>$Y$</span> gate.</p><details class="admonition is-details"><summary class="admonition-header">Details</summary><div class="admonition-body"><p>Implemented as an alias to <code>Control(1, GateY())</code>.</p></div></details><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>By convention we refer to the first qubit as the control qubit and the second qubit as the target.</p></div></div><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{CY} = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; -i \\
    0 &amp; 0 &amp; i &amp; 0
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; GateCY(), numcontrols(GateCY()), numtargets(GateCY())
(CY, 1, 1)

julia&gt; matrix(GateCY())
4×4 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0-1.0im
 0.0+0.0im  0.0+0.0im  0.0+1.0im  0.0+0.0im

julia&gt; c = push!(Circuit(), GateCY(), 1, 2)
2-qubit circuit with 1 instructions:
└── CY @ q[1], q[2]

julia&gt; power(GateCY(), 2), inverse(GateCY())
(CID, CY)
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateCY())
2-qubit circuit with 3 instructions:
├── S† @ q[2]
├── CX @ q[1], q[2]
└── S @ q[2]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/cpauli.jl#L78-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateCZ" href="#MimiqCircuitsBase.GateCZ"><code>MimiqCircuitsBase.GateCZ</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateCZ()</code></pre><p>Two qubit Controlled-<span>$Z$</span> gate.</p><details class="admonition is-details"><summary class="admonition-header">Details</summary><div class="admonition-body"><p>Implemented as an alias to <code>Control(1, GateZ())</code>.</p></div></details><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>By convention we refer to the first qubit as the control qubit and the second qubit as the target.</p></div></div><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{CZ} = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; -1
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; GateCZ(), numcontrols(GateCZ()), numtargets(GateCZ())
(CZ, 1, 1)

julia&gt; matrix(GateCZ())
4×4 Matrix{Float64}:
 1.0  0.0  0.0   0.0
 0.0  1.0  0.0   0.0
 0.0  0.0  1.0   0.0
 0.0  0.0  0.0  -1.0

julia&gt; c = push!(Circuit(), GateCZ(), 1, 2)
2-qubit circuit with 1 instructions:
└── CZ @ q[1], q[2]

julia&gt; power(GateCZ(), 2), inverse(GateCZ())
(CID, CZ)
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateCZ())
2-qubit circuit with 3 instructions:
├── H @ q[2]
├── CX @ q[1], q[2]
└── H @ q[2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/cpauli.jl#L143-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateCH" href="#MimiqCircuitsBase.GateCH"><code>MimiqCircuitsBase.GateCH</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateCH()</code></pre><p>Two qubit controlled-Hadamard gate.</p><details class="admonition is-details"><summary class="admonition-header">Details</summary><div class="admonition-body"><p>Implemented as an alias to <code>Control(1, GateH())</code>.</p></div></details><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>By convention, the first qubit is the control and the second is the target.</p></div></div><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{CH} = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\
    0 &amp; 0 &amp; \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; GateCH(), numcontrols(GateCH), numtargets(GateCH)
(CH, 1, 1)

julia&gt; matrix(GateCH())
4×4 Matrix{Float64}:
 1.0  0.0  0.0        0.0
 0.0  1.0  0.0        0.0
 0.0  0.0  0.707107   0.707107
 0.0  0.0  0.707107  -0.707107

julia&gt; c = push!(Circuit(), GateCH(), 1, 2)
2-qubit circuit with 1 instructions:
└── CH @ q[1], q[2]

julia&gt; power(GateCH(), 2), inverse(GateCH())
(C(H^2), CH)
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateCH())
2-qubit circuit with 7 instructions:
├── S @ q[2]
├── H @ q[2]
├── T @ q[2]
├── CX @ q[1], q[2]
├── T† @ q[2]
├── H @ q[2]
└── S† @ q[2]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/chadamard.jl#L17-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateCS" href="#MimiqCircuitsBase.GateCS"><code>MimiqCircuitsBase.GateCS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateCS()</code></pre><p>Two qubit Controlled-S gate.</p><details class="admonition is-details"><summary class="admonition-header">Details</summary><div class="admonition-body"><p>Implemented as an alias to <code>Control(1, GateS())</code>.</p></div></details><p>See also <a href="#MimiqCircuitsBase.GateS"><code>GateS</code></a>, <a href="#MimiqCircuitsBase.Control"><code>Control</code></a>.</p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{CS} =\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; i
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; GateCS(), numcontrols(GateCS()), numtargets(GateCS())
(CS, 1, 1)

julia&gt; matrix(GateCS())
4×4 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+1.0im

julia&gt; c = push!(Circuit(), GateCS(), 1, 2)
2-qubit circuit with 1 instructions:
└── CS @ q[1], q[2]

julia&gt; power(GateCS(), 2), inverse(GateCS())
(CZ, C(S†))
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateCS())
2-qubit circuit with 1 instructions:
└── CP(π/2) @ q[1], q[2]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/cs.jl#L17-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateCSDG" href="#MimiqCircuitsBase.GateCSDG"><code>MimiqCircuitsBase.GateCSDG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateCSDG()

Adjoint of two qubit Controlled-S gate.</code></pre><details class="admonition is-details"><summary class="admonition-header">Details</summary><div class="admonition-body"><p>Implemented as an alias to <code>inverse(Control(1, GateS()))</code>.</p></div></details><p>See also <a href="#MimiqCircuitsBase.GateS"><code>GateS</code></a>, <a href="#MimiqCircuitsBase.Control"><code>Control</code></a>.</p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{CS}^{\dagger} = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; -i
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; GateCSDG(), numcontrols(GateCSDG()), numtargets(GateCSDG())
(C(S†), 1, 1)

julia&gt; matrix(GateCSDG())
4×4 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  1.0-0.0im  0.0-0.0im
 0.0+0.0im  0.0+0.0im  0.0-0.0im  0.0-1.0im

julia&gt; c = push!(Circuit(), GateCSDG(), 1, 2)
2-qubit circuit with 1 instructions:
└── C(S†) @ q[1], q[2]

julia&gt; power(GateCSDG(), 2), inverse(GateCSDG())
(C((S†)^2), CS)
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateCSDG())
2-qubit circuit with 1 instructions:
└── CP(-1π/2) @ q[1], q[2]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/cs.jl#L77-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateCSX" href="#MimiqCircuitsBase.GateCSX"><code>MimiqCircuitsBase.GateCSX</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateCSX()

Two qubit Controled-SX gate.</code></pre><details class="admonition is-details"><summary class="admonition-header">Details</summary><div class="admonition-body"><p>Implemented as an alias to <code>Control(1, GateSX())</code>.</p></div></details><p>See also <a href="#MimiqCircuitsBase.GateSX"><code>GateSX</code></a>, <a href="#MimiqCircuitsBase.GateCSXDG"><code>GateCSXDG</code></a>, <a href="#MimiqCircuitsBase.Control"><code>Control</code></a>.</p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{CSX} =\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; \frac{1+i}{2} &amp; \frac{1-i}{2} \\
    0 &amp; 0 &amp; \frac{1-i}{2} &amp; \frac{1+i}{2}
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; GateCSX(), numcontrols(GateCSX()), numtargets(GateCSX())
(CSX, 1, 1)

julia&gt; matrix(GateCSX())
4×4 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.5+0.5im  0.5-0.5im
 0.0+0.0im  0.0+0.0im  0.5-0.5im  0.5+0.5im

julia&gt; c = push!(Circuit(), GateCSX(), 1, 2)
2-qubit circuit with 1 instructions:
└── CSX @ q[1], q[2]

julia&gt; power(GateCSX(), 2), inverse(GateCSX())
(CX, C(SX†))
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateCSX())
2-qubit circuit with 3 instructions:
├── H @ q[2]
├── CU1(π/2) @ q[1], q[2]
└── H @ q[2]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/csx.jl#L17-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateCSXDG" href="#MimiqCircuitsBase.GateCSXDG"><code>MimiqCircuitsBase.GateCSXDG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateCSXDG()</code></pre><p>Two qubit CSX-dagger gate. (Control on second qubit)</p><details class="admonition is-details"><summary class="admonition-header">Details</summary><div class="admonition-body"><p>Implemented as an alias to <code>Control(1, GateSXDG())</code>.</p></div></details><p>See also <a href="#MimiqCircuitsBase.GateSX"><code>GateSX</code></a>, <a href="#MimiqCircuitsBase.GateCSXDG"><code>GateCSXDG</code></a>, <a href="#MimiqCircuitsBase.Control"><code>Control</code></a>.</p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{CSX}^{\dagger} = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0
    0 &amp; 0 &amp; \frac{1-i}{2} &amp; \frac{1+i}{2} \\
    0 &amp; 0 &amp; \frac{1+i}{2} &amp; \frac{1-i}{2}
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; GateCSXDG(), numcontrols(GateCSXDG()), numtargets(GateCSXDG())
(C(SX†), 1, 1)

julia&gt; matrix(GateCSXDG())
4×4 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.5-0.5im  0.5+0.5im
 0.0+0.0im  0.0+0.0im  0.5+0.5im  0.5-0.5im

julia&gt; c = push!(Circuit(), GateCSXDG(), 1, 2)
2-qubit circuit with 1 instructions:
└── C(SX†) @ q[1], q[2]

julia&gt; power(GateCSXDG(), 2), inverse(GateCSXDG())
(C((SX†)^2), CSX)
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateCSXDG())
2-qubit circuit with 3 instructions:
├── H @ q[2]
├── CU1(-1π/2) @ q[1], q[2]
└── H @ q[2]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/csx.jl#L81-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateCU" href="#MimiqCircuitsBase.GateCU"><code>MimiqCircuitsBase.GateCU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateCU(θ, ϕ, λ)</code></pre><p>Controlled-<span>$\operatorname{U}(\theta, \phi, \lambda)$</span> gate.</p><details class="admonition is-details"><summary class="admonition-header">Details</summary><div class="admonition-body"><p>Implemented as an alias to <code>Control(1, GateU(θ, ϕ, λ, γ))</code>.</p></div></details><p>See also <a href="#MimiqCircuitsBase.Control"><code>Control</code></a>, <a href="#MimiqCircuitsBase.GateU"><code>GateU</code></a>.</p><p class="math-container">\[\operatorname{CU}(\theta, \phi, \lambda, \gamma) =
\frac{1}{2} \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; e^{i\gamma} \cos\left(\frac{\theta}{2}\right) &amp; -e^{i\gamma} e^{i\lambda}\sin\left(\frac{\theta}{2}\right) \\
    0 &amp; 0 &amp; e^{i\gamma} \mathrm{e}^{i\phi}\sin\left(\frac{\theta}{2}\right) &amp; e^{i\gamma} \mathrm{e}^{i(\phi+\lambda)}\cos\left(\frac{\theta}{2}\right)
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables θ ϕ λ γ
4-element Vector{Symbolics.Num}:
 θ
 ϕ
 λ
 γ

julia&gt; GateCU(θ, ϕ, λ, γ), numcontrols(GateCU(θ, ϕ, λ, γ)), numtargets(GateCU(θ, ϕ, λ, γ))
(CU(θ, ϕ, λ, γ), 1, 1)

julia&gt; matrix(GateCU(2.023, 0.5, 0.1, 0.2))
4×4 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im       0.0+0.0im             0.0+0.0im
 0.0+0.0im  1.0+0.0im       0.0+0.0im             0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.520013+0.105412im  -0.809771-0.250491im
 0.0+0.0im  0.0+0.0im  0.648302+0.546057im   0.369666+0.380622im

julia&gt; c = push!(Circuit(), GateCU(θ, ϕ, λ, γ), 1, 2)
2-qubit circuit with 1 instructions:
└── CU(θ, ϕ, λ, γ) @ q[1], q[2]

julia&gt; push!(c, GateCU(π/8, π/2, π/4, π/7), 1, 2)
2-qubit circuit with 2 instructions:
├── CU(θ, ϕ, λ, γ) @ q[1], q[2]
└── CU(π/8, π/2, π/4, π/7) @ q[1], q[2]

julia&gt; power(GateCU(θ, ϕ, λ, γ), 2), inverse(GateCU(θ, ϕ, λ, γ))
(C(U(θ, ϕ, λ, γ)^2), CU(-θ, -λ, -ϕ, -γ))
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateCU(θ, λ, ϕ, γ))
2-qubit circuit with 7 instructions:
├── P(γ) @ q[1]
├── P((1//2)*(λ + ϕ)) @ q[1]
├── P((1//2)*(-λ + ϕ)) @ q[2]
├── CX @ q[1], q[2]
├── U((-1//2)*θ, 0, (1//2)*(-λ - ϕ)) @ q[2]
├── CX @ q[1], q[2]
└── U((1//2)*θ, λ, 0) @ q[2]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/cu.jl#L17-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateCP" href="#MimiqCircuitsBase.GateCP"><code>MimiqCircuitsBase.GateCP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateCP(θ)</code></pre><p>Controlled-<span>$\operatorname{P}(\lambda)$</span> gate.</p><details class="admonition is-details"><summary class="admonition-header">Details</summary><div class="admonition-body"><p>Implemented as an alias to <code>Control(GateP(θ))</code>.</p></div></details><p>See also <a href="#MimiqCircuitsBase.Control"><code>Control</code></a>, <a href="#MimiqCircuitsBase.GateRZ"><code>GateRZ</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables λ
1-element Vector{Symbolics.Num}:
 λ

julia&gt; GateCP(λ), numcontrols(GateCP(λ)), numtargets(GateCP(λ))
(CP(λ), 1, 1)

julia&gt; matrix(GateCP(1.989))
4×4 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im  0.0+0.0im       0.0+0.0im
 0.0+0.0im  1.0+0.0im  0.0+0.0im       0.0+0.0im
 0.0+0.0im  0.0+0.0im  1.0+0.0im       0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  -0.40612+0.91382im

julia&gt; c = push!(Circuit(), GateCP(λ), 1, 2)
2-qubit circuit with 1 instructions:
└── CP(λ) @ q[1], q[2]

julia&gt; push!(c, GateCP(π/8), 1, 2)
2-qubit circuit with 2 instructions:
├── CP(λ) @ q[1], q[2]
└── CP(π/8) @ q[1], q[2]

julia&gt; power(GateCP(λ), 2), inverse(GateCP(λ))
(CP(2λ), CP(-λ))
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables θ
1-element Vector{Symbolics.Num}:
 θ

julia&gt; decompose(GateCP(θ))
2-qubit circuit with 5 instructions:
├── P((1//2)*θ) @ q[1]
├── CX @ q[1], q[2]
├── P((-1//2)*θ) @ q[2]
├── CX @ q[1], q[2]
└── P((1//2)*θ) @ q[2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/cphase.jl#L17-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateCRX" href="#MimiqCircuitsBase.GateCRX"><code>MimiqCircuitsBase.GateCRX</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateCRX(θ)</code></pre><p>Controlled-<span>$\operatorname{R}_X(\theta)$</span> gate.</p><details class="admonition is-details"><summary class="admonition-header">Details</summary><div class="admonition-body"><p>Implemented as an alias to <code>Control(GateRX(θ))</code>.</p></div></details><p>See also <a href="#MimiqCircuitsBase.Control"><code>Control</code></a>, <a href="#MimiqCircuitsBase.GateRX"><code>GateRX</code></a>.</p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{CRX}(\theta) = \begin{pmatrix}
            1 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 1 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; \cos\frac{\theta}{2} &amp; -i\sin\frac{\theta}{2} \\
            0 &amp; 0 &amp; -i\sin\frac{\theta}{2} &amp; \cos\frac{\theta}{2}
        \end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables θ
1-element Vector{Symbolics.Num}:
 θ

julia&gt; GateCRX(θ), numcontrols(GateCRX(θ)), numtargets(GateCRX(θ))
(CRX(θ), 1, 1)

julia&gt; matrix(GateCRX(1.989))
4×4 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im       0.0+0.0im            0.0+0.0im
 0.0+0.0im  1.0+0.0im       0.0+0.0im            0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.544922+0.0im            0.0-0.838487im
 0.0+0.0im  0.0+0.0im       0.0-0.838487im  0.544922+0.0im

julia&gt; c = push!(Circuit(), GateCRX(θ), 1, 2)
2-qubit circuit with 1 instructions:
└── CRX(θ) @ q[1], q[2]

julia&gt; push!(c, GateCRX(π/8), 1, 2)
2-qubit circuit with 2 instructions:
├── CRX(θ) @ q[1], q[2]
└── CRX(π/8) @ q[1], q[2]

julia&gt; power(GateCRX(θ), 2), inverse(GateCRX(θ))
(CRX(2θ), CRX(-θ))
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateCRX(θ))
2-qubit circuit with 5 instructions:
├── P(π/2) @ q[2]
├── CX @ q[1], q[2]
├── U((-1//2)*θ, 0, 0) @ q[2]
├── CX @ q[1], q[2]
└── U((1//2)*θ, -1π/2, 0) @ q[2]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/crotations.jl#L17-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateCRY" href="#MimiqCircuitsBase.GateCRY"><code>MimiqCircuitsBase.GateCRY</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateCRY(θ)</code></pre><p>Controlled-<span>$\operatorname{R}_Y(\theta)$</span> gate.</p><details class="admonition is-details"><summary class="admonition-header">Details</summary><div class="admonition-body"><p>Implemented as an alias to <code>Control(GateRY(θ))</code>.</p></div></details><p>See also <a href="#MimiqCircuitsBase.Control"><code>Control</code></a>, <a href="#MimiqCircuitsBase.GateRY"><code>GateRY</code></a>.</p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{CRY}(\theta) = \begin{pmatrix}
            1 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 1 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; \cos\frac{\theta}{2} &amp; -\sin\frac{\theta}{2} \\
            0 &amp; 0 &amp;  \sin\frac{\theta}{2} &amp; \cos\frac{\theta}{2}
        \end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables θ
1-element Vector{Symbolics.Num}:
 θ

julia&gt; GateCRY(θ), numcontrols(GateCRY(θ)), numtargets(GateCRY(θ))
(CRY(θ), 1, 1)

julia&gt; matrix(GateCRY(1.989))
4×4 Matrix{Float64}:
 1.0  0.0  0.0        0.0
 0.0  1.0  0.0        0.0
 0.0  0.0  0.544922  -0.838487
 0.0  0.0  0.838487   0.544922

julia&gt; c = push!(Circuit(), GateCRY(θ), 1, 2)
2-qubit circuit with 1 instructions:
└── CRY(θ) @ q[1], q[2]

julia&gt; push!(c, GateCRY(π/8), 1, 2)
2-qubit circuit with 2 instructions:
├── CRY(θ) @ q[1], q[2]
└── CRY(π/8) @ q[1], q[2]

julia&gt; power(GateCRY(θ), 2), inverse(GateCRY(θ))
(CRY(2θ), CRY(-θ))
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateCRY(θ))
2-qubit circuit with 4 instructions:
├── RY((1//2)*θ) @ q[2]
├── CX @ q[1], q[2]
├── RY((-1//2)*θ) @ q[2]
└── CX @ q[1], q[2]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/crotations.jl#L95-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateCRZ" href="#MimiqCircuitsBase.GateCRZ"><code>MimiqCircuitsBase.GateCRZ</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateCRZ(θ)</code></pre><p>Controlled-<span>$\operatorname{R}_Z(\theta)$</span> gate.</p><details class="admonition is-details"><summary class="admonition-header">Details</summary><div class="admonition-body"><p>Implemented as an alias to <code>Control(GateRZ(θ))</code>.</p></div></details><p>See also <a href="#MimiqCircuitsBase.Control"><code>Control</code></a>, <a href="#MimiqCircuitsBase.GateRZ"><code>GateRZ</code></a>.</p><p><strong>Matrix representation</strong></p><p class="math-container">\[    \operatorname{CRZ}(\theta) = \begin{pmatrix}
            1 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 1 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; e^{-i\frac{\lambda}{2}} &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; e^{i\frac{\lambda}{2}}
        \end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables θ
1-element Vector{Symbolics.Num}:
 θ

julia&gt; GateCRZ(θ), numcontrols(GateCRZ(θ)), numtargets(GateCRZ(θ))
(CRZ(θ), 1, 1)

julia&gt; matrix(GateCRZ(1.989))
4×4 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im       0.0+0.0im            0.0+0.0im
 0.0+0.0im  1.0+0.0im       0.0+0.0im            0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.544922-0.838487im       0.0+0.0im
 0.0+0.0im  0.0+0.0im       0.0+0.0im       0.544922+0.838487im

julia&gt; c = push!(Circuit(), GateCRZ(θ), 1, 2)
2-qubit circuit with 1 instructions:
└── CRZ(θ) @ q[1], q[2]

julia&gt; push!(c, GateCRZ(π/8), 1, 2)
2-qubit circuit with 2 instructions:
├── CRZ(θ) @ q[1], q[2]
└── CRZ(π/8) @ q[1], q[2]

julia&gt; power(GateCRZ(θ), 2), inverse(GateCRZ(θ))
(CRZ(2θ), CRZ(-θ))
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateCRZ(θ))
2-qubit circuit with 4 instructions:
├── RZ((1//2)*θ) @ q[2]
├── CX @ q[1], q[2]
├── RZ((-1//2)*θ) @ q[2]
└── CX @ q[1], q[2]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/crotations.jl#L171-L234">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateECR" href="#MimiqCircuitsBase.GateECR"><code>MimiqCircuitsBase.GateECR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateECR()</code></pre><p>Two qubit ECR echo gate.</p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{ECR} = \frac{1}{\sqrt{2}}
\begin{pmatrix}
    0 &amp; 1 &amp; 0 &amp; i \\
    1 &amp; 0 &amp; -i &amp; 0 \\
    0 &amp; i &amp; 0 &amp; 1 \\
    -i &amp; 0 &amp; 1 &amp; 0
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; GateECR()
ECR

julia&gt; matrix(GateECR())
4×4 Matrix{ComplexF64}:
      0.0+0.0im            0.0+0.0im       …       0.0+0.707107im
      0.0+0.0im            0.0+0.0im          0.707107+0.0im
 0.707107+0.0im            0.0-0.707107im          0.0+0.0im
      0.0-0.707107im  0.707107+0.0im               0.0+0.0im

julia&gt; c = push!(Circuit(), GateECR(), 1, 2)
2-qubit circuit with 1 instructions:
└── ECR @ q[1:2]

julia&gt; power(GateECR(), 2), inverse(GateECR())
(Parallel(2, ID), ECR)
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateECR())
2-qubit circuit with 3 instructions:
├── RZX(π/4) @ q[1:2]
├── X @ q[1]
└── RZX(-1π/4) @ q[1:2]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/ecr.jl#L17-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateDCX" href="#MimiqCircuitsBase.GateDCX"><code>MimiqCircuitsBase.GateDCX</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateDCX()</code></pre><p>Two qubit double-CNOT (control on first qubit and then second) OR DCX gate.</p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{DCX}= \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 \\
    0 &amp; 1 &amp; 0 &amp; 0
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; GateDCX()
DCX

julia&gt; matrix(GateDCX())
4×4 Matrix{Float64}:
 1.0  0.0  0.0  0.0
 0.0  0.0  1.0  0.0
 0.0  0.0  0.0  1.0
 0.0  1.0  0.0  0.0

julia&gt; c = push!(Circuit(), GateDCX(), 1, 2)
2-qubit circuit with 1 instructions:
└── DCX @ q[1:2]

julia&gt; power(GateDCX(), 2), inverse(GateDCX())
(DCX†, DCX†)
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateDCX())
2-qubit circuit with 2 instructions:
├── CX @ q[1], q[2]
└── CX @ q[2], q[1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/dcx.jl#L17-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateRXX" href="#MimiqCircuitsBase.GateRXX"><code>MimiqCircuitsBase.GateRXX</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateRXX(θ)</code></pre><p>Parametric two qubit <span>$X \otimes X$</span> interaction <code>\operatorname{R}_{XX}(\theta)</code> gate.</p><p>It corresponds to a rotation of <span>$\theta$</span> radians along the XX axis of the two-qubit Bloch sphere.</p><p>See also <a href="#MimiqCircuitsBase.GateRYY"><code>GateRYY</code></a>, <a href="#MimiqCircuitsBase.GateRZZ"><code>GateRZZ</code></a>, <a href="#MimiqCircuitsBase.GateRZX"><code>GateRZX</code></a>, <a href="#MimiqCircuitsBase.GateXXplusYY"><code>GateXXplusYY</code></a>, <a href="#MimiqCircuitsBase.GateXXminusYY"><code>GateXXminusYY</code></a>.</p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{R}_{XX}(\theta) =
\begin{pmatrix}
    \cos(\\frac{\theta}{2}) &amp; 0 &amp; 0 &amp; -i\sin(\\frac{\theta}{2}) \\
    0 &amp; \cos(\frac{\theta}{2}) &amp; -i\sin(\frac{\theta}{2}) &amp; 0 \\
    0 &amp; -i\sin(\frac{\theta}{2}) &amp; \cos(\frac{\theta}{2}) &amp; 0 \\
    -i\sin(\frac{\theta}{2}) &amp; 0 &amp; 0 &amp; \cos(\frac{\theta}{2})
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables θ
1-element Vector{Symbolics.Num}:
 θ

julia&gt; GateRXX(θ)
RXX(θ)

julia&gt; matrix(GateRXX(θ))
4×4 Matrix{Complex{Symbolics.Num}}:
     cos((1//2)*θ)                  0                  0  -im*sin((1//2)*θ)
                 0      cos((1//2)*θ)  -im*sin((1//2)*θ)                  0
                 0  -im*sin((1//2)*θ)      cos((1//2)*θ)                  0
 -im*sin((1//2)*θ)                  0                  0      cos((1//2)*θ)

julia&gt; c = push!(Circuit(), GateRXX(θ), 1, 2)
2-qubit circuit with 1 instructions:
└── RXX(θ) @ q[1:2]

julia&gt; push!(c, GateRXX(π/2), 1, 2)
2-qubit circuit with 2 instructions:
├── RXX(θ) @ q[1:2]
└── RXX(π/2) @ q[1:2]
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateRXX(θ))
2-qubit circuit with 7 instructions:
├── H @ q[1]
├── H @ q[2]
├── CX @ q[1], q[2]
├── RZ(θ) @ q[2]
├── CX @ q[1], q[2]
├── H @ q[2]
└── H @ q[1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/interactions.jl#L17-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateRYY" href="#MimiqCircuitsBase.GateRYY"><code>MimiqCircuitsBase.GateRYY</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateRYY(θ)</code></pre><p>Parametric two qubit <span>$Y \otimes Y$</span> interaction <code>\operatorname{R}_{YY}(\theta)</code> gate.</p><p>It corresponds to a rotation of <span>$\theta$</span> radians along the YY axis of the two-qubit Bloch sphere.</p><p>See also <a href="#MimiqCircuitsBase.GateRXX"><code>GateRXX</code></a>, <a href="#MimiqCircuitsBase.GateRZZ"><code>GateRZZ</code></a>, <a href="#MimiqCircuitsBase.GateRZX"><code>GateRZX</code></a>, <a href="#MimiqCircuitsBase.GateXXplusYY"><code>GateXXplusYY</code></a>, <a href="#MimiqCircuitsBase.GateXXminusYY"><code>GateXXminusYY</code></a>.</p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{R}_{YY}(\theta) =
\begin{pmatrix}
    \cos(\frac{\theta}{2}) &amp; 0 &amp; 0 &amp; i\sin(\frac{\theta}{2}) \\
    0 &amp; \cos(\frac{\theta}{2}) &amp; -i\sin(\frac{\theta}{2}) &amp; 0 \\
    0 &amp; -i\sin(\\frac{\theta}{2}) &amp; \cos(\frac{\theta}{2}) &amp; 0 \\
    i\sin(\frac{\theta}{2}) &amp; 0 &amp; 0 &amp; \cos(\frac{\theta}{2})
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables θ
1-element Vector{Symbolics.Num}:
 θ

julia&gt; GateRYY(θ)
RYY(θ)

julia&gt; matrix(GateRYY(θ))
4×4 Matrix{Complex{Symbolics.Num}}:
    cos((1//2)*θ)                  0                  0  im*sin((1//2)*θ)
                0      cos((1//2)*θ)  -im*sin((1//2)*θ)                 0
                0  -im*sin((1//2)*θ)      cos((1//2)*θ)                 0
 im*sin((1//2)*θ)                  0                  0     cos((1//2)*θ)

julia&gt; c = push!(Circuit(), GateRYY(θ), 1, 2)
2-qubit circuit with 1 instructions:
└── RYY(θ) @ q[1:2]

julia&gt; push!(c, GateRYY(π/2), 1, 2)
2-qubit circuit with 2 instructions:
├── RYY(θ) @ q[1:2]
└── RYY(π/2) @ q[1:2]
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateRYY(θ))
2-qubit circuit with 7 instructions:
├── RX(π/2) @ q[1]
├── RX(π/2) @ q[2]
├── CX @ q[1], q[2]
├── RZ(θ) @ q[2]
├── CX @ q[1], q[2]
├── RX(-1π/2) @ q[1]
└── RX(-1π/2) @ q[2]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/interactions.jl#L114-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateRZX" href="#MimiqCircuitsBase.GateRZX"><code>MimiqCircuitsBase.GateRZX</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateRZX(θ)</code></pre><p>Parametric two qubit <span>$Z \otimes X$</span> interaction <code>\operatorname{R}_{ZX}(\theta)</code> gate.</p><p>It corresponds to a rotation of <span>$\theta$</span> radians about ZX.</p><p>See also <a href="#MimiqCircuitsBase.GateRXX"><code>GateRXX</code></a>, <a href="#MimiqCircuitsBase.GateRYY"><code>GateRYY</code></a>, <a href="#MimiqCircuitsBase.GateRZZ"><code>GateRZZ</code></a>, <a href="#MimiqCircuitsBase.GateXXplusYY"><code>GateXXplusYY</code></a>, <a href="#MimiqCircuitsBase.GateXXminusYY"><code>GateXXminusYY</code></a>.</p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{RZX}(\theta) =\begin{pmatrix}
            \cos(\frac{\theta}{2}) &amp; -i\sin(\frac{\theta}{2}) &amp; 0 &amp; 0 \\
            -i\sin(\frac{\theta}{2}) &amp; \cos(\frac{\theta}{2}) &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; \cos(\frac{\theta}{2}) &amp; i\sin(\frac{\theta}{2}) \\
            0 &amp; 0 &amp; i\sin(\frac{\theta}{2}) &amp; \cos(\frac{\theta}{2})
        \end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables θ
1-element Vector{Symbolics.Num}:
 θ

julia&gt; GateRZX(θ)
RZX(θ)

julia&gt; matrix(GateRZX(θ))
4×4 Matrix{Complex{Symbolics.Num}}:
     cos((1//2)*θ)  -im*sin((1//2)*θ)                 0                 0
 -im*sin((1//2)*θ)      cos((1//2)*θ)                 0                 0
                 0                  0     cos((1//2)*θ)  im*sin((1//2)*θ)
                 0                  0  im*sin((1//2)*θ)     cos((1//2)*θ)

julia&gt; c = push!(Circuit(), GateRZX(θ), 1, 2)
2-qubit circuit with 1 instructions:
└── RZX(θ) @ q[1:2]

julia&gt; push!(c, GateRZX(π/2), 1, 2)
2-qubit circuit with 2 instructions:
├── RZX(θ) @ q[1:2]
└── RZX(π/2) @ q[1:2]
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateRZX(θ))
2-qubit circuit with 5 instructions:
├── H @ q[2]
├── CX @ q[1], q[2]
├── RZ(θ) @ q[2]
├── CX @ q[1], q[2]
└── H @ q[2]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/interactions.jl#L298-L360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateRZZ" href="#MimiqCircuitsBase.GateRZZ"><code>MimiqCircuitsBase.GateRZZ</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateRZZ(θ)</code></pre><p>Parametric two qubit <span>$Z \otimes Z$</span> interaction <code>\operatorname{R}_{ZZ}(\theta)</code> gate.</p><p>It corresponds to a rotation of <span>$\theta$</span> radians along the ZZ axis of the two-qubit Bloch sphere.</p><p>See also <a href="#MimiqCircuitsBase.GateRXX"><code>GateRXX</code></a>, <a href="#MimiqCircuitsBase.GateRYY"><code>GateRYY</code></a>, <a href="#MimiqCircuitsBase.GateRZX"><code>GateRZX</code></a>, <a href="#MimiqCircuitsBase.GateXXplusYY"><code>GateXXplusYY</code></a>, <a href="#MimiqCircuitsBase.GateXXminusYY"><code>GateXXminusYY</code></a>.</p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{R}_{ZZ}(\theta) =
\begin{pmatrix}
    e^{-i\frac{\theta}{2}} &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; e^{i\frac{\theta}{2}} &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; e^{i\frac{\theta}{2}} &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; e^{-i\frac{\theta}{2}}
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables θ
1-element Vector{Symbolics.Num}:
 θ

julia&gt; GateRZZ(θ)
RZZ(θ)

julia&gt; matrix(GateRZZ(θ))
4×4 Matrix{Complex{Symbolics.Num}}:
 cos((-1//2)*θ) + im*sin((-1//2)*θ)  …                           0
                          0                                      0
                          0                                      0
                          0             cos((-1//2)*θ) + im*sin((-1//2)*θ)

julia&gt; c = push!(Circuit(), GateRZZ(θ), 1, 2)
2-qubit circuit with 1 instructions:
└── RZZ(θ) @ q[1:2]

julia&gt; push!(c, GateRZZ(π/2), 1, 2)
2-qubit circuit with 2 instructions:
├── RZZ(θ) @ q[1:2]
└── RZZ(π/2) @ q[1:2]
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateRZZ(θ))
2-qubit circuit with 3 instructions:
├── CX @ q[1], q[2]
├── RZ(θ) @ q[2]
└── CX @ q[1], q[2]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/interactions.jl#L210-L272">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateXXminusYY" href="#MimiqCircuitsBase.GateXXminusYY"><code>MimiqCircuitsBase.GateXXminusYY</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateXXminusYY(θ, β)</code></pre><p>Parametric two qubit <span>$X \otimes X - Y \otimes Y$</span> interaction <span>$\operatorname{(XX-YY)}(\theta, \beta)$</span> gate, where <span>$\theta$</span> and <span>$\beta$</span> are the rotation and phase angles.</p><p>See also <a href="#MimiqCircuitsBase.GateRXX"><code>GateRXX</code></a>, <a href="#MimiqCircuitsBase.GateRYY"><code>GateRYY</code></a>, <a href="#MimiqCircuitsBase.GateRZZ"><code>GateRZZ</code></a>, <a href="#MimiqCircuitsBase.GateRZX"><code>GateRZX</code></a>, <a href="#MimiqCircuitsBase.GateXXplusYY"><code>GateXXplusYY</code></a>.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\operatorname{(XX-YY)}(\theta, \beta) =
\begin{pmatrix}
    \cos(\frac{\theta}{2}) &amp; 0 &amp; 0 &amp; -i\sin(\frac{\theta}{2})e^{-i\beta} \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    -i\sin(\frac{\theta}{2})e^{i\beta} &amp; 0 &amp; 0 &amp; \cos(\frac{\theta}{2})
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables θ β
2-element Vector{Symbolics.Num}:
 θ
 β

julia&gt; GateXXminusYY(θ, β)
XXminusYY(θ, β)

julia&gt; matrix(GateXXminusYY(θ, β))
4×4 Matrix{Complex{Symbolics.Num}}:
          cos((1//2)*θ)                          …  sin(-β)*sin((1//2)*θ) - im*cos(-β)*sin((1//2)*θ)
                      0                                                            0
                      0                                                            0
 sin(β)*sin((1//2)*θ) - im*cos(β)*sin((1//2)*θ)                        cos((1//2)*θ)

julia&gt; c = push!(Circuit(), GateXXminusYY(θ, β), 1, 2)
2-qubit circuit with 1 instructions:
└── XXminusYY(θ, β) @ q[1:2]

julia&gt; push!(c, GateXXminusYY(π/2, 0.0), 1, 2)
2-qubit circuit with 2 instructions:
├── XXminusYY(θ, β) @ q[1:2]
└── XXminusYY(π/2, 0π) @ q[1:2]
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateXXminusYY(θ, β))
2-qubit circuit with 14 instructions:
├── RZ(-β) @ q[2]
├── RZ(-1π/2) @ q[1]
├── SX @ q[1]
├── RZ(π/2) @ q[1]
├── S @ q[2]
├── CX @ q[1], q[2]
├── RY((1//2)*θ) @ q[1]
├── RY((-1//2)*θ) @ q[2]
├── CX @ q[1], q[2]
├── S† @ q[2]
├── RZ(-1π/2) @ q[1]
├── SX† @ q[1]
├── RZ(π/2) @ q[1]
└── RZ(β) @ q[2]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/interactions.jl#L496-L568">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateXXplusYY" href="#MimiqCircuitsBase.GateXXplusYY"><code>MimiqCircuitsBase.GateXXplusYY</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateXXplusYY(θ, β)</code></pre><p>Parametric two qubit <span>$X \otimes X + Y \otimes Y$</span> interaction <span>$\operatorname{(XX+YY)}(\theta, \beta)$</span> gate, where <span>$\theta$</span> and <span>$\beta$</span> are the rotation and phase angles.</p><p>See also <a href="#MimiqCircuitsBase.GateRXX"><code>GateRXX</code></a>, <a href="#MimiqCircuitsBase.GateRYY"><code>GateRYY</code></a>, <a href="#MimiqCircuitsBase.GateRZZ"><code>GateRZZ</code></a>, <a href="#MimiqCircuitsBase.GateRZX"><code>GateRZX</code></a>, <a href="#MimiqCircuitsBase.GateXXminusYY"><code>GateXXminusYY</code></a>.</p><p><strong>Matrix representation</strong></p><p class="math-container">\[\operatorname{(XX+YY)}(\theta, \beta) =
\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; \cos(\frac{\theta}{2}) &amp; -i\sin(\frac{\theta}{2})e^{i\beta} &amp; 0 \\
    0 &amp; -i\sin(\frac{\theta}{2})e^{-i\beta} &amp; \cos(\frac{\theta}{2}) &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables θ β
2-element Vector{Symbolics.Num}:
 θ
 β

julia&gt; GateXXplusYY(θ, β)
XXplusYY(θ, β)

julia&gt; matrix(GateXXplusYY(θ, β))
4×4 Matrix{Complex{Symbolics.Num}}:
 1                                 0                  …  0
 0                     cos((1//2)*θ)                     0
 0  sin(-β)*sin((1//2)*θ) - im*cos(-β)*sin((1//2)*θ)     0
 0                                 0                     1

julia&gt; c = push!(Circuit(), GateXXplusYY(θ, β), 1, 2)
2-qubit circuit with 1 instructions:
└── XXplusYY(θ, β) @ q[1:2]

julia&gt; push!(c, GateXXplusYY(π/2, 0), 1, 2)
2-qubit circuit with 2 instructions:
├── XXplusYY(θ, β) @ q[1:2]
└── XXplusYY(π/2, 0) @ q[1:2]
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateXXplusYY(θ, β))
2-qubit circuit with 14 instructions:
├── RZ(β) @ q[1]
├── RZ(-1π/2) @ q[2]
├── SX @ q[2]
├── RZ(π/2) @ q[2]
├── S @ q[1]
├── CX @ q[2], q[1]
├── RY((-1//2)*θ) @ q[2]
├── RY((-1//2)*θ) @ q[1]
├── CX @ q[2], q[1]
├── S† @ q[1]
├── RZ(-1π/2) @ q[2]
├── SX† @ q[2]
├── RZ(π/2) @ q[2]
└── RZ(-β) @ q[1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/interactions.jl#L388-L460">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateCSWAP" href="#MimiqCircuitsBase.GateCSWAP"><code>MimiqCircuitsBase.GateCSWAP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateCSWAP()</code></pre><p>Three-qubit, controlled-<span>$\operatorname{SWAP}$</span> gate.</p><details class="admonition is-details"><summary class="admonition-header">Details</summary><div class="admonition-body"><p>Implemented as an alias to <code>Control{1,2,3,GateSWAP}</code>.</p></div></details><p>See also <a href="#MimiqCircuitsBase.Control"><code>Control</code></a>, <a href="#MimiqCircuitsBase.GateU"><code>GateU</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>By convention, the first qubit is the control and the last two are targets.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; GateCSWAP(), numcontrols(GateCSWAP()), numtargets(GateCSWAP())
(CSWAP, 1, 2)

julia&gt; matrix(GateCSWAP())
8×8 Matrix{Float64}:
 1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0
 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0

julia&gt; c = push!(Circuit(), GateCSWAP(), 1, 2, 3)
3-qubit circuit with 1 instructions:
└── CSWAP @ q[1], q[2:3]

julia&gt; power(GateCSWAP(), 2), inverse(GateCSWAP())
(C(Parallel(2, ID)), CSWAP)
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateCSWAP())
3-qubit circuit with 3 instructions:
├── CX @ q[3], q[2]
├── C₂X @ q[1:2], q[3]
└── CX @ q[3], q[2]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/cswap.jl#L17-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateC3X" href="#MimiqCircuitsBase.GateC3X"><code>MimiqCircuitsBase.GateC3X</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateC3X()</code></pre><p>Four qubit, triply-controlled <span>$X$</span> gate.</p><details class="admonition is-details"><summary class="admonition-header">Details</summary><div class="admonition-body"><p>Implemented as an alias to <span>$Control(3, GateX())$</span>.</p></div></details><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>By convention, the first three qubits are the controls and the fourth is the target.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; GateC3X(), numcontrols(GateC3X()), numtargets(GateC3X())
(C₃X, 3, 1)

julia&gt; matrix(GateC3X())
16×16 Matrix{Float64}:
 1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     1.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  1.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  1.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  1.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  1.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  1.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  1.0  0.0

julia&gt; c = push!(Circuit(), GateC3X(), 1, 2, 3, 4)
4-qubit circuit with 1 instructions:
└── C₃X @ q[1:3], q[4]

julia&gt; power(GateC3X(), 2), inverse(GateC3X())
(C₃ID, C₃X)
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateC3X())
4-qubit circuit with 31 instructions:
├── H @ q[4]
├── P(π/8) @ q[1]
├── P(π/8) @ q[2]
├── P(π/8) @ q[3]
├── P(π/8) @ q[4]
├── CX @ q[1], q[2]
├── P(-1π/8) @ q[2]
├── CX @ q[1], q[2]
├── CX @ q[2], q[3]
⋮   ⋮
├── CX @ q[1], q[4]
├── P(π/8) @ q[4]
├── CX @ q[3], q[4]
├── P(-1π/8) @ q[4]
├── CX @ q[2], q[4]
├── P(π/8) @ q[4]
├── CX @ q[3], q[4]
├── P(-1π/8) @ q[4]
├── CX @ q[1], q[4]
└── H @ q[4]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/cnx.jl#L107-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateCCX" href="#MimiqCircuitsBase.GateCCX"><code>MimiqCircuitsBase.GateCCX</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateCCX()</code></pre><p>Three-qubit, doubly-controlled <span>$X$</span> gate.</p><details class="admonition is-details"><summary class="admonition-header">Details</summary><div class="admonition-body"><p>Implemented as an alias to <span>$Control(2, GateX())$</span>.</p></div></details><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>By convention, the first two qubits are the controls and the third is the target.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; GateCCX(), numcontrols(GateCCX()), numtargets(GateCCX())
(C₂X, 2, 1)

julia&gt; matrix(GateCCX())
8×8 Matrix{Float64}:
 1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0
 0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0

julia&gt; c = push!(Circuit(), GateCCX(), 1, 2, 3)
3-qubit circuit with 1 instructions:
└── C₂X @ q[1:2], q[3]

julia&gt; power(GateCCX(), 2), inverse(GateCCX())
(C₂ID, C₂X)
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decompose(GateCCX())
3-qubit circuit with 15 instructions:
├── H @ q[3]
├── CX @ q[2], q[3]
├── T† @ q[3]
├── CX @ q[1], q[3]
├── T @ q[3]
├── CX @ q[2], q[3]
├── T† @ q[3]
├── CX @ q[1], q[3]
├── T @ q[2]
├── T @ q[3]
├── H @ q[3]
├── CX @ q[1], q[2]
├── T @ q[1]
├── T† @ q[2]
└── CX @ q[1], q[2]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/cnx.jl#L17-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateCCP" href="#MimiqCircuitsBase.GateCCP"><code>MimiqCircuitsBase.GateCCP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateCCP(λ)</code></pre><p>Three-qubit, doubly-controlled phase gate.</p><details class="admonition is-details"><summary class="admonition-header">Details</summary><div class="admonition-body"><p>Implemented as an alias to <span>$Control(2, GateP(λ))$</span>.</p></div></details><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>By convention, the first two qubits are the controls and the third is the target.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables λ
1-element Vector{Symbolics.Num}:
 λ

julia&gt; GateCCP(λ), numcontrols(GateCCP(λ)), numtargets(GateCCP(λ))
(C₂P(λ), 2, 1)

julia&gt; matrix(GateCCP(1.989))
8×8 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  …  0.0+0.0im       0.0+0.0im
 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im     0.0+0.0im       0.0+0.0im
 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im     0.0+0.0im       0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  1.0+0.0im     0.0+0.0im       0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im     0.0+0.0im       0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  …  0.0+0.0im       0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im     1.0+0.0im       0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im     0.0+0.0im  -0.40612+0.91382im

julia&gt; c = push!(Circuit(), GateCCP(λ), 1, 2, 3)
3-qubit circuit with 1 instructions:
└── C₂P(λ) @ q[1:2], q[3]

julia&gt; push!(c, GateCCP(π/8), 1, 2, 3)
3-qubit circuit with 2 instructions:
├── C₂P(λ) @ q[1:2], q[3]
└── C₂P(π/8) @ q[1:2], q[3]

julia&gt; power(GateCCP(λ), 2), inverse(GateCCP(λ))
(C₂P(2λ), C₂P(-λ))
</code></pre><p><strong>Decomposition</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables λ
1-element Vector{Symbolics.Num}:
 λ

julia&gt; decompose(GateCCP(λ))
3-qubit circuit with 5 instructions:
├── CP((1//2)*λ) @ q[2], q[3]
├── CX @ q[1], q[2]
├── CP((-1//2)*λ) @ q[2], q[3]
├── CX @ q[1], q[2]
└── CP((1//2)*λ) @ q[1], q[3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/standard/cnp.jl#L17-L79">source</a></section></article><h4 id="Custom-gates"><a class="docs-heading-anchor" href="#Custom-gates">Custom gates</a><a id="Custom-gates-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-gates" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateCustom" href="#MimiqCircuitsBase.GateCustom"><code>MimiqCircuitsBase.GateCustom</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GateCustom{N,T} &lt;: AbstractGate{N}</code></pre><p><code>N</code> qubit gate specified by a <span>$2^N \times 2^N$</span> matrix with elements of type <code>T</code>.</p><p>Use this to construct your own gates based on unitary matrices. Currently only N=1,2 (M=2,4) are recognised.</p><p>MIMIQ uses textbook convention for specifying gates.</p><p>One qubit gate matrices are defined in the basis <span>$|0\rangle$</span>, <span>$|1\rangle$</span> e.g.,</p><p class="math-container">\[\operatorname{Z} =
\begin{pmatrix}
    1&amp;0\\
    0&amp;-1
\end{pmatrix}\]</p><p>Two qubit gate matrices are defined in the basis <span>$|00\rangle$</span>, <span>$|01\rangle$</span>&gt;, <span>$|10\rangle$</span>, <span>$|11\rangle$</span> where the left-most qubit is the first to appear in the target list e.g.,</p><p class="math-container">\[\operatorname{CNOT} =
\begin{pmatrix}
    1&amp;0&amp;0&amp;0\\
    0&amp;1&amp;0&amp;0\\
    0&amp;0&amp;0&amp;1\\
    0&amp;0&amp;1&amp;0
\end{pmatrix}\]</p><pre><code class="nohighlight hljs">julia&gt; CNOT = [1 0 0 0; 0 1 0 0; 0 0 0 1; 0 0 1 0]
4×4 Matrix{Int64}:
 1  0  0  0
 0  1  0  0
 0  0  0  1
 0  0  1  0

julia&gt; # CNOT gate with control on q1 and target on q2

julia&gt; Instruction(GateCustom(CNOT), 1, 2)
GateCustom([1 0 0 0; 0 1 0 0; 0 0 0 1; 0 0 1 0]) @ q1, q2

# Examples
</code></pre><p>jldoctest julia&gt; g = GateCustom([1 0; 0 1]) Custom([1.0 0.0; 0.0 1.0])</p><p>julia&gt; push!(Circuit(), g, 1) 1-qubit circuit with 1 instructions: └── Custom([1.0 0.0; 0.0 1.0]) @ q1 ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/gates/custom.jl#L7-L67">source</a></section></article><h4 id="Generalized-gates"><a class="docs-heading-anchor" href="#Generalized-gates">Generalized gates</a><a id="Generalized-gates-1"></a><a class="docs-heading-anchor-permalink" href="#Generalized-gates" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.QFT" href="#MimiqCircuitsBase.QFT"><code>MimiqCircuitsBase.QFT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QFT(n)</code></pre><p>Quantum Fourier transform.</p><p>Performs the quantum Fourier transform on a register of <code>n</code> qubits.</p><p>The inverse quantum Fourier transform is simply given <code>inverse(qft)</code>.</p><p>It implements the unitary transformation.</p><p class="math-container">\[\frac{1}{2^{n/2}} \sum_{x=0}^{2^n-1} \sum_{y=0}^{2^n-1} e^{2\pi i \frac{xy}{2^n}} \ket{y}\bra{x}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = push!(Circuit(), QFT(10), 1:10...)
10-qubit circuit with 1 instructions:
└── QFT @ q[1:10]

julia&gt; push!(c, inverse(QFT(10)), 1:10...)
10-qubit circuit with 2 instructions:
├── QFT @ q[1:10]
└── QFT† @ q[1:10]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/generalized/qft.jl#L17-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.PhaseGradient" href="#MimiqCircuitsBase.PhaseGradient"><code>MimiqCircuitsBase.PhaseGradient</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PhaseGradient(n)</code></pre><p>A phase gradient gate applies a phase shift to a quantum register of <code>n</code> qubits, where each computational basis state <span>$\ket{k}$</span> experiences a phase proportional to its integer value <span>$k$</span>:</p><p class="math-container">\[\operatorname{PhaseGradient} =
\sum{k=0}^{n-1} \mathrm{e}^{i \frac{2 \pi}{N} k} \ket{k}\bra{k}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/generalized/phasegradient.jl#L17-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.PolynomialOracle" href="#MimiqCircuitsBase.PolynomialOracle"><code>MimiqCircuitsBase.PolynomialOracle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PolynomialOracle(xregsize, yregsize, a, b, c, d)
PolynomialOracle(a, b, c, d) # lazy</code></pre><p>Quantum oracle for a polynomial function of two registers.</p><p>Applies a <span>$\pi$</span> phase shift to any basis state which satifies <span>$a xy + bx + cy + d == 0$</span>, where <span>$\ket{x}$</span> and <span>$\ket{y}$</span> are the states of the two registers.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = push!(Circuit(), PolynomialOracle(5,5,1,2,3,4), 1:10...)
10-qubit circuit with 1 instructions:
└── PolynomialOracle(1, 2, 3, 4) @ q[1:5], q[6:10]

julia&gt; push!(c, inverse(PolynomialOracle(5,5,1,2,3,4)), 1:10...)
10-qubit circuit with 2 instructions:
├── PolynomialOracle(1, 2, 3, 4) @ q[1:5], q[6:10]
└── PolynomialOracle(1, 2, 3, 4) @ q[1:5], q[6:10]</code></pre><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p>This operation is not yet implemented for decomposition. Might not work with some backends, where is not specifically implemented.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/generalized/polynomialoracle.jl#L17-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.Diffusion" href="#MimiqCircuitsBase.Diffusion"><code>MimiqCircuitsBase.Diffusion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Diffusion(n)
Diffusion() # lazy</code></pre><p>Grover&#39;s diffusion operator.</p><p>It implements the unitary transformation.</p><p class="math-container">\[H^{\otimes n} (1-2\bra{0^n}\ket{0^n}) H^{\otimes n}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = push!(Circuit(), Diffusion(10), 1:10...)
10-qubit circuit with 1 instructions:
└── Diffusion @ q[1:10]

julia&gt; push!(c, inverse(Diffusion(10)), 1:10...)
10-qubit circuit with 2 instructions:
├── Diffusion @ q[1:10]
└── Diffusion† @ q[1:10]</code></pre><pre><code class="language-julia-repl hljs">julia&gt; decompose(Diffusion(4))
4-qubit circuit with 9 instructions:
├── RY(π/2) @ q[1]
├── RY(π/2) @ q[2]
├── RY(π/2) @ q[3]
├── RY(π/2) @ q[4]
├── C₃Z @ q[1:3], q[4]
├── RY(π/2) @ q[1]
├── RY(π/2) @ q[2]
├── RY(π/2) @ q[3]
└── RY(π/2) @ q[4]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/generalized/diffusion.jl#L17-L57">source</a></section></article><h3 id="Gate-definitions"><a class="docs-heading-anchor" href="#Gate-definitions">Gate definitions</a><a id="Gate-definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Gate-definitions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateCall" href="#MimiqCircuitsBase.GateCall"><code>MimiqCircuitsBase.GateCall</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateCall(decl, args...)</code></pre><p>Gate corresponding to a call to a <a href="#MimiqCircuitsBase.GateDecl"><code>GateDecl</code></a> definition.</p><p>It is created by calling a <a href="#MimiqCircuitsBase.GateDecl"><code>GateDecl</code></a> with the proper number of arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decl = @gatedecl ansatz(θ) = begin
           insts = Instruction[]
           push!(insts, Instruction(GateX(), 1))
           push!(insts, Instruction(GateRX(θ), 2))
           return insts
       end;


julia&gt; @variables λ;


julia&gt; decl(λ)
ansatz(λ)
</code></pre><p><strong>See also</strong></p><p><a href="#MimiqCircuitsBase.GateDecl"><code>GateDecl</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/gatedecl.jl#L109-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GateDecl" href="#MimiqCircuitsBase.GateDecl"><code>MimiqCircuitsBase.GateDecl</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateDecl(name, args, instructions)</code></pre><p>Define a new gate of given name, arguments and instructions.</p><p><strong>Examples</strong></p><p>A simple gate declaration, via the <code>@gatedecl</code> macro:</p><pre><code class="language-julia-repl hljs">julia&gt; decl = @gatedecl ansatz(θ) = begin
           insts = Instruction[]
           push!(insts, Instruction(GateX(), 1))
           push!(insts, Instruction(GateRX(θ), 2))
           return insts
       end
gate ansatz(θ) =
├── X @ q[1]
└── RX(θ) @ q[2]

julia&gt; @variables λ;


julia&gt; decompose(decl(λ))
2-qubit circuit with 2 instructions:
├── X @ q[1]
└── RX(λ) @ q[2]
</code></pre><p><strong>See also</strong></p><p><a href="#MimiqCircuitsBase.GateCall"><code>GateCall</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/gatedecl.jl#L1-L33">source</a></section></article><h3 id="Non-unitary-operations"><a class="docs-heading-anchor" href="#Non-unitary-operations">Non-unitary operations</a><a id="Non-unitary-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Non-unitary-operations" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.Reset" href="#MimiqCircuitsBase.Reset"><code>MimiqCircuitsBase.Reset</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Reset()</code></pre><p>Quantum operation that resets the status of one qubit to the <span>$\ket{0}$</span> state.</p><p>See also <a href="#MimiqCircuitsBase.Operation"><code>Operation</code></a>, <a href="#MimiqCircuitsBase.Measure"><code>Measure</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Reset()
Reset

julia&gt; c = push!(Circuit(), Reset, 1)
1-qubit circuit with 1 instructions:
└── Reset @ q[1]

julia&gt; push!(c, Reset(), 3)
3-qubit circuit with 2 instructions:
├── Reset @ q[1]
└── Reset @ q[3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/reset.jl#L17-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.Measure" href="#MimiqCircuitsBase.Measure"><code>MimiqCircuitsBase.Measure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Measure()</code></pre><p>Single qubit measurement operation in the computational basis</p><p>The operation projects the quantum states and stores the result of such measurement is stored in a classical register.</p><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p><code>Measure</code> is non-reversible.</p></div></div><p>See also <a href="#MimiqCircuitsBase.Operation"><code>Operation</code></a>, <a href="#MimiqCircuitsBase.Reset"><code>Reset</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Measure()
Measure

julia&gt; c = push!(Circuit(), Measure, 1, 1)
1-qubit circuit with 1 instructions:
└── Measure @ q[1], c[1]

julia&gt; push!(c, Measure(), 3, 4)
3-qubit circuit with 2 instructions:
├── Measure @ q[1], c[1]
└── Measure @ q[3], c[4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/measure.jl#L17-L45">source</a></section></article><h3 id="No-ops"><a class="docs-heading-anchor" href="#No-ops">No-ops</a><a id="No-ops-1"></a><a class="docs-heading-anchor-permalink" href="#No-ops" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.Barrier" href="#MimiqCircuitsBase.Barrier"><code>MimiqCircuitsBase.Barrier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Barrier(numqubits)</code></pre><p>No-op operation that does not affect the quantum state or the execution of a circuit, but prevents compression or optimization across it.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Barrier(1)
Barrier

julia&gt; Barrier(2)
Barrier

julia&gt; c = push!(Circuit(), Barrier(1), 1)
1-qubit circuit with 1 instructions:
└── Barrier @ q[1]

julia&gt; push!(c, Barrier(1), 1:3)
3-qubit circuit with 4 instructions:
├── Barrier @ q[1]
├── Barrier @ q[1]
├── Barrier @ q[2]
└── Barrier @ q[3]

julia&gt; push!(c, Barrier(3), 1,2,3)
3-qubit circuit with 5 instructions:
├── Barrier @ q[1]
├── Barrier @ q[1]
├── Barrier @ q[2]
├── Barrier @ q[3]
└── Barrier @ q[1:3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/operations/barrier.jl#L17-L51">source</a></section></article><h2 id="Bit-Strings"><a class="docs-heading-anchor" href="#Bit-Strings">Bit Strings</a><a id="Bit-Strings-1"></a><a class="docs-heading-anchor-permalink" href="#Bit-Strings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.BitString" href="#MimiqCircuitsBase.BitString"><code>MimiqCircuitsBase.BitString</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BitString(numbits)</code></pre><p>Representation of the state of a register of bits. Can also represent the state of a register of qubits with defined values for each qubit (0 or 1).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; BitString(16)
16-bits BitString with integer value 0:
  00000000 00000000

julia&gt; bs = BitString(16, [1,2,3,4])
16-bits BitString with integer value 15:
  11110000 00000000

julia&gt; bs[10] = 1
1

julia&gt; bs
16-bits BitString with integer value 527:
  11110000 01000000

julia&gt; bitstring_to_integer(bs)
527

julia&gt; typeof(ans)
BigInt

julia&gt; bitstring_to_integer(bs, Int)
527

julia&gt; typeof(ans)
Int64</code></pre><p>There are many different ways to get bit states:</p><pre><code class="language-julia-repl hljs">julia&gt; bs = BitString(30, 2344574)
30-bits BitString with integer value 2344574:
  01111110 01100011 11000100 000000

julia&gt; ones(BitString, 10) # or also trues(BitString, 10)
10-bits BitString with integer value 1023:
  11111111 11

julia&gt; zeros(BitString, 10) # or also falses(BitString, 10)
10-bits BitString with integer value 0:
  00000000 00

julia&gt; BitString(16) do i
           iseven(i)
       end
16-bits BitString with integer value 43690:
  01010101 01010101</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/bitstrings.jl#L17-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.bitstring_to_index-Tuple{BitString}" href="#MimiqCircuitsBase.bitstring_to_index-Tuple{BitString}"><code>MimiqCircuitsBase.bitstring_to_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bitstring_to_index(bitstring)</code></pre><p>Convert a bitstring into the corresponding index.</p><p>This is useful for indexing, for example, a vector of states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/bitstrings.jl#L110-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.bitstring_to_integer" href="#MimiqCircuitsBase.bitstring_to_integer"><code>MimiqCircuitsBase.bitstring_to_integer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bitstring_to_integer(bitstring[, T])</code></pre><p>Convert a bitstring into its corresponding integer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/bitstrings.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.nonzeros-Tuple{BitString}" href="#MimiqCircuitsBase.nonzeros-Tuple{BitString}"><code>MimiqCircuitsBase.nonzeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nonzeros(bitstring)</code></pre><p>Return the indices of the non-zero qubits in a bit state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/bitstrings.jl#L130-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.to01-Tuple{BitString}" href="#MimiqCircuitsBase.to01-Tuple{BitString}"><code>MimiqCircuitsBase.to01</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to01(bitstring[, endianess=:big])</code></pre><p>Converts a BitString into a string of 0 and 1 characters. Optionally endianess can be specified, which can be either <code>:big</code> or <code>:little</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; to01(bs&quot;10011&quot;)
&quot;10011&quot;

julia&gt; to01(bs&quot;10011&quot;; endianess=:big)
&quot;10011&quot;

julia&gt; to01(bs&quot;10011&quot;; endianess=:little)
&quot;11001&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/bitstrings.jl#L231-L249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.tobits-Tuple{BitString}" href="#MimiqCircuitsBase.tobits-Tuple{BitString}"><code>MimiqCircuitsBase.tobits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tobits(bitstring)</code></pre><p>Get the underlying BitVector of a bit state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/bitstrings.jl#L294-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.@bs_str-Tuple{Any}" href="#MimiqCircuitsBase.@bs_str-Tuple{Any}"><code>MimiqCircuitsBase.@bs_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">macro bs_str(s)</code></pre><p>Convert a string into a bit state.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bs&quot;101011&quot;
6-bits BitString with integer value 53:
  101011</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/bitstrings.jl#L277-L289">source</a></section></article><h2 id="Results-of-simulations"><a class="docs-heading-anchor" href="#Results-of-simulations">Results of simulations</a><a id="Results-of-simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Results-of-simulations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.QCSResults" href="#MimiqCircuitsBase.QCSResults"><code>MimiqCircuitsBase.QCSResults</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QCSRresults()
QCSRresults(simulator, version, fidelities, avggateerrors, cstates, zstates, amplitudes, timings)</code></pre><p>Storage for the results of a quantum circuit simulation.</p><p><strong>Fields</strong></p><ul><li><code>simulator</code>: name of the simulator used,</li><li><code>version</code>: version of the simulator used,</li><li><code>fidelities</code>: fidelity estimates,</li><li><code>avggateerrors</code>: average multiqubit gate errors,</li><li><code>cstates</code>: classical states content,</li><li><code>zstates</code>: complex valued states content (not used),</li><li><code>amplitudes</code>: amplitudes,</li><li><code>timings</code>: precise timings of the execution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/qcsresults.jl#L17-L33">source</a></section></article><h2 id="Symbolics"><a class="docs-heading-anchor" href="#Symbolics">Symbolics</a><a id="Symbolics-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.issymbolic" href="#MimiqCircuitsBase.issymbolic"><code>MimiqCircuitsBase.issymbolic</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Check whether the circuit contains any symbolic (unevaluated) parameters.</p><p>This method examines each instruction in the circuit to determine if any parameter remains symbolic (i.e., unevaluated). It recursively checks through each instruction and its nested  operations, if any. Returns True if any parameter is symbolic (unevaluated), False if all parameters are fully evaluated.</p><p>```jldoctests julia&gt; c = Circuit() empty circuit</p><p>julia&gt; push!(c, GateH(), 1) 1-qubit circuit with 1 instructions: └── H @ q[1]</p><p>julia&gt; issymbolic(c) false</p><p>julia&gt; @variables x y 2-element Vector{Symbolics.Num}:  x  y</p><p>julia&gt; push!(c,Control(3,GateP(x+y)),1,2,3,4) 4-qubit circuit with 2 instructions: ├── H @ q[1] └── C₃P(x + y) @ q[1:3], q[4]</p><p>julia&gt; issymbolic(c) true</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/5550dd7abd0978bd96074e2094976b48cdc53a77/src/symbolics.jl#L18-L51">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../operations/">« List of Operations</a><a class="docs-footer-nextpage" href="../internals/">Internals »</a><div class="flexbox-break"></div><p class="footer-message">Copyright 2021-2024 QPerfect. All rights reserved.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Monday 3 June 2024 02:16">Monday 3 June 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
